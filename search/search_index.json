{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"R-Type Documentation","text":"<p>Welcome to the documentation for the R-Type Game Engine project. This documentation will guide you through setting up, developing, and contributing to the project.</p>"},{"location":"#introduction","title":"Introduction","text":""},{"location":"#goal-of-the-project","title":"Goal of the Project","text":"<p>The goal of this project is to develop a multi-threaded server and a graphical client for a networked version of the classic shoot 'em up game R-Type, using a custom-built game engine. The project will teach advanced C++ development techniques, software engineering practices, and networked game development.</p>"},{"location":"#different-parts-and-description","title":"Different Parts and Description","text":"<ol> <li> <p>Game Engine: The core of the project, containing the various subsystems such as rendering, physics, audio, and more. Decoupling these subsystems is crucial for better architecture and maintainability. The engine must support a modular design and ensure optimized resource management.</p> </li> <li> <p>Networking: The game is networked, with multiple clients connecting to a server. The server is responsible for handling the game logic and updating the clients with the current game state. Clients communicate via UDP, and mechanisms to handle network errors, latency, and synchronization are vital.</p> </li> <li> <p>Game Logic: The game logic resides on the server, ensuring authoritative gameplay. It manages player actions, enemy behavior, missile trajectories, collisions, and more. Client-side logic exists for handling inputs and rendering, but the server makes the final decisions.</p> </li> <li> <p>Gameplay Features: Players control spaceships to battle waves of enemy Bydos. Each player can shoot missiles, and there are multiple players per game session. The game world features a scrolling background, enemies, obstacles, and player missiles, providing a rich gameplay experience.</p> </li> </ol>"},{"location":"Comparerative_Analysis/","title":"Comparerative Analysis","text":""},{"location":"accessibility/","title":"Acessibility","text":""},{"location":"advanced_topics/","title":"Advanced Topics","text":""},{"location":"ci_cd/","title":"R-Type Project: Testing and CI/CD Documentation","text":""},{"location":"ci_cd/#overview","title":"Overview","text":"<p>This document outlines the Continuous Integration and Continuous Deployment (CI/CD) process for the R-Type project. We use GitHub Actions to automate our build, test, and deployment processes.</p>"},{"location":"ci_cd/#cicd-workflow","title":"CI/CD Workflow","text":"<p>Our CI/CD pipeline is defined in the <code>.github/workflows/ci.yml</code> file. The workflow is triggered on: - Push events to the <code>main</code> and <code>Develop</code> branches - Pull requests to the <code>main</code> branch</p>"},{"location":"ci_cd/#workflow-details","title":"Workflow Details","text":""},{"location":"ci_cd/#name-ci-r-type","title":"Name: CI R-Type","text":""},{"location":"ci_cd/#jobs","title":"Jobs:","text":"<p>We have a single job named <code>build</code> that runs on the latest Ubuntu environment.</p>"},{"location":"ci_cd/#build-matrix","title":"Build Matrix:","text":"<p>We use a build matrix to define our build configuration: - Operating System: Ubuntu Latest - Build Type: Release - C Compiler: GCC - C++ Compiler: G++</p>"},{"location":"ci_cd/#steps","title":"Steps:","text":"<ol> <li> <p>Checkout: Uses <code>actions/checkout@v4</code> to fetch the repository.</p> </li> <li> <p>Caching:</p> </li> <li>Conan dependencies are cached using <code>actions/cache@v4</code></li> <li> <p>Build output is cached to speed up subsequent builds</p> </li> <li> <p>System Updates and Dependencies:</p> </li> <li>Updates <code>apt-get</code></li> <li> <p>Installs necessary system libraries and development packages</p> </li> <li> <p>CMake Installation:</p> </li> <li> <p>Installs CMake using <code>apt-get</code></p> </li> <li> <p>Google Test Setup:</p> </li> <li> <p>Configures and builds Google Test from source</p> </li> <li> <p>Conan Setup:</p> </li> <li>Installs Conan package manager</li> <li> <p>Creates a default Conan profile</p> </li> <li> <p>Dependencies Installation:</p> </li> <li> <p>Uses Conan to install project dependencies</p> </li> <li> <p>CMake Configuration:</p> </li> <li>Configures the project using CMake</li> <li> <p>Sets the C++ compiler, C compiler, and build type</p> </li> <li> <p>Build:</p> </li> <li>Builds the project using CMake</li> </ol>"},{"location":"ci_cd/#worflow","title":"Worflow","text":"<pre><code>name: CI R-Type\n\non:\n  push:\n    branches:\n      - main\n      - Develop\n  pull_request:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ${{ matrix.os }}\n\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [ubuntu-latest]\n        build_type: [Release]\n        c_compiler: [gcc]\n        cpp_compiler: [g++]\n        include:\n          - os: ubuntu-latest\n            c_compiler: gcc\n            cpp_compiler: g++\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Cache Conan dependencies\n        uses: actions/cache@v4\n        with:\n          path: |\n            ~/.conan/data\n            ~/.conan\n          key: ${{ runner.os }}-conan-${{ hashFiles('conanfile.txt') }}\n          restore-keys: |\n            ${{ runner.os }}-conan-\n\n      - name: Cache build output\n        uses: actions/cache@v4\n        with:\n          path: build\n          key: ${{ runner.os }}-build-${{ hashFiles('**/CMakeLists.txt', '**/*.cpp', '**/*.h*') }}\n          restore-keys: |\n            ${{ runner.os }}-build-\n\n      - name: Update apt-get\n        if: matrix.os == 'ubuntu-latest'\n        run: |\n          sudo apt-get update\n          sudo apt-get upgrade -y\n          sudo apt-get install -y libudev-dev libgl-dev \\\n            libx11-dev libx11-xcb-dev libfontenc-dev libboost-all-dev \\\n            libgtest-dev libice-dev libsm-dev libxau-dev \\\n            libxaw7-dev\n\n      - name: Install CMake\n        if: matrix.os == 'ubuntu-latest'\n        run: sudo apt-get install -y cmake\n\n      - name: Set google test\n        if: matrix.os == 'ubuntu-latest'\n        run: |\n          cd /usr/src/gtest\n          sudo cmake .\n          sudo make\n\n      - name: Install Conan\n        run: pip install conan\n\n      - name: Conan version\n        run: conan --version\n\n      - name: Create default Conan profile\n        run: conan profile detect --force\n\n      - name: Install dependencies\n        if : matrix.os == 'ubuntu-latest'\n        run: |\n          conan install . --build=missing \\\n          -c tools.system.package_manager:mode=install \\\n          -c tools.system.package_manager:sudo=True\n\n      - name: Set reusable strings\n        id: strings\n        shell: bash\n        run: echo \"build-output-dir=${{ github.workspace }}/build\" &gt;&gt; \"$GITHUB_OUTPUT\"\n\n      - name: Configure CMake\n        if : matrix.os == 'ubuntu-latest'\n        run: |\n          cmake -B ${{ steps.strings.outputs.build-output-dir }} \\\n          -DCMAKE_CXX_COMPILER=${{ matrix.cpp_compiler }} \\\n          -DCMAKE_C_COMPILER=${{ matrix.c_compiler }} \\\n          -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} \\\n          -S ${{ github.workspace }}\n\n      - name: Build\n        if : matrix.os == 'ubuntu-latest'\n        run: |\n          cmake --build ${{ steps.strings.outputs.build-output-dir }} \\\n          --config ${{ matrix.build_type }}\n</code></pre>"},{"location":"ci_cd/#testing","title":"Testing","text":"<p>While not explicitly shown in the workflow, it's implied that Google Test is set up for unit testing. To run tests:</p> <ol> <li>Ensure Google Test is properly set up (as done in the workflow).</li> <li>Add a step in the workflow to run tests after the build step:</li> </ol> <pre><code>- name: Run Tests\n  working-directory: ${{ steps.strings.outputs.build-output-dir }}\n  run: ctest -C ${{ matrix.build_type }}\n</code></pre>"},{"location":"ci_cd/#deployment","title":"Deployment","text":"<p>The current workflow does not include deployment steps. When ready to add deployment:</p> <ol> <li>Add a new job or steps after the build job.</li> <li>Use appropriate GitHub Actions for your deployment target (e.g., AWS, Azure, GCP, etc.).</li> <li>Ensure all necessary secrets are stored in GitHub Secrets.</li> </ol>"},{"location":"ci_cd/#best-practices","title":"Best Practices","text":"<ol> <li>Regular Updates: Keep dependencies and tools updated regularly.</li> <li>Code Quality: Consider adding static code analysis tools to the workflow.</li> <li>Security Scanning: Implement security scanning for vulnerabilities.</li> <li>Documentation: Update this documentation as the workflow evolves.</li> </ol>"},{"location":"ci_cd/#troubleshooting","title":"Troubleshooting","text":"<p>If the CI/CD pipeline fails:</p> <ol> <li>Check the GitHub Actions logs for detailed error messages.</li> <li>Ensure all dependencies are correctly specified in the project files.</li> <li>Verify that the build matrix is appropriate for your project needs.</li> <li>Test the build process locally to isolate issues.</li> </ol>"},{"location":"ci_cd/#future-improvements","title":"Future Improvements","text":"<ol> <li>Add code coverage reporting.</li> <li>Implement automatic versioning.</li> <li>Set up automatic releases for tagged commits.</li> <li>Add performance benchmarking tests.</li> </ol> <p>This documentation provides an overview of your current CI/CD setup and includes suggestions for testing and future improvements. As your project evolves, remember to keep this documentation updated to reflect any changes in your CI/CD process.</p>"},{"location":"protocol/","title":"R-TYPE Multiplayer Game Protocol (MGP) over UDP","text":"<p>The Multiplayer Game Protocol (MGP) is a communication protocol designed for real-time multiplayer games, specifically for the R-TYPE game. This document outlines the structure and functionality of MGP, which operates over UDP to facilitate efficient and low-latency communication between a server and multiple clients.</p>"},{"location":"protocol/#2-terminology","title":"2. Terminology","text":"<ul> <li>Client: The player-side application.</li> <li>Server: The authoritative source for player and entity positions, game state, etc.</li> <li>Entity: A game object (players, enemies, etc.).</li> <li>ID: A unique identifier for each entity.</li> </ul>"},{"location":"protocol/#3-protocol-overview","title":"3. Protocol Overview","text":"<p>MGP operates over UDP to prioritize real-time performance. The protocol consists of simple hexadecimal identifiers (opcodes) followed by data payloads. Both the server and the client exchange these messages to synchronize game states.</p>"},{"location":"protocol/#4-message-structure","title":"4. Message Structure","text":"<p>Each message consists of:</p> <ul> <li>Opcode: A 1-byte hexadecimal identifier indicating the type of message.</li> <li>Payload: Additional data (e.g., position, player life) relevant to the message.</li> </ul> <pre><code>+---------------------+\n|      Message        |\n+---------------------+\n| Opcode (1 Byte)     |\n+---------------------+\n| Payload (Variable)  |\n+---------------------+\n</code></pre>"},{"location":"protocol/#5-message-types","title":"5. Message Types","text":""},{"location":"protocol/#51-client-to-server-messages","title":"5.1. Client to Server Messages","text":""},{"location":"protocol/#511-0x01-client-connection-request","title":"5.1.1. 0x01: Client Connection Request","text":"<ul> <li>Description: The client sends this message to request a connection to the server.</li> <li>Payload: None.</li> <li>Server Response: The server responds with <code>0x02</code> (Connection Acknowledgment).</li> </ul>"},{"location":"protocol/#512-0x03-client-input-movement","title":"5.1.2. 0x03: Client Input (Movement)","text":"<ul> <li>Description: The client sends movement inputs to the server.</li> <li>Payload:</li> </ul> Field Size (bytes) Description Input 1 Direction of movement. <ul> <li> <p>Possible values for Input:</p> <ul> <li>0x01: Up</li> <li>0x02: Down</li> <li>0x03: Left</li> <li>0x04: Right</li> </ul> </li> <li> <p>Server Response: The server processes the input and updates player positions.</p> </li> </ul>"},{"location":"protocol/#513-additional-client-messages","title":"5.1.3. Additional Client Messages","text":"<ul> <li>Description: Clients can send other messages based on game design (e.g., shooting, item pickup). These are assigned specific opcodes based on game requirements.</li> </ul>"},{"location":"protocol/#52-server-to-client-messages","title":"5.2. Server to Client Messages","text":""},{"location":"protocol/#521-0x02-server-acknowledgment-of-connection","title":"5.2.1. 0x02: Server Acknowledgment of Connection","text":"<ul> <li>Description: The server sends this message to acknowledge a client's connection request.</li> <li>Payload: None.</li> </ul>"},{"location":"protocol/#522-0x05-player-position-update","title":"5.2.2. 0x05: Player Position Update","text":"<ul> <li>Description: The server broadcasts updated player positions to all clients.</li> <li>Payload:</li> </ul> Field Size (bytes) Description PlayerID 1 ID of the player being updated. X Pos 2 X coordinate of the player. Y Pos 2 Y coordinate of the player. <p>This message contains the positions of all players currently connected to the game.</p>"},{"location":"protocol/#523-0x07-player-life-and-score-update","title":"5.2.3. 0x07: Player Life and Score Update","text":"<ul> <li>Description: The server sends updates on a player's life and score.</li> <li>Payload:</li> </ul> Field Size (bytes) Description PlayerID 1 ID of the player whose data is updated. Life 1 Remaining life of the player. Score 2 Player\u2019s current score."},{"location":"protocol/#524-0x09-entity-death-notification","title":"5.2.4. 0x09: Entity Death Notification","text":"<ul> <li>Description: The server notifies clients of entities (e.g., enemies) that have been destroyed.</li> <li>Payload:</li> </ul> Field Size (bytes) Description EntityID 1 ID of the entity that was destroyed."},{"location":"protocol/#525-0x04-player-disconnection-notice","title":"5.2.5. 0x04: Player Disconnection Notice","text":"<ul> <li>Description: The server sends this message when a player disconnects from the game.</li> <li>Payload:</li> </ul> Field Size (bytes) Description PlayerID 1 ID of the player who disconnected."},{"location":"protocol/#526-other-server-messages","title":"5.2.6. Other Server Messages","text":"<ul> <li>Description: Additional messages can be implemented based on specific game requirements, such as broadcasting new enemies, missiles, or item pickups (e.g., coins).</li> </ul>"},{"location":"protocol/#6-message-flow","title":"6. Message Flow","text":"<ol> <li>Client Connection</li> <li>The client sends <code>0x01</code> (Connection Request).</li> <li> <p>The server responds with <code>0x02</code> (Connection Acknowledgment).</p> </li> <li> <p>Client Movement Input</p> </li> <li>The client sends <code>0x03</code> with a movement direction.</li> <li> <p>The server processes the movement and sends updated positions using <code>0x05</code> to all clients.</p> </li> <li> <p>Player Status Updates</p> </li> <li>The server periodically sends <code>0x07</code> to update each client\u2019s life and score.</li> <li> <p>If any entities die during the game, the server broadcasts <code>0x09</code> to notify all clients.</p> </li> <li> <p>Disconnection Handling</p> </li> <li>If a player disconnects, the server sends <code>0x04</code> to all clients to notify them of the disconnection.</li> </ol>"},{"location":"protocol/#7-error-handling","title":"7. Error Handling","text":"<p>UDP is a connectionless protocol, and there is no guarantee of message delivery. Therefore, the protocol should handle the following cases:</p> <ul> <li>Lost Packets: If a message is not received, the client should resend input, and the server should regularly broadcast state updates.</li> <li>Out-of-Order Packets: The client must be prepared to handle messages arriving in the wrong order (e.g., receiving player status before the initial connection acknowledgment).</li> </ul>"},{"location":"protocol/#8-security-considerations","title":"8. Security Considerations","text":"<p>Since this protocol runs over UDP, it is vulnerable to spoofing and man-in-the-middle attacks. Therefore, implementing encryption or adding a verification layer at the application level is recommended.</p>"},{"location":"protocol/#9-conclusion","title":"9. Conclusion","text":"<p>The MGP protocol is designed for efficient real-time communication between a server and multiple clients in a multiplayer game. It leverages the low-latency benefits of UDP while ensuring synchronization of player actions and game states.</p>"},{"location":"references/","title":"References","text":""},{"location":"security_performance/","title":"Security &amp; Performance","text":"<p>Security Review:</p> <p>The MGP protocol, as described, does not include any built-in security measures. Since it operates over UDP, which is a connectionless protocol, it is vulnerable to spoofing and man-in-the-middle attacks. This could potentially allow an unauthorized user to impersonate a client or server, or to intercept and modify data in transit.</p> <p>To address these security concerns, it is recommended to implement encryption for all data transmitted over the network. This could be done using a secure protocol like TLS/SSL, or by implementing encryption at the application level. Additionally, a verification layer could be added to ensure that messages are authentic and have not been tampered with.</p> <p>Performance Review:</p> <p>The MGP protocol is designed to prioritize real-time performance by operating over UDP. This allows for low-latency communication between the server and clients, which is crucial for a smooth and responsive multiplayer gaming experience.</p> <p>The protocol uses simple hexadecimal identifiers (opcodes) followed by data payloads, which allows for efficient parsing and processing of messages. The use of UDP also means that the protocol is lightweight and does not require the overhead of establishing and maintaining a connection between the server and each client.</p> <p>However, the protocol does not include any mechanisms for handling lost or out-of-order packets. This could potentially lead to issues with synchronization between the server and clients, particularly in the case of network congestion or other disruptions. To address these performance concerns, it may be necessary to implement mechanisms for handling lost or out-of-order packets, such as requesting resends or reordering messages.</p> <p>Overall, the MGP protocol is well-suited for real-time multiplayer gaming, and its use of UDP allows for low-latency communication. However, to ensure the security and reliability of the system, it is recommended to implement encryption and a verification layer, as well as mechanisms for handling lost or out-of-order packets.</p>"},{"location":"system_requirements/","title":"System Requirements","text":"<ul> <li>Language: C++</li> <li>Build System: CMake</li> <li>Package Manager: Conan</li> <li>Operating Systems: Linux (required), Windows (cross-platform support preferred)</li> <li>Network Communication: UDP protocol for client-server communication (TCP allowed for specific purposes)</li> <li>Libraries: Asio (networking), SFML (optional for rendering, audio, input)</li> </ul> <p>Note: Ensure that you have all the required dependencies installed before building the project. This includes CMake, Conan, and the necessary libraries such as Asio and optionally SFML.</p>"},{"location":"testing_ci_cd/","title":"Unit Tests","text":"<p>Certainly! I'll create a testing and unit test section using the provided code as an example and provide instructions for setting up and running the tests. Here's the documentation:</p>"},{"location":"testing_ci_cd/#testing-and-unit-tests","title":"Testing and Unit Tests","text":""},{"location":"testing_ci_cd/#overview","title":"Overview","text":"<p>This section covers the unit testing setup for the AudioManager class using Google Test (gtest) framework. The tests are designed to verify the functionality of various audio operations such as playing music, pausing, resuming, and adjusting audio properties.</p>"},{"location":"testing_ci_cd/#setup","title":"Setup","text":"<p>To run the unit tests, you'll need to have Google Test installed and properly linked to your project. Here are the steps to set up the testing environment:</p> <ol> <li> <p>Install Google Test:    <pre><code>sudo apt-get install libgtest-dev\n</code></pre></p> </li> <li> <p>Build Google Test:    <pre><code>cd /usr/src/gtest\nsudo cmake .\nsudo make\nsudo cp lib/*.a /usr/lib\n</code></pre></p> </li> <li> <p>In your CMakeLists.txt, add the following lines to link Google Test:    <pre><code>find_package(GTest REQUIRED)\ninclude_directories(${GTEST_INCLUDE_DIRS})\n</code></pre></p> </li> <li> <p>Link your test executable with GTest:    <pre><code>target_link_libraries(your_test_executable ${GTEST_LIBRARIES} pthread)\n</code></pre></p> </li> </ol>"},{"location":"testing_ci_cd/#test-structure","title":"Test Structure","text":"<p>The tests are organized using a test fixture class <code>AudioTest</code> which inherits from <code>::testing::Test</code>. This allows for common setup and teardown operations across multiple tests.</p> <pre><code>class AudioTest : public ::testing::Test {\nprotected:\n    AudioManager audioManager;\n    void SetUp() override {\n        // Add any setup code here\n    }\n\n    void TearDown() override {\n        // Add any teardown code here\n    }\n};\n</code></pre>"},{"location":"testing_ci_cd/#writing-tests","title":"Writing Tests","text":"<p>Each test is written as a separate TEST_F macro, which allows access to the <code>audioManager</code> instance defined in the <code>AudioTest</code> fixture. Here's an example of a test case:</p> <pre><code>TEST_F(AudioTest, AudioManagerTest) {\n    audioManager.playMusic(\"assets/audio/Effect/boom.ogg\");\n    audioManager.pauseMusic();\n    audioManager.resumeMusic();\n    audioManager.setMusicVolume(50);\n    audioManager.setSoundVolume(50);\n    audioManager.setPitch(1.5);\n}\n</code></pre>"},{"location":"testing_ci_cd/#running-tests","title":"Running Tests","text":"<p>To run the tests, compile your test file and execute the resulting binary. The <code>main</code> function is already set up to run all tests:</p> <pre><code>int main(int argc, char **argv) {\n    ::testing::InitGoogleTest(&amp;argc, argv);\n    return RUN_ALL_TESTS();\n}\n</code></pre>"},{"location":"testing_ci_cd/#test-cases","title":"Test Cases","text":"<p>The provided code includes multiple test cases, each testing different aspects of the AudioManager:</p> <ol> <li>Playing different audio files (both .ogg and .wav formats)</li> <li>Pausing and resuming music</li> <li>Setting music and sound volumes</li> <li>Adjusting pitch</li> </ol> <p>Each test case follows a similar pattern of playing a music file, pausing, resuming, and adjusting various audio properties.</p>"},{"location":"testing_ci_cd/#best-practices","title":"Best Practices","text":"<ol> <li> <p>File Paths: Ensure that the audio file paths in the tests are correct and the files exist in your project structure.</p> </li> <li> <p>Error Handling: Consider adding tests for error cases, such as trying to play non-existent files or setting invalid volume/pitch values.</p> </li> <li> <p>Isolation: Each test should be independent. If necessary, add teardown code to reset the AudioManager state between tests.</p> </li> <li> <p>Assertions: The current tests don't include explicit assertions. Consider adding EXPECT_NO_THROW or other appropriate assertions to verify that operations complete successfully.</p> </li> <li> <p>Coverage: Aim to test all public methods of the AudioManager class, including edge cases and potential error conditions.</p> </li> </ol>"},{"location":"testing_ci_cd/#example-adding-assertions","title":"Example: Adding Assertions","text":"<p>To improve the tests, you could add assertions like this:</p> <pre><code>TEST_F(AudioTest, AudioManagerVolumeTest) {\n    audioManager.playMusic(\"assets/audio/Music/menu1.ogg\");\n    audioManager.setMusicVolume(75);\n    EXPECT_EQ(75, audioManager.getMusicVolume());  // Assuming getMusicVolume() method exists\n    audioManager.setSoundVolume(50);\n    EXPECT_EQ(50, audioManager.getSoundVolume());  // Assuming getSoundVolume() method exists\n}\n</code></pre> <p>By following these guidelines and examples, you can create a comprehensive test suite for your AudioManager class, ensuring its reliability and correctness across various usage scenarios.</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Animation_8cpp/","title":"File Animation.cpp","text":"<p>FileList &gt; Animation &gt; Animation.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../../include/Engine/Animation/Animation.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Engine/Animation/Animation.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Animation_8cpp_source/","title":"File Animation.cpp","text":"<p>File List &gt; Animation &gt; Animation.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"../../../include/Engine/Animation/Animation.hpp\"\n\nAnimation::Animation() : frameTime(0.1f), currentFrame(0)\n{\n    animations[\"red\"].loadFromFile(\"assets/image/Player/red1.gif\");\n    animations[\"green\"].loadFromFile(\"assets/image/Enemie/Blaster.png\");\n    animations[\"yellow\"].loadFromFile(\"assets/image/Enemie/BlasterB.png\");\n    animations[\"purple\"].loadFromFile(\"assets/image/Enemie/BlasterC.png\");\n    animations[\"orange\"].loadFromFile(\"assets/image/Enemie/SniperA.png\");\n    animations[\"pink\"].loadFromFile(\"assets/image/Enemie/SniperB.png\");\n    animations[\"cyan\"].loadFromFile(\"assets/image/Enemie/SniperC.png\");\n    animations[\"brown\"].loadFromFile(\"assets/image/Enemie/TankerA.png\");\n    animations[\"white\"].loadFromFile(\"assets/image/Enemie/TankerB.png\");\n    animations[\"black\"].loadFromFile(\"assets/image/Enemie/TankerC.png\");\n    animations[\"boss\"].loadFromFile(\"assets/image/Enemie/TankerC.png\");\n    animations[\"blue\"].loadFromFile(\"assets/image/Player/blue.png\");\n}\n\nAnimation::~Animation()\n{\n}\n\nvoid Animation::loadAnimation(const std::string &amp;name_by_color, int frames, float x = 1, float y = 1)\n{\n    if (animations.find(name_by_color) != animations.end())\n    {\n        AnimationData data;\n        data.sprite.setTexture(animations[name_by_color]);\n        data.totalFrames = frames;\n        data.currentFrame = 0;\n        data.sprite.setScale(x, y);\n        animationsData[name_by_color] = data;\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Error: animation of \" &lt;&lt; name_by_color &lt;&lt; \" not found\" &lt;&lt; std::endl;\n    }\n}\n\nvoid Animation::update(const std::string &amp;name_by_color)\n{\n    if (animationsData.find(name_by_color) != animationsData.end())\n    {\n        AnimationData &amp;data = animationsData[name_by_color];\n        int frameWidth = data.sprite.getTexture()-&gt;getSize().x / data.totalFrames;\n\n        if (data.clock.getElapsedTime().asSeconds() &gt;= frameTime)\n        {\n            data.currentFrame = (data.currentFrame + 1) % data.totalFrames;\n            data.sprite.setTextureRect(sf::IntRect(data.currentFrame * frameWidth, 0, frameWidth,\n                                                   data.sprite.getTexture()-&gt;getSize().y));\n            data.clock.restart();\n        }\n    }\n}\n\nvoid Animation::render(sf::RenderWindow &amp;window, const std::string &amp;name_by_color)\n{\n    if (animationsData.find(name_by_color) != animationsData.end())\n    {\n        window.draw(animationsData[name_by_color].sprite);\n    }\n    /*window.draw(sprite);*/\n}\n\nvoid Animation::setScale(float scaleX, float scaleY)\n{\n    sprite.setScale(scaleX, scaleY);\n}\n\nvoid Animation::setPosition(const std::string &amp;name_by_color, float x, float y)\n{\n    if (animationsData.find(name_by_color) != animationsData.end())\n    {\n        animationsData[name_by_color].sprite.setPosition(x, y);\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Error: animation of \" &lt;&lt; name_by_color &lt;&lt; \" not found\" &lt;&lt; std::endl;\n    }\n}\n\nvoid Animation::moveY(const std::string &amp;name_by_color, float SpeedY)\n{\n    if (animationsData.find(name_by_color) != animationsData.end())\n    {\n        sf::Vector2f currentPosition = animationsData[name_by_color].sprite.getPosition();\n\n        animationsData[name_by_color].sprite.setPosition(currentPosition.x,\n                                                         currentPosition.y + SpeedY);\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Error: animation of \" &lt;&lt; name_by_color &lt;&lt; \" not found\" &lt;&lt; std::endl;\n    }\n}\n\nvoid Animation::moveYUp(const std::string &amp;name_by_color, float SpeedY)\n{\n    if (animationsData.find(name_by_color) != animationsData.end())\n    {\n        sf::Vector2f currentPosition = animationsData[name_by_color].sprite.getPosition();\n        animationsData[name_by_color].sprite.setPosition(currentPosition.x,\n                                                         currentPosition.y - SpeedY);\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Error: animation of \" &lt;&lt; name_by_color &lt;&lt; \" not found\" &lt;&lt; std::endl;\n    }\n}\n\nvoid Animation::moveXRight(const std::string &amp;name_by_color, float SpeedX)\n{\n    if (animationsData.find(name_by_color) != animationsData.end())\n    {\n        sf::Vector2f currentPosition = animationsData[name_by_color].sprite.getPosition();\n        animationsData[name_by_color].sprite.setPosition(currentPosition.x + SpeedX,\n                                                         currentPosition.y);\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Error: animation of \" &lt;&lt; name_by_color &lt;&lt; \" not found\" &lt;&lt; std::endl;\n    }\n}\n\nvoid Animation::moveXLeft(const std::string &amp;name_by_color, float SpeedX)\n{\n    if (animationsData.find(name_by_color) != animationsData.end())\n    {\n        sf::Vector2f currentPosition = animationsData[name_by_color].sprite.getPosition();\n        animationsData[name_by_color].sprite.setPosition(currentPosition.x - SpeedX,\n                                                         currentPosition.y);\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Error: animation of \" &lt;&lt; name_by_color &lt;&lt; \" not found\" &lt;&lt; std::endl;\n    }\n}\n\nsf::Vector2f Animation::getPosition(const std::string &amp;name_by_color)\n{\n    if (animationsData.find(name_by_color) != animationsData.end())\n    {\n        return animationsData[name_by_color].sprite.getPosition();\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Error: animation of \" &lt;&lt; name_by_color &lt;&lt; \" not found\" &lt;&lt; std::endl;\n        return sf::Vector2f(0, 0);\n    }\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Animation_8hpp/","title":"File Animation.hpp","text":"<p>FileList &gt; Animation &gt; Animation.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> <li><code>#include &lt;SFML/Window.hpp&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Animation_8hpp/#classes","title":"Classes","text":"Type Name class Animation struct AnimationData <p>The documentation for this class was generated from the following file <code>include/Engine/Animation/Animation.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Animation_8hpp_source/","title":"File Animation.hpp","text":"<p>File List &gt; Animation &gt; Animation.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef ANIMATION_HPP\n#define ANIMATION_HPP\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;SFML/Window.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n\nstruct AnimationData\n{\n    sf::Sprite sprite;\n    int totalFrames;\n    int currentFrame;\n    sf::Clock clock;\n};\n\nclass Animation\n{\nprivate:\n    sf::Sprite sprite;\n    sf::Texture texture;\n    std::map&lt;std::string, sf::Texture&gt; animations;\n    float frameTime;\n    int currentFrame;\n    // int totalFrames;\n    // sf::Clock clock;\n    std::map&lt;std::string, AnimationData&gt; animationsData;\n\npublic:\n    Animation();\n    ~Animation();\n\n    // void loadAnimation(const std::string &amp;name_by_color, int frames);\n    void loadAnimation(const std::string &amp;name_by_color, int frames, float x, float y);\n    void update(const std::string &amp;name_by_color);\n    void render(sf::RenderWindow &amp;window, const std::string &amp;name_by_color);\n    void setScale(float scaleX, float scaleY);\n    void setPosition(const std::string &amp;name_by_color, float x, float y);\n    void moveY(const std::string &amp;name_by_color, float SpeedY);\n    void moveYUp(const std::string &amp;name_by_color, float SpeedY);\n    void moveXRight(const std::string &amp;name_by_color, float SpeedX);\n    void moveXLeft(const std::string &amp;name_by_color, float SpeedX);\n    sf::Vector2f getPosition(const std::string &amp;name_by_color);\n    sf::Sprite &amp;getSprite() { return sprite; }\n};\n\n#endif\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/AudioManager_8cpp/","title":"File AudioManager.cpp","text":"<p>FileList &gt; Audio &gt; AudioManager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../../include/Engine/Audio/AudioManager.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Engine/Audio/AudioManager.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/AudioManager_8cpp_source/","title":"File AudioManager.cpp","text":"<p>File List &gt; Audio &gt; AudioManager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"../../../include/Engine/Audio/AudioManager.hpp\"\n\nAudioManager::AudioManager()\n{\n}\n\nAudioManager::~AudioManager()\n{\n}\n\nvoid AudioManager::playSound(const std::string &amp;Path)\n{\n    if (!buffer.loadFromFile(Path))\n    {\n        std::cout &lt;&lt; \"Error loading sound\" &lt;&lt; std::endl;\n    }\n    sound.setBuffer(buffer);\n    sound.play();\n}\n\nvoid AudioManager::playMusic(const std::string &amp;Path)\n{\n    if (!music.openFromFile(Path))\n    {\n        std::cerr &lt;&lt; \"Error loading music from \" &lt;&lt; Path &lt;&lt; std::endl;\n        return;\n    }\n    music.play();\n    music.setLoop(true);\n}\n\nvoid AudioManager::pauseMusic()\n{\n    music.pause();\n}\n\nvoid AudioManager::resumeMusic()\n{\n    music.play();\n}\n\nvoid AudioManager::setMusicVolume(float volume)\n{\n    music.setVolume(volume);\n}\n\nvoid AudioManager::setSoundVolume(float volume)\n{\n    sound.setVolume(volume);\n}\n\nvoid AudioManager::setPitch(float pitch)\n{\n    sound.setPitch(pitch);\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/AudioManager_8hpp/","title":"File AudioManager.hpp","text":"<p>FileList &gt; Audio &gt; AudioManager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;SFML/Audio.hpp&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/AudioManager_8hpp/#classes","title":"Classes","text":"Type Name class AudioManager Handles sound and music playback using the SFML audio library. <p>The documentation for this class was generated from the following file <code>include/Engine/Audio/AudioManager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/AudioManager_8hpp_source/","title":"File AudioManager.hpp","text":"<p>File List &gt; Audio &gt; AudioManager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef AUDIO_MANAGER_HPP\n#define AUDIO_MANAGER_HPP\n\n#include &lt;SFML/Audio.hpp&gt;\n#include &lt;iostream&gt;\n\nclass AudioManager\n{\nprivate:\n    sf::SoundBuffer buffer;\n\n    sf::Sound sound;\n\n    sf::Music music;\n\npublic:\n    AudioManager();\n\n    ~AudioManager();\n\n    void playSound(const std::string &amp;Path);\n\n    void playMusic(const std::string &amp;Path);\n\n    void pauseMusic();\n\n    void resumeMusic();\n\n    void setMusicVolume(float volume = 100);\n\n    void setSoundVolume(float volume = 100);\n\n    void setPitch(float pitch = 1.0);\n};\n\n#endif // AUDIO_MANAGER_HPP\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Client_8cpp/","title":"File Client.cpp","text":"<p>FileList &gt; Server &gt; Client.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../include/Server/Client.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Server/Client.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Client_8cpp_source/","title":"File Client.cpp","text":"<p>File List &gt; Server &gt; Client.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** client\n** File description:\n** Client\n*/\n\n#include \"../../include/Server/Client.hpp\"\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\n\nClient::Client() : _io_context(), _soc(_io_context)\n{\n}\nvoid Client::send_tcp_message(const protocol::PlayerAction &amp;message, const std::string &amp;server_ip,\n                              int server_port)\n{\n    try\n    {\n        boost::asio::io_context io_context;\n        tcp::resolver resolver(io_context);\n        tcp::resolver::query query(tcp::v4(), server_ip, std::to_string(server_port));\n        tcp::resolver::iterator endpoint_iterator = resolver.resolve(query);\n        tcp::socket socket(io_context);\n        boost::asio::connect(socket, endpoint_iterator);\n\n        while (true)\n        {\n            auto buffer = protocol::serialize(message);\n            boost::asio::write(socket, boost::asio::buffer(buffer));\n            std::cout &lt;&lt; \"TCP message sent\" &lt;&lt; std::endl;\n            std::vector&lt;uint8_t&gt; recv_buffer(128);\n            boost::system::error_code error;\n            size_t len = socket.read_some(boost::asio::buffer(recv_buffer), error);\n            if (error)\n            {\n                std::cerr &lt;&lt; \"TCP Exception: \" &lt;&lt; error.message() &lt;&lt; \"\\n\";\n                if (error == boost::asio::error::eof)\n                {\n                    std::cout &lt;&lt; \"Connection closed by the server.\" &lt;&lt; std::endl;\n                    break;\n                }\n                else if (error == boost::asio::error::connection_reset)\n                {\n                    std::cout &lt;&lt; \"Connection reset by peer.\" &lt;&lt; std::endl;\n                    break;\n                }\n                else if (error == boost::asio::error::operation_aborted)\n                {\n                    std::cout &lt;&lt; \"Operation aborted.\" &lt;&lt; std::endl;\n                    break;\n                }\n                else\n                {\n                    throw boost::system::system_error(error);\n                }\n            }\n\n            std::cout &lt;&lt; \"Received TCP acknowledgment, length: \" &lt;&lt; len &lt;&lt; std::endl;\n            if (len &gt; 0)\n            {\n                std::string response(recv_buffer.begin(), recv_buffer.begin() + len);\n                std::cout &lt;&lt; \"Received TCP acknowledgment: \" &lt;&lt; response &lt;&lt; std::endl;\n            }\n\n            std::this_thread::sleep_for(std::chrono::seconds(5));\n        }\n    }\n    catch (std::exception &amp;e)\n    {\n        std::cerr &lt;&lt; \"TCP Exception: \" &lt;&lt; e.what() &lt;&lt; \"\\n\";\n    }\n}\n\nstd::string Client::get_name()\n{\n    sf::RenderWindow window(sf::VideoMode(400, 200), \"Player Name Entry\");\n\n    sf::Font font;\n    if (!font.loadFromFile(\"04B_19__.TTF\"))\n    {\n        std::cerr &lt;&lt; \"Failed to load font\\n\";\n        exit(84);\n    }\n    std::string _name;\n    sf::Text text;\n    text.setFont(font);\n    text.setCharacterSize(24);\n    text.setFillColor(sf::Color::Black);\n    text.setPosition(10.f, 10.f);\n    text.setString(\"Enter player name:\");\n\n    sf::Text playerNameText;\n    playerNameText.setFont(font);\n    playerNameText.setCharacterSize(24);\n    playerNameText.setFillColor(sf::Color::Black);\n    playerNameText.setPosition(10.f, 50.f);\n\n    bool enteringName = true;\n    _name.clear();\n    while (window.isOpen())\n    {\n        sf::Event event;\n        while (window.pollEvent(event))\n        {\n            if (event.type == sf::Event::Closed)\n            {\n                window.close();\n            }\n            else if (event.type == sf::Event::TextEntered &amp;&amp; enteringName)\n            {\n                if (event.text.unicode == '\\b' &amp;&amp; !_name.empty())\n                {\n                    _name.erase(_name.size() - 1);\n                }\n                else if (event.text.unicode &lt; 128 &amp;&amp; _name.size() &lt; 20)\n                {\n                    _name += event.text.unicode;\n                }\n                playerNameText.setString(_name);\n            }\n            else if (event.type == sf::Event::KeyPressed &amp;&amp; event.key.code == sf::Keyboard::Return)\n            {\n                if (_name.empty())\n                    _name = \"Anonymous\";\n                enteringName = false;\n                window.close();\n                return _name;\n            }\n        }\n        window.clear(sf::Color::White);\n        window.draw(text);\n        window.draw(playerNameText);\n        window.display();\n    }\n\n    delete &amp;window;\n    return _name;\n}\n\nvoid Client::create_player_1()\n{\n    sf::RectangleShape player(sf::Vector2f(50, 50));\n    player.setFillColor(sf::Color::Transparent);\n    player.setOutlineColor(sf::Color::Red);\n    player.setPosition(100, 100);\n    players.push_back(player);\n    player1.loadAnimation(\"red\", 8, 1.5, 1.5);\n    players_id.push_back(std::make_pair(1, player1));\n}\n\nvoid Client::create_player_2()\n{\n    sf::RectangleShape player(sf::Vector2f(50, 50));\n    player.setFillColor(sf::Color::Yellow);\n    player.setPosition(100, 300);\n    players.push_back(player);\n    player2.loadAnimation(\"blue\", 8, 1.5, 1.5);\n    player2.setPosition(\"blue\", 100, 200);\n    players_id.push_back(std::make_pair(2, player2));\n}\n\nstd::string Client::get_player_color(int id)\n{\n    if (id == 1)\n        return \"red\";\n    else if (id == 2)\n        return \"blue\";\n    else\n        return \"red\";\n}\n\nAnimation Client::create_random_enemy(int id)\n{\n\n    int random = rand() % 9 + 1;\n    if (random == 1)\n    {\n        enemie1.loadAnimation(\"green\", 8, 1.25, 1.25);\n        color_by_enemie.push_back(std::make_pair(id, \"green\"));\n        return enemie1;\n    }\n    else if (random == 2)\n    {\n        enemie2.loadAnimation(\"yellow\", 8, 1.25, 1.25);\n        color_by_enemie.push_back(std::make_pair(id, \"yellow\"));\n        return enemie2;\n    }\n    else if (random == 3)\n    {\n        enemie3.loadAnimation(\"purple\", 8, 1.25, 1.25);\n        color_by_enemie.push_back(std::make_pair(id, \"purple\"));\n        return enemie3;\n    }\n    else if (random == 4)\n    {\n        enemie4.loadAnimation(\"orange\", 5, 1.25, 1.25);\n        color_by_enemie.push_back(std::make_pair(id, \"orange\"));\n        return enemie4;\n    }\n    else if (random == 5)\n    {\n        enemie5.loadAnimation(\"pink\", 5, 1.25, 1.25);\n        color_by_enemie.push_back(std::make_pair(id, \"pink\"));\n        return enemie5;\n    }\n    else if (random == 6)\n    {\n        enemie6.loadAnimation(\"cyan\", 5, 1.25, 1.25);\n        color_by_enemie.push_back(std::make_pair(id, \"cyan\"));\n        return enemie6;\n    }\n    else if (random == 7)\n    {\n        enemie7.loadAnimation(\"brown\", 5, 1.25, 1.25);\n        color_by_enemie.push_back(std::make_pair(id, \"brown\"));\n        return enemie7;\n    }\n    else if (random == 8)\n    {\n        enemie8.loadAnimation(\"white\", 5, 1.25, 1.25);\n        color_by_enemie.push_back(std::make_pair(id, \"white\"));\n        return enemie8;\n    }\n    else if (random == 9)\n    {\n        enemie9.loadAnimation(\"black\", 5, 1.25, 1.25);\n        color_by_enemie.push_back(std::make_pair(id, \"black\"));\n        return enemie9;\n    }\n    else\n    {\n        enemie1.loadAnimation(\"green\", 5, 1.25, 1.25);\n        color_by_enemie.push_back(std::make_pair(id, \"green\"));\n        return enemie1;\n    }\n}\n\nstd::string Client::get_enemy_color(int id)\n{\n    for (auto &amp;color : color_by_enemie)\n    {\n        if (color.first == id)\n        {\n            return color.second;\n        }\n    }\n    return \"green\";\n}\n\nvoid Client::send_udp_message(const protocol::PlayerAction &amp;message, const std::string &amp;server_ip,\n                              int server_port, std::string player_name)\n{\n    Parallax parallax(\"assets/image/Background/background1.png\",\n                      \"assets/image/Background/background1.png\", 50.f, 50.f);\n    window_manager.loadFont(\"assets/font/04B_19__.TTF\");\n    sf::Clock clock;\n    try\n    {\n        // boost::asio::io_context io_context;\n        udp::resolver resolver(_io_context);\n        udp::resolver::query query(udp::v4(), server_ip, std::to_string(server_port));\n        _receiver_endpoint = *resolver.resolve(query).begin();\n\n        _soc = udp::socket(_io_context);\n        _soc.open(udp::v4());\n        _soc.non_blocking(true);\n        uint8_t connect_message = 0x01;\n        _soc.send_to(boost::asio::buffer(&amp;connect_message, 1), _receiver_endpoint);\n        std::cout &lt;&lt; \"Sent player connection request\" &lt;&lt; std::endl;\n\n        // std::string player_name = get_name();\n        int nb_players = 0;\n        uint8_t name_message[21] = {0x02};\n        for (int i = 0; i &lt; player_name.size(); i++)\n        {\n            name_message[i + 1] = player_name[i];\n        }\n        _soc.send_to(boost::asio::buffer(name_message, 21), _receiver_endpoint);\n        std::cout &lt;&lt; \"Sent player name: \" &lt;&lt; player_name &lt;&lt; std::endl;\n\n        window.create(sf::VideoMode(1366, 768), \"SFML window\");\n\n        while (window.isOpen())\n        {\n            while (window.pollEvent(event))\n            {\n                if (event.type == sf::Event::Closed)\n                {\n                    players.clear();\n                    window.close();\n                }\n                if (event.type == sf::Event::KeyPressed)\n                {\n                    if (sf::Keyboard::isKeyPressed(sf::Keyboard::Up))\n                    {\n                        uint8_t move_message[2] = {0x03, 0x01};\n                        _soc.send_to(boost::asio::buffer(move_message, 2), _receiver_endpoint);\n                        std::cout &lt;&lt; \"Sent player movement: keyup\" &lt;&lt; std::endl;\n                    }\n                    if (sf::Keyboard::isKeyPressed(sf::Keyboard::Down))\n                    {\n                        uint8_t move_message[2] = {0x03, 0x02};\n                        _soc.send_to(boost::asio::buffer(move_message, 2), _receiver_endpoint);\n                        std::cout &lt;&lt; \"Sent player movement: keydown\" &lt;&lt; std::endl;\n                    }\n                    if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left))\n                    {\n                        uint8_t move_message[2] = {0x03, 0x03};\n                        _soc.send_to(boost::asio::buffer(move_message, 2), _receiver_endpoint);\n                        std::cout &lt;&lt; \"Sent player movement: keyleft\" &lt;&lt; std::endl;\n                    }\n                    if (sf::Keyboard::isKeyPressed(sf::Keyboard::Right))\n                    {\n                        uint8_t move_message[2] = {0x03, 0x04};\n                        _soc.send_to(boost::asio::buffer(move_message, 2), _receiver_endpoint);\n                        std::cout &lt;&lt; \"Sent player movement: keyright\" &lt;&lt; std::endl;\n                    }\n                }\n            }\n            window.clear();\n            std::array&lt;u_int16_t, 128&gt; recv_buffer;\n            udp::endpoint sender_endpoint;\n            boost::system::error_code error;\n            size_t len =\n                _soc.receive_from(boost::asio::buffer(recv_buffer), sender_endpoint, 0, error);\n\n            if (error == boost::asio::error::would_block)\n            {\n                continue;\n            }\n            else if (error)\n            {\n                std::cerr &lt;&lt; \"UDP Exception: \" &lt;&lt; error.message() &lt;&lt; \"\\n\";\n                break;\n            }\n            if (len &gt; 0)\n            {\n                if (recv_buffer[0] == 0x03)\n                {\n                    std::cout &lt;&lt; \"Received UDP acknowledgment data: \" &lt;&lt; recv_buffer.data()\n                              &lt;&lt; std::endl;\n                    int id = recv_buffer[1];\n                    float pos_x = static_cast&lt;float&gt;(recv_buffer[2]);\n                    float pos_y = static_cast&lt;float&gt;(recv_buffer[3]);\n\n                    if (id == 1)\n                    {\n                        player1.setPosition(\"red\", pos_x, pos_y);\n                    }\n                    else if (id == 2)\n                    {\n                        player2.setPosition(\"blue\", pos_x, pos_y);\n                    }\n                    else\n                    {\n                        return;\n                    }\n                }\n                if (recv_buffer[0] == 0x02)\n                {\n                    nb_players = recv_buffer[1];\n                    std::cout &lt;&lt; \"Received UDP acknowledgment data: \" &lt;&lt; recv_buffer.data()\n                              &lt;&lt; std::endl;\n                    std::cout &lt;&lt; \"Players size : \" &lt;&lt; nb_players &lt;&lt; std::endl;\n                    if (nb_players &gt;= 1 &amp;&amp; players_id.size() == 0)\n                    {\n                        create_player_1();\n                    }\n                    if (nb_players &gt;= 2 &amp;&amp; players_id.size() == 1)\n                    {\n                        create_player_2();\n                    }\n                    // if (nb_players &gt;= 3 &amp;&amp; players_id.size() == 2)\n                    // {\n                    //     create_player_3();\n                    // }\n                    // if (nb_players &gt;= 4 &amp;&amp; players_id.size() == 3)\n                    // {\n                    //     create_player_4();\n                    // }\n                    std::cout &lt;&lt; \"Received updated game state\" &lt;&lt; std::endl;\n                }\n                if (recv_buffer[0] == 0x04)\n                {\n                    int v = 0;\n                    int id = recv_buffer[1];\n                    int pos_x = recv_buffer[2];\n                    int pos_y = recv_buffer[3];\n                    for (auto &amp;enemy : enemies_id)\n                    {\n                        if (enemy.first == id)\n                        {\n                            std::string color = get_enemy_color(id);\n                            enemy.second.setPosition(color, pos_x, pos_y);\n                            std::cout &lt;&lt; \"Updated enemy \" &lt;&lt; id &lt;&lt; \" position to: (\" &lt;&lt; pos_x\n                                      &lt;&lt; \", \" &lt;&lt; pos_y &lt;&lt; \")\" &lt;&lt; std::endl;\n                            v = 1;\n                            window.clear();\n                        }\n                    }\n                    if (v == 0)\n                    {\n                        Animation enemy = create_random_enemy(id);\n                        enemies_id.push_back(std::make_pair(id, enemy));\n                    }\n                }\n                if (recv_buffer[0] == 0x05)\n                {\n                    int id = recv_buffer[1];\n                    float pos_x = static_cast&lt;float&gt;(recv_buffer[2]);\n                    float pos_y = static_cast&lt;float&gt;(recv_buffer[3]);\n                    std::cout &lt;&lt; \"Received player id :\" &lt;&lt; id &lt;&lt; \"position: (\" &lt;&lt; pos_x &lt;&lt; \", \"\n                              &lt;&lt; pos_y &lt;&lt; \")\" &lt;&lt; std::endl;\n                    for (int i = 0; i &lt; players_id.size(); i++)\n                    {\n                        if (players_id[i].first == id)\n                        {\n                            players_id[i].second.setPosition(get_player_color(id), pos_x, pos_y);\n                        }\n                    }\n                }\n                if (recv_buffer[0] == 0x08)\n                {\n                    int id = recv_buffer[1];\n                    int pos_x = recv_buffer[2];\n                    int pos_y = recv_buffer[3];\n                    int v = 0;\n                    for (auto &amp;projectile : projectiles_id)\n                    {\n                        if (projectile.first == id)\n                        {\n                            std::cout &lt;&lt; \"Updated projectile \" &lt;&lt; id &lt;&lt; \" position to: (\" &lt;&lt; pos_x\n                                      &lt;&lt; \", \" &lt;&lt; pos_y &lt;&lt; \")\" &lt;&lt; std::endl;\n                            projectile.second.setPosition(pos_x, pos_y);\n                            v = 1;\n                            window.clear();\n                        }\n                    }\n                    if (v == 0)\n                    {\n                        sf::CircleShape projectile;\n                        projectile.setFillColor(sf::Color::Red);\n                        projectile.setPosition(pos_x, pos_y);\n                        projectile.setRadius(5.0f);\n                        projectiles.push_back(projectile);\n                        projectiles_id.push_back(std::make_pair(id, projectile));\n                    }\n                }\n                if (recv_buffer[0] == 0x07)\n                {\n                    _health = recv_buffer[1];\n                    _score = recv_buffer[2];\n\n                    std::cout &lt;&lt; \"Received player health: \" &lt;&lt; _health &lt;&lt; \" and score: \" &lt;&lt; _score\n                              &lt;&lt; std::endl;\n                }\n                if (recv_buffer[0] == 0x011)\n                {\n                    int id = recv_buffer[1];\n                    window.clear();\n                    for (int i = 0; i &lt; players_id.size(); i++)\n                    {\n                        if (players_id[i].first == id)\n                        {\n                            players_id.erase(players_id.begin() + i);\n                        }\n                    }\n                    game_over = true;\n                }\n            }\n\n            if (game_over)\n            {\n                window_manager.drawText(\"Game Over\", 10, 10, sf::Color::Red, window);\n                window.display();\n                std::this_thread::sleep_for(std::chrono::seconds(5));\n                window.close();\n            }\n            else\n            {\n                float deltaTime = clock.restart().asSeconds();\n                parallax.update(deltaTime);\n                window.clear();\n                parallax.draw(window);\n                for (int i = 0; i &lt; enemies_id.size(); i++)\n                {\n                    std::string color = get_enemy_color(enemies_id[i].first);\n                    enemies_id[i].second.update(color);\n                    enemies_id[i].second.render(window, color);\n                }\n                window_manager.drawText(\"Player Health: \" + std::to_string(_health), 10, 10,\n                                        sf::Color::Green, window);\n                window_manager.drawText(\"Player Score: \" + std::to_string(_score), 10, 40,\n                                        sf::Color::Yellow, window);\n                for (int i = 0; i &lt; projectiles_id.size(); i++)\n                {\n                    window.draw(projectiles_id[i].second);\n                }\n                for (int i = 0; i &lt; players_id.size(); i++)\n                {\n                    std::string color = get_player_color(players_id[i].first);\n                    std::cout &lt;&lt; \"Player color: \" &lt;&lt; color &lt;&lt; std::endl;\n                    players_id[i].second.update(color);\n                    players_id[i].second.render(window, color);\n                }\n                window.display();\n            }\n        }\n    }\n    catch (std::exception &amp;e)\n    {\n        std::cerr &lt;&lt; \"UDP Exception: \" &lt;&lt; e.what() &lt;&lt; \"\\n\";\n    }\n}\n\nClient::~Client()\n{\n}\n\n// int main(int ac, char **av)\n// {\n//     Client client;\n//     server_me_t server_me;\n//     // if (recup_args(&amp;server_me, ac, av) == false){\n//     //     return (84);\n\n//     // }\n//     protocol::PlayerAction player_action = {1, 1, {0x04, 0x02}};\n//     protocol::GameStateUpdate game_state_update = {{0x64, 0x04}};\n\n//     std::string server_ip = \"127.0.0.1\";\n\n//     std::cout &lt;&lt; \"Starting client...\" &lt;&lt; std::endl;\n//     std::thread udp_thread(&amp;Client::send_udp_message, &amp;client, player_action, server_ip,\n//     12346); std::thread tcp_thread(&amp;Client::send_tcp_message, &amp;client, player_action,\n//     server_ip, 12345);\n\n//     udp_thread.join();\n//     tcp_thread.join();\n\n//     return 0;\n// }\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Client_8hpp/","title":"File Client.hpp","text":"<p>FileList &gt; include &gt; Server &gt; Client.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> <li><code>#include &lt;SFML/Network.hpp&gt;</code></li> <li><code>#include &lt;SFML/System.hpp&gt;</code></li> <li><code>#include &lt;SFML/Window.hpp&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;boost/asio.hpp&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"../../include/Engine/Animation/Animation.hpp\"</code></li> <li><code>#include \"../../include/Engine/Audio/AudioManager.hpp\"</code></li> <li><code>#include \"../../include/Engine/Image/ImageManager.hpp\"</code></li> <li><code>#include \"../../include/Engine/Input/InputManager.hpp\"</code></li> <li><code>#include \"../../include/Engine/Mouse/MouseManager.hpp\"</code></li> <li><code>#include \"../../include/Engine/Shape/ShapeManager.hpp\"</code></li> <li><code>#include \"../Engine/Parallax/parallax.hpp\"</code></li> <li><code>#include \"Server.hpp\"</code></li> <li><code>#include \"protocol.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Client_8hpp/#classes","title":"Classes","text":"Type Name class Client Manages the client's interaction with the server and handles rendering, networking, and gameplay logic. <p>The documentation for this class was generated from the following file <code>include/Server/Client.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Client_8hpp_source/","title":"File Client.hpp","text":"<p>File List &gt; include &gt; Server &gt; Client.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** client\n** File description:\n** Client\n*/\n\n#ifndef CLIENT_HPP_\n#define CLIENT_HPP_\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;SFML/Network.hpp&gt;\n#include &lt;SFML/System.hpp&gt;\n#include &lt;SFML/Window.hpp&gt;\n#include &lt;array&gt;\n#include &lt;boost/asio.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\n#include \"../../include/Engine/Animation/Animation.hpp\"\n#include \"../../include/Engine/Audio/AudioManager.hpp\"\n#include \"../../include/Engine/Image/ImageManager.hpp\"\n#include \"../../include/Engine/Input/InputManager.hpp\"\n#include \"../../include/Engine/Mouse/MouseManager.hpp\"\n#include \"../../include/Engine/Shape/ShapeManager.hpp\"\n#include \"../Engine/Parallax/parallax.hpp\"\n#include \"Server.hpp\"\n#include \"protocol.hpp\"\n\nclass Client\n{\npublic:\n    Client();\n\n    ~Client();\n\n    void send_tcp_message(const protocol::PlayerAction &amp;message, const std::string &amp;server_ip, int server_port);\n\n    void send_udp_message(const protocol::PlayerAction &amp;message, const std::string &amp;server_ip, int server_port, std::string player_name);\n\n    std::string get_name();\n\n    void create_player_1();\n\n    void create_player_2();\n\n    void create_player_3();\n\n    void create_player_4();\n\n    Animation create_random_enemy(int id);\n\n    void assign_enemy();\n\n    std::string get_player_color(int id);\n\n    std::string get_enemy_color(int id);\n\n    // === Public Attributes ===\n    sf::RenderWindow window; \n    sf::Event event; \n    boost::asio::io_context _io_context; \n    udp::socket _soc; \n    udp::endpoint _receiver_endpoint; \n\n    std::vector&lt;sf::RectangleShape&gt; players; \n    std::vector&lt;std::pair&lt;int, Animation&gt;&gt; players_id; \n    std::vector&lt;sf::CircleShape&gt; enemies; \n    std::vector&lt;std::pair&lt;int, Animation&gt;&gt; enemies_id; \n    std::vector&lt;sf::CircleShape&gt; projectiles; \n    std::vector&lt;std::pair&lt;int, sf::CircleShape&gt;&gt; projectiles_id; \n\n    sf::Font font; \n    std::string input; \n\n    ImageManager GamePlayImage, backgroundImage, TeamScoreImage, LifeBoardImage;\n\n    AudioManager ButtonSound; \n\n    Animation player1, player2, enemie1, enemie2, enemie3, enemie4, enemie5, enemie6, enemie7, enemie8, enemie9, enemieBoss;\n\n    ShapeManager shapeManager1, shapeManager2;\n\n    TextManager window_manager; \n\n    int _health = 100; \n    int _score = 0; \n    bool game_over = false; \n\nprotected:\n    // === Private Attributes ===\n    int server_tcp_ip; \n    int server_udp_ip; \n};\n\n\n#endif /* !CLIENT_HPP_ */\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Coin__system_8cpp/","title":"File Coin_system.cpp","text":"<p>FileList &gt; Server &gt; Coin_system.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../include/Server/Coin_system.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Server/Coin_system.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Coin__system_8cpp_source/","title":"File Coin_system.cpp","text":"<p>File List &gt; Server &gt; Coin_system.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** game_logic\n** File description:\n** Coin_system.cpp\n*/\n\n#include \"../../include/Server/Coin_system.hpp\"\n\nvoid CoinSystem::checkCoins(Registry &amp;registry)\n{\n    auto &amp;coins = registry.get_entities(\"Coin\");\n    auto &amp;players = registry.get_entities(\"Player\");\n    int coinCollected = 0;\n\n    for (auto &amp;coin : coins)\n    {\n        if (!coin-&gt;_alive)\n        {\n            coinCollected++;\n        }\n    }\n\n    for (auto &amp;player : players)\n    {\n        player-&gt;score-&gt;set_score(coinCollected * 10);\n    }\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Coin__system_8hpp/","title":"File Coin_system.hpp","text":"<p>FileList &gt; include &gt; Server &gt; Coin_system.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Entity.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Coin__system_8hpp/#classes","title":"Classes","text":"Type Name class CoinSystem Manages the logic related to coins within the ECS ( Entity Component System). <p>The documentation for this class was generated from the following file <code>include/Server/Coin_system.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Coin__system_8hpp_source/","title":"File Coin_system.hpp","text":"<p>File List &gt; include &gt; Server &gt; Coin_system.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** game_logic\n** File description:\n** Coin_system.hpp\n*/\n\n#ifndef COIN_SYSTEM_HPP_\n#define COIN_SYSTEM_HPP_\n#include \"Entity.hpp\"\n\nclass Registry;\n\nclass CoinSystem\n{\npublic:\n    void checkCoins(Registry &amp;registry);\n};\n\n#endif // COIN_SYSTEM_HPP_\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Collision__system_8cpp/","title":"File Collision_system.cpp","text":"<p>FileList &gt; Server &gt; Collision_system.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../include/Server/Collision_system.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Server/Collision_system.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Collision__system_8cpp_source/","title":"File Collision_system.cpp","text":"<p>File List &gt; Server &gt; Collision_system.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** game_logic\n** File description:\n** CollisionSystem.cpp\n*/\n\n#include \"../../include/Server/Collision_system.hpp\"\n\nvoid CollisionSystem::collision_player_enemy(Registry &amp;registry)\n{\n    auto &amp;players = registry.get_entities(\"Player\");\n    auto &amp;enemies = registry.get_entities(\"Enemy\");\n\n    if (players.empty() || enemies.empty())\n        return;\n\n    for (auto player : players)\n    {\n        if (!player-&gt;transform || !player-&gt;bbox)\n            continue; // Ignorer si le joueur n'a pas de bo\u00eete de collision ou de\n                      // transformation\n\n        for (auto &amp;enemy : enemies)\n        {\n            if (!enemy-&gt;_alive || !enemy-&gt;transform || !enemy-&gt;bbox)\n                continue;\n            float playerLeft = player-&gt;transform-&gt;position.x;\n            float playerRight = playerLeft + player-&gt;bbox-&gt;size.x;\n            float playerTop = player-&gt;transform-&gt;position.y;\n            float playerBottom = playerTop + player-&gt;bbox-&gt;size.y;\n\n            float enemyLeft = enemy-&gt;transform-&gt;position.x;\n            float enemyRight = enemyLeft + enemy-&gt;bbox-&gt;size.x;\n            float enemyTop = enemy-&gt;transform-&gt;position.y;\n            float enemyBottom = enemyTop + enemy-&gt;bbox-&gt;size.y;\n\n            if (playerRight &gt; enemyLeft &amp;&amp; playerLeft &lt; enemyRight &amp;&amp; playerBottom &gt; enemyTop &amp;&amp;\n                playerTop &lt; enemyBottom)\n            {\n                player-&gt;health-&gt;takeDamage(10);\n                enemy-&gt;_alive = false;\n                player-&gt;score-&gt;set_score(10);\n                std::cout &lt;&lt; \"Player collided with enemy, enemy dead.\" &lt;&lt; std::endl;\n            }\n        }\n    }\n    registry.entity_update();\n}\n\nvoid CollisionSystem::collison_player_coins(Registry &amp;registry)\n{\n    auto &amp;players = registry.get_entities(\"Player\");\n    auto &amp;coins = registry.get_entities(\"Coin\");\n    int v = 0;\n    if (players.empty())\n        return;\n    auto player = players[0];\n\n    if (!player-&gt;transform || !player-&gt;bbox)\n        return;\n\n    for (auto &amp;coin : coins)\n    {\n        if (!coin-&gt;transform || !coin-&gt;bbox)\n            continue;\n\n        float playerLeft = player-&gt;transform-&gt;position.x;\n        float playerRight = playerLeft + player-&gt;bbox-&gt;size.x;\n        float playerTop = player-&gt;transform-&gt;position.y;\n        float playerBottom = playerTop + player-&gt;bbox-&gt;size.y;\n\n        float coinLeft = coin-&gt;transform-&gt;position.x;\n        float coinRight = coinLeft + coin-&gt;bbox-&gt;size.x;\n        float coinTop = coin-&gt;transform-&gt;position.y;\n        float coinBottom = coinTop + coin-&gt;bbox-&gt;size.y;\n\n        if (playerRight &gt; coinLeft &amp;&amp; playerLeft &lt; coinRight &amp;&amp; playerBottom &gt; coinTop &amp;&amp;\n            playerTop &lt; coinBottom)\n        {\n            coin-&gt;_alive = false;\n        }\n    }\n}\n\nbool CollisionSystem::collision_enemy_projectiles(Registry &amp;registry)\n{\n    auto &amp;projectiles = registry.get_entities(\"Projectile\");\n    auto &amp;enemies = registry.get_entities(\"Enemy\");\n\n    for (auto &amp;proj : projectiles)\n    {\n        for (auto &amp;enemy : enemies)\n        {\n            if (check_collision(proj, enemy))\n            {\n                std::cout &lt;&lt; \"Projectile hit enemy!\" &lt;&lt; std::endl;\n                enemy-&gt;health-&gt;takeDamage(10);\n                proj-&gt;_alive = false;\n                enemy-&gt;_alive = enemy-&gt;health-&gt;currentHealth &gt; 0;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool CollisionSystem::check_collision(std::shared_ptr&lt;Entity&gt; &amp;proj, std::shared_ptr&lt;Entity&gt; &amp;enemy)\n{\n    float projLeft = proj-&gt;transform-&gt;position.x;\n    float projRight = projLeft + proj-&gt;bbox-&gt;size.x;\n    float projTop = proj-&gt;transform-&gt;position.y;\n    float projBottom = projTop + proj-&gt;bbox-&gt;size.y;\n\n    float enemyLeft = enemy-&gt;transform-&gt;position.x;\n    float enemyRight = enemyLeft + enemy-&gt;bbox-&gt;size.x;\n    float enemyTop = enemy-&gt;transform-&gt;position.y;\n    float enemyBottom = enemyTop + enemy-&gt;bbox-&gt;size.y;\n\n    return projRight &gt; enemyLeft &amp;&amp; projLeft &lt; enemyRight &amp;&amp; projBottom &gt; enemyTop &amp;&amp;\n           projTop &lt; enemyBottom;\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Collision__system_8hpp/","title":"File Collision_system.hpp","text":"<p>FileList &gt; include &gt; Server &gt; Collision_system.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Entity.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Collision__system_8hpp/#classes","title":"Classes","text":"Type Name class CollisionSystem Handles collision detection and responses in the ECS ( Entity Component System). <p>The documentation for this class was generated from the following file <code>include/Server/Collision_system.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Collision__system_8hpp_source/","title":"File Collision_system.hpp","text":"<p>File List &gt; include &gt; Server &gt; Collision_system.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** game_logic\n** File description:\n** Collision_system.hpp\n*/\n\n#ifndef COLLISION_SYSTEM_HPP_\n#define COLLISION_SYSTEM_HPP_\n#include \"Entity.hpp\"\n\n// Forward declaration of the Registry class to avoid circular dependencies.\nclass Registry;\n\nclass CollisionSystem\n{\npublic:\n    CollisionSystem() {};\n\n    ~CollisionSystem() {};\n\n    void collision_player_enemy(Registry &amp;registry);\n\n    void collison_player_coins(Registry &amp;registry);\n\n    bool collision_enemy_projectiles(Registry &amp;registry);\n\n    bool check_collision(std::shared_ptr&lt;Entity&gt; &amp;proj, std::shared_ptr&lt;Entity&gt; &amp;enemy);\n};\n\n#endif // COLLISION_SYSTEM_HPP_\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Entity_8cpp/","title":"File Entity.cpp","text":"<p>FileList &gt; Server &gt; Entity.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../include/Server/Entity.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Server/Entity.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Entity_8cpp_source/","title":"File Entity.cpp","text":"<p>File List &gt; Server &gt; Entity.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** B-CPP-500-COT-5-1-bsrtype-kafui.hounkpatin\n** File description:\n** Entity.cpp\n*/\n\n#include \"../../include/Server/Entity.hpp\"\n\nvoid Registry::entity_update()\n{\n    for (auto &amp;entity : _new_entities)\n    {\n        if (entity == nullptr || !entity-&gt;_alive)\n            continue;\n\n        _entities_vector.push_back(entity);\n        _entities_map[entity-&gt;_tag].push_back(entity);\n    }\n    _new_entities.clear();\n    _entities_vector.erase(std::remove_if(_entities_vector.begin(), _entities_vector.end(),\n                                          [](const std::shared_ptr&lt;Entity&gt; &amp;entity)\n                                          { return entity == nullptr || !entity-&gt;_alive; }),\n                           _entities_vector.end());\n    for (auto &amp;pair : _entities_map)\n    {\n        auto &amp;entities = pair.second;\n        entities.erase(std::remove_if(entities.begin(), entities.end(),\n                                      [](const std::shared_ptr&lt;Entity&gt; &amp;entity)\n                                      { return entity == nullptr || !entity-&gt;_alive; }),\n                       entities.end());\n    }\n}\n\nEntityVector &amp;Registry::get_entities(const std::string tag)\n{\n    return _entities_map[tag];\n}\n\nEntityVector &amp;Registry::get_entities()\n{\n    return _entities_vector;\n}\n\nVector2D Registry::spawn_enemy()\n{\n    auto enemy = add_entity(\"Enemy\");\n    enemy-&gt;transform = std::make_unique&lt;Transform&gt;(Vector2D(200, 200), Vector2D(0, 0));\n    enemy-&gt;bbox = std::make_unique&lt;BBox&gt;(Vector2D(100, 100));\n    enemy-&gt;transform-&gt;position.y = rand() % 700 + 100;\n    enemy-&gt;transform-&gt;position.x = 1370;\n    enemy-&gt;health = std::make_unique&lt;Health&gt;(10);\n    return enemy-&gt;transform-&gt;position;\n}\n\nstd::shared_ptr&lt;Entity&gt; Registry::add_entity(const std::string tag)\n{\n    std::shared_ptr&lt;Entity&gt; entity = std::make_unique&lt;Entity&gt;(_entities_count, tag);\n    _new_entities.push_back(entity);\n    _entities_count++;\n    return entity;\n}\n\nvoid Registry::spawn_coin()\n{\n    auto coin = add_entity(\"Coin\");\n    coin-&gt;transform = std::make_unique&lt;Transform&gt;(Vector2D(200, 200), Vector2D(0, 0));\n    coin-&gt;bbox = std::make_unique&lt;BBox&gt;(Vector2D(20, 20));\n    coin-&gt;transform-&gt;position.y = rand() % 400 + 100;\n    coin-&gt;transform-&gt;position.x = 775;\n    coin-&gt;transform-&gt;velocity.x = -0.005;\n}\n\nvoid Registry::spawn_player(std::string name)\n{\n    auto player = add_entity(\"Player\");\n    // entity_update();\n    auto players = get_entities(\"Player\");\n    std::cout &lt;&lt; \"Players size : \" &lt;&lt; players.size() &lt;&lt; std::endl;\n    if (players.size() == 0)\n        player-&gt;transform = std::make_unique&lt;Transform&gt;(Vector2D(100, 100), Vector2D(0, 0));\n    if (players.size() == 1)\n        player-&gt;transform = std::make_unique&lt;Transform&gt;(Vector2D(100, 300), Vector2D(0, 0));\n    player-&gt;bbox = std::make_unique&lt;BBox&gt;(Vector2D(50, 50));\n    player-&gt;health = std::make_unique&lt;Health&gt;(100);\n    player-&gt;score = std::make_unique&lt;Score&gt;();\n    player-&gt;input = std::make_unique&lt;Input&gt;();\n    player-&gt;name = std::make_unique&lt;Name&gt;(name);\n}\n\nvoid Registry::spawn_boss()\n{\n    auto boss = add_entity(\"Boss\");\n    boss-&gt;transform = std::make_unique&lt;Transform&gt;(Vector2D(200, 200), Vector2D(0, 0));\n    boss-&gt;bbox = std::make_unique&lt;BBox&gt;(Vector2D(100, 100));\n    boss-&gt;transform-&gt;position.y = rand() % 400 + 100;\n    boss-&gt;transform-&gt;position.x = 775;\n    boss-&gt;health = std::make_unique&lt;Health&gt;(100);\n    boss-&gt;score = std::make_unique&lt;Score&gt;();\n    boss-&gt;input = std::make_unique&lt;Input&gt;();\n    boss-&gt;name = std::make_unique&lt;Name&gt;(\"Boss\");\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Entity_8hpp/","title":"File Entity.hpp","text":"<p>FileList &gt; include &gt; Server &gt; Entity.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;any&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;typeindex&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Vector.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Entity_8hpp/#classes","title":"Classes","text":"Type Name class BBox Component representing the size of an entity's bounding box. class Entity Represents a game object composed of multiple components. class Health Component to manage an entity's health state. class Input Component to track player input actions (e.g., movement or shooting). class Name Component to store the name of an entity. class Registry Manages all entities in the game and their lifecycle. class Score Component to manage an entity's score during gameplay. class Transform Component representing an entity's position and velocity in 2D space. <p>The documentation for this class was generated from the following file <code>include/Server/Entity.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Entity_8hpp_source/","title":"File Entity.hpp","text":"<p>File List &gt; include &gt; Server &gt; Entity.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** B-CPP-500-COT-5-1-bsrtype-kafui.hounkpatin\n** File description:\n** Entity.hpp\n*/\n\n#ifndef ENTITY_HPP_\n#define ENTITY_HPP_\n#include &lt;any&gt;\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;mutex&gt;\n#include &lt;optional&gt;\n#include &lt;string&gt;\n#include &lt;typeindex&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\n#include \"Vector.hpp\"\n\nclass Transform {\npublic:\n    Vector2D position; \n    Vector2D velocity; \n\n    Transform() : position(0, 0), velocity(0, 0) {}\n\n    Transform(Vector2D pos, Vector2D vel) : position(pos), velocity(vel) {}\n};\n\nclass Name {\npublic:\n    std::string name; \n\n    Name() : name(\"\") {}\n\n    Name(std::string n) : name(n) {}\n};\n\nclass BBox {\npublic:\n    Vector2D size; \n\n    BBox() : size(0, 0) {}\n\n    BBox(Vector2D s) : size(s) {}\n};\n\nclass Input {\npublic:\n    bool up;    \n    bool down;  \n    bool left;  \n    bool right; \n    bool shoot; \n\n    Input() : up(false), down(false), left(false), right(false), shoot(false) {}\n\n    void reset() {\n        up = down = left = right = shoot = false;\n    }\n};\n\nclass Health {\npublic:\n    int maxHealth;     \n    int currentHealth; \n\n    Health() : maxHealth(0), currentHealth(0) {}\n\n    Health(int maxHp) : maxHealth(maxHp), currentHealth(maxHp) {}\n\n    void takeDamage(int damage) {\n        currentHealth = std::max(0, currentHealth - damage);\n    }\n};\n\nclass Score {\nprivate:\n    int scoreValue; \n\npublic:\n    Score() : scoreValue(0) {}\n\n    void set_score(int new_score) {\n        scoreValue += new_score;\n    }\n\n    int getScore() const {\n        return scoreValue;\n    }\n};\n\nclass Entity {\npublic:\n    std::unique_ptr&lt;Transform&gt; transform; \n    std::unique_ptr&lt;Name&gt; name;           \n    std::unique_ptr&lt;BBox&gt; bbox;           \n    std::unique_ptr&lt;Input&gt; input;         \n    std::unique_ptr&lt;Health&gt; health;       \n    std::unique_ptr&lt;Score&gt; score;         \n\n    const size_t _id;           \n    const std::string _tag;     \n    bool _alive = true;         \n\n    Entity(size_t id, std::string tag) : _id(id), _tag(tag) {}\n\n    void destroy() { _alive = false; }\n};\n\nclass Registry {\nprivate:\n    EntityMap _entities_map;       \n    EntityVector _entities_vector; \n    EntityVector _new_entities;    \n    size_t _entities_count = 0;    \n\npublic:\n    std::shared_ptr&lt;Entity&gt; add_entity(const std::string tag);\n\n    EntityVector&amp; get_entities(const std::string tag);\n\n    void remove_entity(const size_t id);\n};\n\n#endif // !ENTITY_HPP_\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameCore_8cpp/","title":"File GameCore.cpp","text":"<p>FileList &gt; Client &gt; GameCore.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"GameCore.hpp\"</code></li> <li><code>#include \"GamePlay.hpp\"</code></li> <li><code>#include \"GameSetting.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Client/GameCore.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameCore_8cpp_source/","title":"File GameCore.cpp","text":"<p>File List &gt; Client &gt; GameCore.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"GameCore.hpp\"\n\n#include \"GamePlay.hpp\"\n#include \"GameSetting.hpp\"\n\nGameUI::GameCore::GameCore()\n    : window(sf::VideoMode(BASE_WIDTH, BASE_HEIGHT), \"Epitech | R-Type\"), screenManager(window),\n      roomLobby(screenManager)\n{\n    screenManager.addScreen&lt;GameLobby&gt;(\"GameLobby\", [&amp;]()\n                                       { return std::make_unique&lt;GameLobby&gt;(screenManager); });\n    screenManager.addScreen&lt;RoomLobby&gt;(\"RoomLobby\", [&amp;]()\n                                       { return std::make_unique&lt;RoomLobby&gt;(screenManager); });\n    screenManager.addScreen&lt;GameSetting&gt;(\"GameSetting\", [&amp;]()\n                                         { return std::make_unique&lt;GameSetting&gt;(screenManager); });\n    // screenManager.addScreen&lt;GamePlay&gt;(\"GamePlay\",\n    //                                   [&amp;]() { return std::make_unique&lt;GamePlay&gt;(screenManager);\n    //                                   });\n    screenManager.switchToScreen(\"GameLobby\");\n}\n\nvoid GameUI::GameCore::run()\n{\n    sf::Clock clock;\n\n    RoomMusic.playMusic(\"assets/audio/Music/menu1.ogg\");\n\n    while (window.isOpen())\n    {\n        sf::Event event;\n        while (window.pollEvent(event))\n        {\n            if (event.type == sf::Event::Closed)\n            {\n                window.close();\n            }\n            screenManager.handleEvent(event);\n        }\n\n        screenManager.update();\n\n        window.clear();\n        screenManager.render();\n        window.display();\n    }\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameCore_8hpp/","title":"File GameCore.hpp","text":"<p>FileList &gt; Client &gt; GameCore.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"GameLobby.hpp\"</code></li> <li><code>#include \"RoomLobby.hpp\"</code></li> <li><code>#include \"ScreenManager.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameCore_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace GameUI"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameCore_8hpp/#classes","title":"Classes","text":"Type Name class GameCore"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameCore_8hpp/#macros","title":"Macros","text":"Type Name define BASE_HEIGHT  768 define BASE_WIDTH  1366"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameCore_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameCore_8hpp/#define-base_height","title":"define BASE_HEIGHT","text":"<pre><code>#define BASE_HEIGHT 768\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameCore_8hpp/#define-base_width","title":"define BASE_WIDTH","text":"<pre><code>#define BASE_WIDTH 1366\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Client/GameCore.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameCore_8hpp_source/","title":"File GameCore.hpp","text":"<p>File List &gt; Client &gt; GameCore.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"GameLobby.hpp\"\n#include \"RoomLobby.hpp\"\n#include \"ScreenManager.hpp\"\n\n#define BASE_WIDTH 1366\n#define BASE_HEIGHT 768\n\nnamespace GameUI\n{\n    class GameCore\n    {\n    public:\n        GameCore();\n        void run();\n        RoomLobby roomLobby;\n\n    private:\n        sf::RenderWindow window;\n        ScreenManager screenManager;\n        AudioManager RoomMusic;\n    };\n} // namespace GameUI\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameLobby_8cpp/","title":"File GameLobby.cpp","text":"<p>FileList &gt; Client &gt; GameLobby.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"GameLobby.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Client/GameLobby.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameLobby_8cpp_source/","title":"File GameLobby.cpp","text":"<p>File List &gt; Client &gt; GameLobby.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"GameLobby.hpp\"\n\nGameUI::GameLobby::GameLobby(ScreenManager &amp;screenManager) : screenManager(screenManager)\n{\n    if (!font.loadFromFile(\"assets/font/Bangers.ttf\"))\n    {\n        std::cerr &lt;&lt; \"Failed to load font.\" &lt;&lt; std::endl;\n    }\n}\n\nbool GameUI::GameLobby::setGameLobby(const std::string &amp;filePath, float windowWidth,\n                                     float windowHeight)\n{\n    if (GameLobbyImage.createImage(filePath))\n    {\n        GameLobbyImage.fitToScreen(windowWidth / 3.5, windowHeight / 3.5);\n        centerImage(GameLobbyImage, windowWidth, windowHeight);\n        return true;\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to load GameLobby image.\" &lt;&lt; std::endl;\n        return false;\n    }\n}\n\nbool GameUI::GameLobby::setBackground(const std::string &amp;filePath, float windowWidth,\n                                      float windowHeight)\n{\n    if (backgroundImage.createImage(filePath))\n    {\n        backgroundImage.fitToScreen(windowWidth, windowHeight);\n        return true;\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to load background image.\" &lt;&lt; std::endl;\n        return false;\n    }\n}\n\nbool GameUI::GameLobby::setAsteriodOne(const std::string &amp;filePath)\n{\n    if (Asteriod1.createImage(filePath))\n    {\n        Asteriod1.setPosition(103, 400);\n        Asteriod1.setScale(1.5, 1.5);\n        return true;\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to load background image.\" &lt;&lt; std::endl;\n        return false;\n    }\n}\n\nbool GameUI::GameLobby::setAsteriodTwo(const std::string &amp;filePath)\n{\n    if (Asteriod2.createImage(filePath))\n    {\n        Asteriod2.setPosition(1100, 121);\n        Asteriod2.setScale(1.5, 1.5);\n        return true;\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to load background image.\" &lt;&lt; std::endl;\n        return false;\n    }\n}\n\nbool GameUI::GameLobby::setAsteriodThree(const std::string &amp;filePath)\n{\n    if (Asteriod3.createImage(filePath))\n    {\n        Asteriod3.setPosition(950, 500);\n        Asteriod3.setScale(1.5, 1.5);\n        return true;\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to load background image.\" &lt;&lt; std::endl;\n        return false;\n    }\n}\n\nvoid GameUI::GameLobby::drawBackground(sf::RenderWindow &amp;window)\n{\n    window.draw(getBackgroundSprite());\n}\n\nvoid GameUI::GameLobby::drawGameLobby(sf::RenderWindow &amp;window)\n{\n    window.draw(getGameLobbySprite());\n}\n\nvoid GameUI::GameLobby::drawAsteriodOne(sf::RenderWindow &amp;window)\n{\n    window.draw(getAsteriodOneSprite());\n}\n\nvoid GameUI::GameLobby::drawAsteriodTwo(sf::RenderWindow &amp;window)\n{\n    window.draw(getAsteriodTwoSprite());\n}\n\nvoid GameUI::GameLobby::drawAsteriodThree(sf::RenderWindow &amp;window)\n{\n    window.draw(getAsteriodThreeSprite());\n}\n\nconst sf::Sprite &amp;GameUI::GameLobby::getAsteriodOneSprite() const\n{\n    return Asteriod1.getSprite();\n}\n\nconst sf::Sprite &amp;GameUI::GameLobby::getAsteriodTwoSprite() const\n{\n    return Asteriod2.getSprite();\n}\n\nconst sf::Sprite &amp;GameUI::GameLobby::getAsteriodThreeSprite() const\n{\n    return Asteriod3.getSprite();\n}\n\nconst sf::Sprite &amp;GameUI::GameLobby::getGameLobbySprite() const\n{\n    return GameLobbyImage.getSprite();\n}\n\nconst sf::Sprite &amp;GameUI::GameLobby::getBackgroundSprite() const\n{\n    return backgroundImage.getSprite();\n}\n\nvoid GameUI::GameLobby::centerImage(ImageManager &amp;img, float windowWidth, float windowHeight)\n{\n    sf::Sprite &amp;sprite = img.getSprite();\n    sf::FloatRect bounds = sprite.getLocalBounds();\n    sprite.setOrigin(bounds.width / 2, bounds.height / 2);\n    sprite.setPosition(windowWidth / 2, windowHeight / 2);\n}\n\nvoid GameUI::GameLobby::shapebuilder(sf::RenderWindow &amp;window)\n{\n    this-&gt;rect1 = shapeManager1.drawRectangle(window, 592, 366, 180, 50, sf::Color::Red, 5);\n    sf::FloatRect textBounds = textip.getLocalBounds();\n    textip.setOrigin(textBounds.left + textBounds.width / 2.0f,\n                     textBounds.top + textBounds.height / 2.0f);\n    textip.setPosition(rect1.getPosition().x + rect1.getSize().x / 2.0f,\n                       rect1.getPosition().y + rect1.getSize().y / 2.0f);\n    window.draw(textip);\n\n    this-&gt;rect2 = shapeManager2.drawRectangle(window, 596, 501, 180, 50, sf::Color::Red, 5);\n    sf::FloatRect textBounds2 = textname.getLocalBounds();\n    textname.setOrigin(textBounds2.left + textBounds2.width / 2.0f,\n                       textBounds2.top + textBounds2.height / 2.0f);\n    textname.setPosition(rect2.getPosition().x + rect2.getSize().x / 2.0f,\n                         rect2.getPosition().y + rect2.getSize().y / 2.0f);\n}\n\nvoid GameUI::GameLobby::loadFont(const std::string &amp;fontPath)\n{\n    if (!font.loadFromFile(fontPath))\n    {\n        std::cerr &lt;&lt; \"Failed to load font.\" &lt;&lt; std::endl;\n    }\n}\n\nvoid GameUI::GameLobby::update()\n{\n}\n\nvoid GameUI::GameLobby::render(sf::RenderWindow &amp;window)\n{\n    window.clear();\n\n    float windowWidth = window.getSize().x;\n    float windowHeight = window.getSize().y;\n\n    if (setBackground(\"assets/image/Background/background1.png\", windowWidth, windowHeight))\n    {\n        drawBackground(window);\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to set background\" &lt;&lt; std::endl;\n    }\n\n    if (setGameLobby(\"assets/image/Element/welcome.png\", windowWidth, windowHeight))\n    {\n        drawGameLobby(window);\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to set setting\" &lt;&lt; std::endl;\n    }\n\n    if (setAsteriodOne(\"assets/image/Asteroids/brown-large.png\"))\n    {\n        drawAsteriodOne(window);\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to set setting\" &lt;&lt; std::endl;\n    }\n\n    if (setAsteriodTwo(\"assets/image/Asteroids/gray-medium.png\"))\n    {\n        drawAsteriodTwo(window);\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to set setting\" &lt;&lt; std::endl;\n    }\n\n    if (setAsteriodThree(\"assets/image/Asteroids/red-small.png\"))\n    {\n        drawAsteriodThree(window);\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to set setting\" &lt;&lt; std::endl;\n    }\n    shapebuilder(window);\n    window.display();\n}\n\nvoid GameUI::GameLobby::handleEvent(sf::Event &amp;event)\n{\n    if (event.type == sf::Event::MouseButtonPressed)\n    {\n        sf::Vector2f mousePos = sf::Vector2f(event.mouseButton.x, event.mouseButton.y);\n        std::cout &lt;&lt; \"x: \" &lt;&lt; mousePos.x &lt;&lt; \" y: \" &lt;&lt; mousePos.y &lt;&lt; std::endl;\n\n        if (getRect1().getGlobalBounds().contains(static_cast&lt;sf::Vector2f&gt;(mousePos)))\n        {\n            std::cout &lt;&lt; \"Button clicked 1\" &lt;&lt; std::endl;\n            getButtonSound().playSound(\"assets/audio/Effect/button.mp3\");\n            sf::sleep(sf::seconds(0.5));\n            screenManager.switchToScreen(\"RoomLobby\");\n        }\n        else if (getRect2().getGlobalBounds().contains(static_cast&lt;sf::Vector2f&gt;(mousePos)))\n        {\n            std::cout &lt;&lt; \"Button clicked 2\" &lt;&lt; std::endl;\n            getButtonSound().playSound(\"assets/audio/Effect/button.mp3\");\n            // sf::sleep(sf::seconds(0.5));\n            screenManager.switchToScreen(\"GameSetting\");\n        }\n    }\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameLobby_8hpp/","title":"File GameLobby.hpp","text":"<p>FileList &gt; Client &gt; GameLobby.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ScreenManager.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameLobby_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace GameUI"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameLobby_8hpp/#classes","title":"Classes","text":"Type Name class GameLobby"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameLobby_8hpp/#macros","title":"Macros","text":"Type Name define PLAY_BUTTON_X  0.432 define PLAY_BUTTON_Y  0.53 define SETTING_BUTTON_X  0.436 define SETTING_BUTTON_Y  0.725"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameLobby_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameLobby_8hpp/#define-play_button_x","title":"define PLAY_BUTTON_X","text":"<pre><code>#define PLAY_BUTTON_X 0.432\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameLobby_8hpp/#define-play_button_y","title":"define PLAY_BUTTON_Y","text":"<pre><code>#define PLAY_BUTTON_Y 0.53\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameLobby_8hpp/#define-setting_button_x","title":"define SETTING_BUTTON_X","text":"<pre><code>#define SETTING_BUTTON_X 0.436\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameLobby_8hpp/#define-setting_button_y","title":"define SETTING_BUTTON_Y","text":"<pre><code>#define SETTING_BUTTON_Y 0.725\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Client/GameLobby.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameLobby_8hpp_source/","title":"File GameLobby.hpp","text":"<p>File List &gt; Client &gt; GameLobby.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"ScreenManager.hpp\"\n#define PLAY_BUTTON_X 0.432\n#define PLAY_BUTTON_Y 0.53\n#define SETTING_BUTTON_X 0.436\n#define SETTING_BUTTON_Y 0.725\n\nnamespace GameUI\n{\n    class GameLobby : public IScreen\n    {\n    private:\n        sf::Font font;\n        std::string input;\n        ImageManager GameLobbyImage, backgroundImage;\n        ImageManager Asteriod1, Asteriod2, Asteriod3;\n        AudioManager ButtonSound, RoomMusic;\n        MouseManager mouse;\n        sf::Text textip, textname;\n        sf::RectangleShape rect1, rect2;\n        ShapeManager shapeManager1, shapeManager2;\n        void centerImage(ImageManager &amp;img, float windowWidth, float windowHeight);\n        ScreenManager &amp;screenManager;\n\n    public:\n        GameLobby(ScreenManager &amp;screenManager);\n        void render(sf::RenderWindow &amp;window) override;\n        void update() override;\n        void loadFont(const std::string &amp;fontPath);\n        void handleEvent(sf::Event &amp;event) override;\n\n        bool setBackground(const std::string &amp;filePath, float windowWidth, float windowHeight);\n        bool setGameLobby(const std::string &amp;filePath, float windowWidth, float windowHeight);\n        bool setAsteriodOne(const std::string &amp;filePath);\n        bool setAsteriodTwo(const std::string &amp;filePath);\n        bool setAsteriodThree(const std::string &amp;filePath);\n        bool setAsteriodFour(const std::string &amp;filePath);\n\n        void drawGameLobby(sf::RenderWindow &amp;window);\n        void drawBackground(sf::RenderWindow &amp;window);\n        void drawAsteriodOne(sf::RenderWindow &amp;window);\n        void drawAsteriodTwo(sf::RenderWindow &amp;window);\n        void drawAsteriodThree(sf::RenderWindow &amp;window);\n        void drawAsteriodFour(sf::RenderWindow &amp;window);\n\n        const sf::Sprite &amp;getGameLobbySprite() const;\n        const sf::Sprite &amp;getBackgroundSprite() const;\n        const sf::Sprite &amp;getAsteriodOneSprite() const;\n        const sf::Sprite &amp;getAsteriodTwoSprite() const;\n        const sf::Sprite &amp;getAsteriodThreeSprite() const;\n        const sf::Sprite &amp;getAsteriodFourSprite() const;\n\n        void shapebuilder(sf::RenderWindow &amp;window);\n\n        sf::RectangleShape &amp;getRect1() { return rect1; }\n        sf::RectangleShape &amp;getRect2() { return rect2; }\n\n        AudioManager &amp;getRoomMusic() { return RoomMusic; }\n        AudioManager &amp;getButtonSound() { return ButtonSound; }\n        MouseManager &amp;getMouse() { return mouse; }\n    };\n} // namespace GameUI\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GamePlay_8cpp/","title":"File GamePlay.cpp","text":"<p>FileList &gt; Client &gt; GamePlay.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"GamePlay.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Client/GamePlay.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GamePlay_8cpp_source/","title":"File GamePlay.cpp","text":"<p>File List &gt; Client &gt; GamePlay.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"GamePlay.hpp\"\n\nGameUI::GamePlay::GamePlay(ScreenManager &amp;screenManager) : screenManager(screenManager)\n{\n    if (!font.loadFromFile(\"assets/font/Bangers.ttf\"))\n    {\n        std::cerr &lt;&lt; \"Failed to load font.\" &lt;&lt; std::endl;\n    }\n    createPlayer1();\n    // spawnRandomEnemies();\n    createPlayer2();\n    createEnemies();\n    createEnemies2();\n    createEnemies3();\n    createEnemies4();\n    createEnamies5();\n    createEnamies6();\n    createEnamies7();\n    createEnamies8();\n    createEnamies9();\n}\n\nbool GameUI::GamePlay::setBackground(const std::string &amp;filePath, float windowWidth,\n                                     float windowHeight)\n{\n    if (backgroundImage.createImage(filePath))\n    {\n        backgroundImage.fitToScreen(windowWidth, windowHeight);\n        return true;\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to load background image.\" &lt;&lt; std::endl;\n        return false;\n    }\n}\n\nbool GameUI::GamePlay::setTeamScore(const std::string &amp;filePath, float windowWidth,\n                                    float windowHeight)\n{\n    if (TeamScoreImage.createImage(filePath))\n    {\n        TeamScoreImage.fitToScreen(windowWidth / 3.5, windowHeight / 3.5);\n        TeamScoreImage.setPosition(100, 40);\n        TeamScoreImage.setScale(0.5, 0.5);\n        return true;\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to load TeamScore image.\" &lt;&lt; std::endl;\n        return false;\n    }\n}\n\nbool GameUI::GamePlay::setLifeBoard(const std::string &amp;filePath, float windowWidth,\n                                    float windowHeight)\n{\n    if (LifeBoardImage.createImage(filePath))\n    {\n        LifeBoardImage.fitToScreen(windowWidth / 3.5, windowHeight / 3.5);\n        LifeBoardImage.setPosition(700, 40);\n        LifeBoardImage.setScale(0.3, 0.3);\n        return true;\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to load LifeBoard image.\" &lt;&lt; std::endl;\n        return false;\n    }\n}\n\nvoid GameUI::GamePlay::createPlayer1()\n{\n    player1.loadAnimation(\"red\", 8, 1.5, 1.5);\n    player1.setPosition(\"red\", 100, 100);\n}\n\nvoid GameUI::GamePlay::createPlayer2()\n{\n    player2.loadAnimation(\"blue\", 8, 1.5, 1.5);\n    player2.setPosition(\"blue\", 100, 200);\n}\n\n\nvoid GameUI::GamePlay::spawnRandomEnemies()\n{\n    // return random number between 1 and 9\n    int random = rand() % 9 + 1;\n    if (random == 1)\n    {\n        createEnemies();\n    }\n    else if (random == 2)\n    {\n        createEnemies2();\n    }\n    else if (random == 3)\n    {\n        createEnemies3();\n    }\n    else if (random == 4)\n    {\n        createEnemies4();\n    }\n    else if (random == 5)\n    {\n        createEnamies5();\n    }\n    else if (random == 6)\n    {\n        createEnamies6();\n    }\n    else if (random == 7)\n    {\n        createEnamies7();\n    }\n    else if (random == 8)\n    {\n        createEnamies8();\n    }\n    else if (random == 9)\n    {\n        createEnamies9();\n    }\n}\n\n\nvoid GameUI::GamePlay::createEnemies()\n{\n    enemies1.loadAnimation(\"green\", 8, 1.25, 1.25);\n    enemies1.setPosition(\"green\", 150, 150);\n}\n\nvoid GameUI::GamePlay::createEnemies2()\n{\n    enemies2.loadAnimation(\"yellow\", 8, 1.25, 1.25);\n    enemies2.setPosition(\"yellow\", 200, 200);\n}\n\nvoid GameUI::GamePlay::createEnemies3()\n{\n    enemies3.loadAnimation(\"purple\", 8, 1.25, 1.25);\n    enemies3.setPosition(\"purple\", 250, 250);\n}\n\nvoid GameUI::GamePlay::createEnemies4()\n{\n    enemies4.loadAnimation(\"orange\", 5, 1.25, 1.25);\n    enemies4.setPosition(\"orange\", 300, 300);\n}\n\nvoid GameUI::GamePlay::createEnamies5()\n{\n    enemies5.loadAnimation(\"pink\", 5, 1.25, 1.25);\n    enemies5.setPosition(\"pink\", 350, 350);\n}\n\nvoid GameUI::GamePlay::createEnamies6()\n{\n    enemies6.loadAnimation(\"cyan\", 5, 1.25, 1.25);\n    enemies6.setPosition(\"cyan\", 400, 400);\n}\n\nvoid GameUI::GamePlay::createEnamies7()\n{\n    enemies7.loadAnimation(\"brown\", 5, 1.25, 1.25);\n    enemies7.setPosition(\"brown\", 450, 450);\n}\n\nvoid GameUI::GamePlay::createEnamies8()\n{\n    enemies8.loadAnimation(\"white\", 5, 1.25, 1.25);\n    enemies8.setPosition(\"white\", 500, 500);\n}\n\nvoid GameUI::GamePlay::createEnamies9()\n{\n    enemies9.loadAnimation(\"black\", 5, 1.25, 1.25);\n    enemies9.setPosition(\"black\", 550, 550);\n}\n\nvoid GameUI::GamePlay::createEnamiesBoss()\n{\n    enemiesBoss.loadAnimation(\"boss\", 8, 1.25, 1.25);\n    enemiesBoss.setPosition(\"boss\", 200, 200);\n}\n\nvoid GameUI::GamePlay::drawBackground(sf::RenderWindow &amp;window)\n{\n    window.draw(getBackgroundSprite());\n}\n\nvoid GameUI::GamePlay::drawTeamScore(sf::RenderWindow &amp;window)\n{\n    window.draw(getTeamScoreSprite());\n}\n\nvoid GameUI::GamePlay::drawLifeBoard(sf::RenderWindow &amp;window)\n{\n    window.draw(getLifeBoardSprite());\n}\n\nconst sf::Sprite &amp;GameUI::GamePlay::getTeamScoreSprite() const\n{\n    return TeamScoreImage.getSprite();\n}\n\nconst sf::Sprite &amp;GameUI::GamePlay::getBackgroundSprite() const\n{\n    return backgroundImage.getSprite();\n}\n\nconst sf::Sprite &amp;GameUI::GamePlay::getLifeBoardSprite() const\n{\n    return LifeBoardImage.getSprite();\n}\n\nvoid GameUI::GamePlay::centerImage(ImageManager &amp;img, float windowWidth, float windowHeight)\n{\n    sf::Sprite &amp;sprite = img.getSprite();\n    sf::FloatRect bounds = sprite.getLocalBounds();\n    sprite.setOrigin(bounds.width / 2, bounds.height / 2);\n    sprite.setPosition(windowWidth / 2, windowHeight / 2);\n}\n\nvoid GameUI::GamePlay::shapebuilder(sf::RenderWindow &amp;window)\n{\n}\n\nvoid GameUI::GamePlay::loadFont(const std::string &amp;fontPath)\n{\n    if (!font.loadFromFile(fontPath))\n    {\n        std::cerr &lt;&lt; \"Failed to load font.\" &lt;&lt; std::endl;\n    }\n}\n\nvoid GameUI::GamePlay::update()\n{\n}\n\nvoid GameUI::GamePlay::render(sf::RenderWindow &amp;window)\n{\n    window.clear();\n\n    float windowWidth = window.getSize().x;\n    float windowHeight = window.getSize().y;\n    if (setBackground(\"assets/image/Background/background2.png\", windowWidth, windowHeight))\n    {\n        drawBackground(window);\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to set background\" &lt;&lt; std::endl;\n    }\n\n    if (setTeamScore(\"assets/image/Element/score.png\", windowWidth, windowHeight))\n    {\n        drawTeamScore(window);\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to set setting\" &lt;&lt; std::endl;\n    }\n\n    if (setLifeBoard(\"assets/image/Element/life_board.png\", windowWidth, windowHeight))\n    {\n        drawLifeBoard(window);\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to set setting\" &lt;&lt; std::endl;\n    }\n\n    player1.update(\"red\");\n    player1.render(window, \"red\");\n\n    player2.update(\"blue\");\n    player2.render(window, \"blue\");\n\n    enemies1.update(\"green\");\n    enemies1.render(window, \"green\");\n\n    enemies2.update(\"yellow\");\n    enemies2.render(window, \"yellow\");\n\n    enemies3.update(\"purple\");\n    enemies3.render(window, \"purple\");\n\n    enemies4.update(\"orange\");\n    enemies4.render(window, \"orange\");\n\n    enemies5.update(\"pink\");\n    enemies5.render(window, \"pink\");\n\n    enemies6.update(\"cyan\");\n    enemies6.render(window, \"cyan\");\n\n    enemies7.update(\"brown\");\n    enemies7.render(window, \"brown\");\n\n    enemies8.update(\"white\");\n    enemies8.render(window, \"white\");\n\n    enemies9.update(\"black\");\n    enemies9.render(window, \"black\");\n\n    shapebuilder(window);\n    window.display();\n}\n\nvoid GameUI::GamePlay::handleEvent(sf::Event &amp;event)\n{\n\n    // move player using keyboard\n    if (event.type == sf::Event::KeyPressed)\n    {\n        if (event.key.code == sf::Keyboard::Up)\n        {\n            player1.moveY(\"red\", -5);\n        }\n        if (event.key.code == sf::Keyboard::Down)\n        {\n            player1.moveY(\"red\", 5);\n        }\n        if (event.key.code == sf::Keyboard::Left)\n        {\n            player1.moveXRight(\"red\", -5);\n        }\n        if (event.key.code == sf::Keyboard::Right)\n        {\n            player1.moveXRight(\"red\", 5);\n        }\n    }\n\n\n    if (event.type == sf::Event::MouseButtonPressed)\n    {\n        sf::Vector2f mousePos = sf::Vector2f(event.mouseButton.x, event.mouseButton.y);\n        std::cout &lt;&lt; \"x: \" &lt;&lt; mousePos.x &lt;&lt; \" y: \" &lt;&lt; mousePos.y &lt;&lt; std::endl;\n    }\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GamePlay_8hpp/","title":"File GamePlay.hpp","text":"<p>FileList &gt; Client &gt; GamePlay.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ScreenManager.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GamePlay_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace GameUI"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GamePlay_8hpp/#classes","title":"Classes","text":"Type Name class GamePlay <p>The documentation for this class was generated from the following file <code>src/Client/GamePlay.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GamePlay_8hpp_source/","title":"File GamePlay.hpp","text":"<p>File List &gt; Client &gt; GamePlay.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"ScreenManager.hpp\"\n\nnamespace GameUI\n{\n    class GamePlay : public IScreen\n    {\n    private:\n        sf::Font font;\n        std::string input;\n        ImageManager GamePlayImage, backgroundImage, TeamScoreImage, LifeBoardImage;\n        AudioManager ButtonSound;\n        Animation player1, player2;\n        Animation enemies1, enemies2, enemies3, enemies4, enemies5, enemies6, enemies7, enemies8, enemies9, enemiesBoss;\n        ShapeManager shapeManager1, shapeManager2;\n        void centerImage(ImageManager &amp;img, float windowWidth, float windowHeight);\n        ScreenManager &amp;screenManager;\n\n    public:\n        bool playIsUp, playIsDown, playIsRight, playIsLeft;\n        GamePlay(ScreenManager &amp;screenManager);\n        void render(sf::RenderWindow &amp;window) override;\n        void update() override;\n        void loadFont(const std::string &amp;fontPath);\n        void handleEvent(sf::Event &amp;event) override;\n\n        void createPlayer1();\n        void createPlayer2();\n        void createEnemies();\n        void createEnemies2();\n        void createEnemies3();\n        void createEnemies4();\n        void createEnamies5();\n        void createEnamies6();\n        void createEnamies7();\n        void createEnamies8();\n        void createEnamies9();\n        void createEnamiesBoss();\n        void spawnRandomEnemies();\n        bool setBackground(const std::string &amp;filePath, float windowWidth, float windowHeight);\n        bool setTeamScore(const std::string &amp;filePath, float windowWidth, float windowHeight);\n        bool setLifeBoard(const std::string &amp;filePath, float windowWidth, float windowHeight);\n\n        void drawTeamScore(sf::RenderWindow &amp;window);\n        void drawBackground(sf::RenderWindow &amp;window);\n        void drawLifeBoard(sf::RenderWindow &amp;window);\n\n        const sf::Sprite &amp;getTeamScoreSprite() const;\n        const sf::Sprite &amp;getBackgroundSprite() const;\n        const sf::Sprite &amp;getLifeBoardSprite() const;\n\n        void shapebuilder(sf::RenderWindow &amp;window);\n\n        AudioManager &amp;getButtonSound() { return ButtonSound; }\n    };\n} // namespace GameUI\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameSetting_8cpp/","title":"File GameSetting.cpp","text":"<p>FileList &gt; Client &gt; GameSetting.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"GameSetting.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Client/GameSetting.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameSetting_8cpp_source/","title":"File GameSetting.cpp","text":"<p>File List &gt; Client &gt; GameSetting.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"GameSetting.hpp\"\n\nGameUI::GameSetting::GameSetting(ScreenManager &amp;screenManager) : screenManager(screenManager)\n{\n    if (!font.loadFromFile(\"assets/font/Bangers.ttf\"))\n    {\n        std::cerr &lt;&lt; \"Failed to load font.\" &lt;&lt; std::endl;\n    }\n}\n\nbool GameUI::GameSetting::setGameSetting(const std::string &amp;filePath, float windowWidth,\n                                         float windowHeight)\n{\n    if (GameSettingImage.createImage(filePath))\n    {\n        GameSettingImage.fitToScreen(windowWidth / 2, windowHeight / 2);\n        centerImage(GameSettingImage, windowWidth, windowHeight);\n        return true;\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to load GameSetting image.\" &lt;&lt; std::endl;\n        return false;\n    }\n}\n\nbool GameUI::GameSetting::setBackground(const std::string &amp;filePath, float windowWidth,\n                                        float windowHeight)\n{\n    if (backgroundImage.createImage(filePath))\n    {\n        backgroundImage.fitToScreen(windowWidth, windowHeight);\n        return true;\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to load background image.\" &lt;&lt; std::endl;\n        return false;\n    }\n}\n\nvoid GameUI::GameSetting::drawBackground(sf::RenderWindow &amp;window)\n{\n    window.draw(getBackgroundSprite());\n}\n\nvoid GameUI::GameSetting::drawGameSetting(sf::RenderWindow &amp;window)\n{\n    window.draw(getGameSettingSprite());\n}\n\nconst sf::Sprite &amp;GameUI::GameSetting::getGameSettingSprite() const\n{\n    return GameSettingImage.getSprite();\n}\n\nconst sf::Sprite &amp;GameUI::GameSetting::getBackgroundSprite() const\n{\n    return backgroundImage.getSprite();\n}\n\nvoid GameUI::GameSetting::centerImage(ImageManager &amp;img, float windowWidth, float windowHeight)\n{\n    sf::Sprite &amp;sprite = img.getSprite();\n    sf::FloatRect bounds = sprite.getLocalBounds();\n    sprite.setOrigin(bounds.width / 2, bounds.height / 2);\n    sprite.setPosition(windowWidth / 2, windowHeight / 2);\n}\n\nvoid GameUI::GameSetting::shapebuilder(sf::RenderWindow &amp;window)\n{\n    // this-&gt;rect1 = shapeManager1.drawRectangle(window, 592, 366, 180, 50,\n    // sf::Color::Blue, 5, true); sf::FloatRect textBounds =\n    // textip.getLocalBounds(); textip.setOrigin(textBounds.left +\n    // textBounds.width / 2.0f, textBounds.top + textBounds.height / 2.0f);\n    // textip.setPosition(rect1.getPosition().x + rect1.getSize().x / 2.0f,\n    // rect1.getPosition().y + rect1.getSize().y / 2.0f); window.draw(textip);\n\n    // this-&gt;rect2 = shapeManager2.drawRectangle(window, 596, 501, 180, 50,\n    // sf::Color::Red, 5); sf::FloatRect textBounds2 = textname.getLocalBounds();\n    // textname.setOrigin(textBounds2.left + textBounds2.width / 2.0f,\n    // textBounds2.top + textBounds2.height / 2.0f);\n    // textname.setPosition(rect2.getPosition().x + rect2.getSize().x / 2.0f,\n    // rect2.getPosition().y + rect2.getSize().y / 2.0f);\n}\n\nvoid GameUI::GameSetting::loadFont(const std::string &amp;fontPath)\n{\n    if (!font.loadFromFile(fontPath))\n    {\n        std::cerr &lt;&lt; \"Failed to load font.\" &lt;&lt; std::endl;\n    }\n}\n\nvoid GameUI::GameSetting::update()\n{\n}\n\nvoid GameUI::GameSetting::render(sf::RenderWindow &amp;window)\n{\n    window.clear();\n\n    float windowWidth = window.getSize().x;\n    float windowHeight = window.getSize().y;\n    if (setBackground(\"assets/image/Background/seamful_background.png\", windowWidth, windowHeight))\n    {\n        drawBackground(window);\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to set background\" &lt;&lt; std::endl;\n    }\n\n    if (setGameSetting(\"assets/image/Element/setting.png\", windowWidth, windowHeight))\n    {\n        drawGameSetting(window);\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to set setting\" &lt;&lt; std::endl;\n    }\n\n    shapebuilder(window);\n    window.display();\n}\n\nvoid GameUI::GameSetting::handleEvent(sf::Event &amp;event)\n{\n    if (event.type == sf::Event::MouseButtonPressed)\n    {\n        sf::Vector2f mousePos = sf::Vector2f(event.mouseButton.x, event.mouseButton.y);\n        std::cout &lt;&lt; \"x: \" &lt;&lt; mousePos.x &lt;&lt; \" y: \" &lt;&lt; mousePos.y &lt;&lt; std::endl;\n\n        // if\n        // (getRect2().getGlobalBounds().contains(static_cast&lt;sf::Vector2f&gt;(mousePos)))\n        // {\n        //     std::cout &lt;&lt; \"Button clicked 2\" &lt;&lt; std::endl;\n        //     getButtonSound().playSound(\"assets/audio/Effect/button.mp3\");\n        //     sf::sleep(sf::seconds(0.5));\n        //     screenManager.switchToScreen(\"GameSetting\");\n        // }\n    }\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameSetting_8hpp/","title":"File GameSetting.hpp","text":"<p>FileList &gt; Client &gt; GameSetting.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ScreenManager.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameSetting_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace GameUI"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameSetting_8hpp/#classes","title":"Classes","text":"Type Name class GameSetting <p>The documentation for this class was generated from the following file <code>src/Client/GameSetting.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/GameSetting_8hpp_source/","title":"File GameSetting.hpp","text":"<p>File List &gt; Client &gt; GameSetting.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"ScreenManager.hpp\"\n\nnamespace GameUI\n{\n    class GameSetting : public IScreen\n    {\n    private:\n        sf::Font font;\n        std::string input;\n        ImageManager GameSettingImage, backgroundImage;\n        AudioManager ButtonSound;\n        MouseManager mouse;\n        sf::Text textip, textname;\n        sf::RectangleShape rect1, rect2;\n        ShapeManager shapeManager1, shapeManager2;\n        void centerImage(ImageManager &amp;img, float windowWidth, float windowHeight);\n        ScreenManager &amp;screenManager;\n\n    public:\n        GameSetting(ScreenManager &amp;screenManager);\n        void render(sf::RenderWindow &amp;window) override;\n        void update() override;\n        void loadFont(const std::string &amp;fontPath);\n        void handleEvent(sf::Event &amp;event) override;\n\n        bool setBackground(const std::string &amp;filePath, float windowWidth, float windowHeight);\n        bool setGameSetting(const std::string &amp;filePath, float windowWidth, float windowHeight);\n\n        void drawGameSetting(sf::RenderWindow &amp;window);\n        void drawBackground(sf::RenderWindow &amp;window);\n\n        const sf::Sprite &amp;getGameSettingSprite() const;\n        const sf::Sprite &amp;getBackgroundSprite() const;\n\n        void shapebuilder(sf::RenderWindow &amp;window);\n\n        sf::RectangleShape &amp;getRect1() { return rect1; }\n        sf::RectangleShape &amp;getRect2() { return rect2; }\n\n        AudioManager &amp;getButtonSound() { return ButtonSound; }\n    };\n\n} // namespace GameUI\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Health__system_8cpp/","title":"File Health_system.cpp","text":"<p>FileList &gt; Server &gt; Health_system.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../include/Server/Health_system.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Server/Health_system.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Health__system_8cpp_source/","title":"File Health_system.cpp","text":"<p>File List &gt; Server &gt; Health_system.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** game_logic\n** File description:\n** Health_system.cpp\n*/\n\n#include \"../../include/Server/Health_system.hpp\"\n\nvoid HealthSystem::checkHealth(Registry &amp;registry)\n{\n    auto &amp;players = registry.get_entities(\"Player\");\n    auto &amp;enemies = registry.get_entities(\"Enemy\");\n\n    size_t enemyCount = 0;\n    if (players.empty())\n        return;\n\n    for (auto &amp;enemy : enemies)\n    {\n        if (enemy-&gt;_alive == false)\n        {\n            enemyCount++;\n        }\n    }\n    for (auto &amp;player : players)\n    {\n        if (player-&gt;health-&gt;currentHealth &gt; 0)\n        {\n            player-&gt;health-&gt;takeDamage(enemyCount * 10);\n        }\n        if (player-&gt;health-&gt;currentHealth &lt;= 0)\n        {\n            player-&gt;_alive = false;\n        }\n    }\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Health__system_8hpp/","title":"File Health_system.hpp","text":"<p>FileList &gt; include &gt; Server &gt; Health_system.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Entity.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Health__system_8hpp/#classes","title":"Classes","text":"Type Name class HealthSystem Forward declaration of the Registry class. <p>The documentation for this class was generated from the following file <code>include/Server/Health_system.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Health__system_8hpp_source/","title":"File Health_system.hpp","text":"<p>File List &gt; include &gt; Server &gt; Health_system.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** game_logic\n** File description:\n** Health_system.hpp\n*/\n\n#ifndef HEALTH_SYSTEM_HPP_\n#define HEALTH_SYSTEM_HPP_\n#include \"Entity.hpp\"\n\nclass Registry; \n\nclass HealthSystem\n{\npublic:\n    void checkHealth(Registry &amp;registry);\n};\n\n#endif // HEALTH_SYSTEM_HPP_\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/ImageManager_8cpp/","title":"File ImageManager.cpp","text":"<p>FileList &gt; Engine &gt; Image &gt; ImageManager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../../include/Engine/Image/ImageManager.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Engine/Image/ImageManager.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/ImageManager_8cpp_source/","title":"File ImageManager.cpp","text":"<p>File List &gt; Engine &gt; Image &gt; ImageManager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"../../../include/Engine/Image/ImageManager.hpp\"\n\nImageManager::ImageManager()\n{\n}\n\nImageManager::~ImageManager()\n{\n    destroyImage();\n}\n\nbool ImageManager::createImage(const std::string &amp;filePath)\n{\n    if (!texture.loadFromFile(filePath))\n    {\n        std::cerr &lt;&lt; \"Erreur: impossible de charger l'image depuis \" &lt;&lt; filePath &lt;&lt; std::endl;\n        return false;\n    }\n    sprite.setTexture(texture);\n    return true;\n}\n\nvoid ImageManager::setPosition(float x, float y)\n{\n    sprite.setPosition(x, y);\n}\n\nvoid ImageManager::setScale(float scaleX, float scaleY)\n{\n    sprite.setScale(scaleX, scaleY);\n}\n\nvoid ImageManager::draw(sf::RenderWindow &amp;window)\n{\n    window.draw(sprite);\n}\n\nvoid ImageManager::destroyImage()\n{\n}\n\nsf::FloatRect ImageManager::getGlobalBounds()\n{\n    return sprite.getGlobalBounds();\n}\n\nvoid ImageManager::fitToScreen(float windowWidth, float windowHeight)\n{\n    if (texture.getSize().x == 0 || texture.getSize().y == 0)\n    {\n        return;\n    }\n\n    float scaleX = windowWidth / texture.getSize().x;\n    float scaleY = windowHeight / texture.getSize().y;\n    float scale = std::max(scaleX, scaleY);\n\n    sprite.setScale(scale, scale);\n    sf::FloatRect bounds = sprite.getLocalBounds();\n    sprite.setOrigin(bounds.width / 2, bounds.height / 2);\n    sprite.setPosition(windowWidth / 2, windowHeight / 2);\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/ImageManager_8hpp/","title":"File ImageManager.hpp","text":"<p>FileList &gt; Engine &gt; Image &gt; ImageManager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/ImageManager_8hpp/#classes","title":"Classes","text":"Type Name class ImageManager Handles image loading, manipulation, and rendering using the SFML graphics library. <p>The documentation for this class was generated from the following file <code>include/Engine/Image/ImageManager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/ImageManager_8hpp_source/","title":"File ImageManager.hpp","text":"<p>File List &gt; Engine &gt; Image &gt; ImageManager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef IMAGEMANAGER_HPP\n#define IMAGEMANAGER_HPP\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\nclass ImageManager\n{\npublic:\n    ImageManager();\n\n    ~ImageManager();\n\n    bool createImage(const std::string &amp;filePath);\n\n    void setPosition(float x, float y);\n\n    void setScale(float scaleX, float scaleY);\n\n    void draw(sf::RenderWindow &amp;window);\n\n    void destroyImage();\n\n    sf::FloatRect getGlobalBounds();\n    sf::Texture texture;\n\n    sf::Sprite &amp;getSprite() { return sprite; }\n    const sf::Sprite &amp;getSprite() const { return sprite; }\n    void fitToScreen(float windowWidth, float windowHeight);\n\nprivate:\n    sf::Sprite sprite;\n};\n\n#endif // IMAGEMANAGER_HPP\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/InputManager_8cpp/","title":"File InputManager.cpp","text":"<p>FileList &gt; Engine &gt; Input &gt; InputManager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../../include/Engine/Input/InputManager.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Engine/Input/InputManager.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/InputManager_8cpp_source/","title":"File InputManager.cpp","text":"<p>File List &gt; Engine &gt; Input &gt; InputManager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"../../../include/Engine/Input/InputManager.hpp\"\n\nInputManager::InputManager()\n{\n    button.left = button.right = button.up = button.down = button.attack = button.escape = false;\n}\n\nInputManager::~InputManager()\n{\n}\n\nInputManager::Button InputManager::getButton() const\n{\n    return button;\n}\n\nvoid InputManager::handleInput(sf::Event event, sf::RenderWindow &amp;window)\n{\n    if (event.type == sf::Event::KeyPressed)\n    {\n        switch (event.key.code)\n        {\n        case sf::Keyboard::Escape:\n            button.escape = true;\n            break;\n\n        case sf::Keyboard::Left:\n            button.left = true;\n            break;\n\n        case sf::Keyboard::Right:\n            button.right = true;\n            break;\n\n        case sf::Keyboard::Up:\n            button.up = true;\n            break;\n\n        case sf::Keyboard::Down:\n            button.down = true;\n            break;\n        case sf::Keyboard::A:\n            button.attack = true;\n            break;\n\n        default:\n            break;\n        }\n    }\n\n    if (event.type == sf::Event::KeyReleased)\n    {\n        switch (event.key.code)\n        {\n        case sf::Keyboard::Escape:\n            button.escape = false;\n            break;\n\n        case sf::Keyboard::Left:\n            button.left = false;\n            break;\n\n        case sf::Keyboard::Right:\n            button.right = false;\n            break;\n\n        case sf::Keyboard::Up:\n            button.up = false;\n            break;\n\n        case sf::Keyboard::Down:\n            button.down = false;\n            break;\n        case sf::Keyboard::A:\n            button.attack = false;\n            break;\n\n        default:\n            break;\n        }\n    }\n}\n\nvoid TextManager::drawText(const std::string &amp;text, float x, float y, sf::Color color,\n                           sf::RenderWindow &amp;window)\n{\n    sf::Text sfText;\n    sfText.setFont(font);\n    sfText.setString(text);\n    sfText.setPosition(x, y);\n    sfText.setFillColor(color);\n    window.draw(sfText);\n}\n\nvoid TextManager::drawTextTemporarily(const std::string &amp;text, float x, float y, sf::Color color,\n                                      float duration, sf::RenderWindow &amp;window)\n{\n\n    TemporaryText tempText;\n    tempText.text.setFont(font);\n    tempText.text.setString(text);\n    tempText.text.setPosition(x, y);\n    tempText.text.setFillColor(color);\n    tempText.duration = duration;\n    tempText.clock.restart();\n    tempTexts.push_back(tempText);\n}\n\nvoid TextManager::loadFont(const std::string &amp;fontPath)\n{\n    if (!font.loadFromFile(fontPath))\n    {\n        std::cerr &lt;&lt; \"Failed to load font.\" &lt;&lt; std::endl;\n    }\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/InputManager_8hpp/","title":"File InputManager.hpp","text":"<p>FileList &gt; Engine &gt; Input &gt; InputManager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> <li><code>#include &lt;SFML/Window.hpp&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/InputManager_8hpp/#classes","title":"Classes","text":"Type Name class InputManager Manages keyboard and window input events using the SFML library. struct TemporaryText class TextManager <p>The documentation for this class was generated from the following file <code>include/Engine/Input/InputManager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/InputManager_8hpp_source/","title":"File InputManager.hpp","text":"<p>File List &gt; Engine &gt; Input &gt; InputManager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef INPUTMANAGER_HPP\n#define INPUTMANAGER_HPP\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;SFML/Window.hpp&gt;\n#include &lt;iostream&gt;\n\nclass InputManager\n{\n    struct Button\n    {\n        bool left;   \n        bool right;  \n        bool up;     \n        bool down;   \n        bool attack; \n        bool escape; \n    };\n\nprivate:\n    Button button;\n\npublic:\n    InputManager();\n\n    ~InputManager();\n\n    void handleInput(sf::Event event, sf::RenderWindow &amp;window);\n\n    Button getButton(void) const;\n};\n\nstruct TemporaryText\n{\n    sf::Text text;\n    sf::Clock clock;\n    float duration;\n};\n\nclass TextManager\n{\nprivate:\n    sf::Font font;\n    sf::Event event;\n    InputManager input;\n    std::vector&lt;TemporaryText&gt; tempTexts;\n\npublic:\n    TextManager() {};\n    void drawText(const std::string &amp;text, float x, float y, sf::Color color,\n                  sf::RenderWindow &amp;window);\n    void loadFont(const std::string &amp;fontPath);\n    void render();\n    void handleEvent();\n    void drawTextTemporarily(const std::string &amp;text, float x, float y, sf::Color color,\n                             float duration, sf::RenderWindow &amp;window);\n    sf::RenderWindow &amp;GetWindow();\n};\n\n#endif // INPUTMANAGER_HPP\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/MenuWindowManager_8cpp/","title":"File MenuWindowManager.cpp","text":"<p>FileList &gt; Client &gt; Save &gt; MenuWindowManager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"MenuWindowManager.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Client/Save/MenuWindowManager.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/MenuWindowManager_8cpp_source/","title":"File MenuWindowManager.cpp","text":"<p>File List &gt; Client &gt; Save &gt; MenuWindowManager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"MenuWindowManager.hpp\"\n\nWindowManager::WindowManager(int width, int height, const std::string &amp;windowName)\n    : window(sf::VideoMode(width, height), windowName)\n\n{\n}\n\nvoid WindowManager::keepOpen()\n{\n    animation.setPosition(\"red\", 100.0f, 200.0f);\n    animation.setPosition(\"gray\", 300.0f, 400.0f);\n\n    while (window.isOpen())\n    {\n        animation.update(\"red\");\n        animation.update(\"gray\");\n        handleEvent();\n        render();\n    }\n}\n\nvoid WindowManager::loadFont(const std::string &amp;fontPath)\n{\n    if (!font.loadFromFile(fontPath))\n    {\n    }\n}\n\nvoid WindowManager::SetWindowSize(const sf::Vector2u &amp;size)\n{\n    if (size.x == 0 || size.y == 0)\n    {\n        window.create(sf::VideoMode::getDesktopMode(), \"Game Menu\", sf::Style::Fullscreen);\n    }\n    else\n    {\n        window.setSize(size);\n    }\n}\n\nvoid WindowManager::render()\n{\n    window.clear(sf::Color::Black);\n    window.display();\n}\n\nvoid WindowManager::handleEvent()\n{\n    while (window.pollEvent(event))\n    {\n        if (event.type == sf::Event::Closed)\n        {\n            window.close();\n        }\n    }\n}\n\nsf::RenderWindow &amp;WindowManager::GetWindow()\n{\n    return this-&gt;window;\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/MenuWindowManager_8hpp/","title":"File MenuWindowManager.hpp","text":"<p>FileList &gt; Client &gt; Save &gt; MenuWindowManager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include \"../../include/Engine/Animation/Animation.hpp\"</code></li> <li><code>#include \"../../include/Engine/Input/InputManager.hpp\"</code></li> <li><code>#include \"../../include/Engine/Mouse/MouseManager.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/MenuWindowManager_8hpp/#classes","title":"Classes","text":"Type Name struct TemporaryText class WindowManager <p>The documentation for this class was generated from the following file <code>src/Client/Save/MenuWindowManager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/MenuWindowManager_8hpp_source/","title":"File MenuWindowManager.hpp","text":"<p>File List &gt; Client &gt; Save &gt; MenuWindowManager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef HEADER_HPP\n#define HEADER_HPP\n#include &lt;iostream&gt;\n\n#include \"../../include/Engine/Animation/Animation.hpp\"\n#include \"../../include/Engine/Input/InputManager.hpp\"\n#include \"../../include/Engine/Mouse/MouseManager.hpp\"\n\nstruct TemporaryText\n{\n    sf::Text text;\n    sf::Clock clock;\n    float duration;\n};\n\nclass WindowManager\n{\nprivate:\n    sf::RenderWindow window;\n    sf::Font font;\n    sf::Event event;\n    InputManager input;\n    MouseManager mouse;\n    std::vector&lt;TemporaryText&gt; tempTexts;\n    Animation animation;\n\npublic:\n    WindowManager(int width, int height, const std::string &amp;windowName);\n    void keepOpen();\n    void drawText(const std::string &amp;text, float x, float y, sf::Color color);\n    void loadFont(const std::string &amp;fontPath);\n    void render();\n    void handleEvent();\n    void SetWindowSize(const sf::Vector2u &amp;size);\n    sf::RenderWindow &amp;GetWindow();\n};\n\n#endif\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Menu_8cpp/","title":"File Menu.cpp","text":"<p>FileList &gt; Client &gt; Save &gt; Menu.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Menu.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Menu_8cpp/#public-functions","title":"Public Functions","text":"Type Name int main ()"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Menu_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Menu_8cpp/#function-main","title":"function main","text":"<pre><code>int main () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Client/Save/Menu.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Menu_8cpp_source/","title":"File Menu.cpp","text":"<p>File List &gt; Client &gt; Save &gt; Menu.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Menu.hpp\"\n\nMenu::Menu()\n    : windowManager(BASE_WIDTH, BASE_HEIGHT, \"Game Menu\"), window(windowManager.GetWindow()),\n      volumeLevel(100), isSoundOn(true), currentResolutionIndex(1)\n{\n    initializeMusic();\n    loadImages();\n    loadVolumeImages();\n    updateVolumeImage();\n    loadResolutionImages();\n    updateResolutionImage();\n}\n\nvoid Menu::initializeMusic()\n{\n    if (!music.openFromFile(\"assets/audio/Music/UNSquadron.ogg\"))\n    {\n        std::cerr &lt;&lt; \"Error: Unable to load music\" &lt;&lt; std::endl;\n    }\n    else\n    {\n        music.setLoop(true);\n        music.play();\n        music.setVolume(volumeLevel);\n    }\n}\n\n// void Menu::centerImage(ImageManager&amp; img, float windowWidth, float\n// windowHeight) {\n//     sf::Sprite&amp; sprite = img.getSprite();\n//     sf::FloatRect bounds = sprite.getLocalBounds();\n//     sprite.setOrigin(bounds.width / 2, bounds.height / 2);\n//     sprite.setPosition(windowWidth / 2, windowHeight / 2);\n// }\n\nvoid Menu::drawGameLobby(sf::RenderWindow &amp;window)\n{\n    window.draw(getGameLobbySprite());\n}\n\nvoid Menu::loadImages()\n{\n    // loadAndSetupImage(backgroundImage,\n    // \"assets/image/Background/seamful_background.png\", 1.5f, 1.5f, 0, 0);\n    // loadAndSetupImage(titleImage, \"assets/image/Button/logo.png\", 1.5f, 1.5f,\n    // 700, 200); loadAndSetupImage(startButtonImage,\n    // \"assets/image/Element/play.png\", 1.0f, 1.0f, 860, 600);\n    // loadAndSetupImage(settingsButtonImage,\n    // \"assets/image/Element/settings.png\", 1.0f, 1.0f, 860, 770);\n    loadAndSetupImage(setVolumeImage, \"assets/image/Element/volume.png\", 1.0f, 1.0f, 250, 250);\n    loadAndSetupImage(moinsButton, \"assets/image/Element/-.png\", 1.0f, 1.0f, 900, 200);\n    loadAndSetupImage(plusButton, \"assets/image/Element/+.png\", 1.0f, 1.0f, 1700, 250);\n    loadAndSetupImage(soundImage, \"assets/image/Element/sound.png\", 1.0f, 1.0f, 250, 450);\n    loadAndSetupImage(onImage, \"assets/image/Element/on.png\", 1.0f, 1.0f, 1300, 450);\n    loadAndSetupImage(offImage, \"assets/image/Element/off.png\", 1.0f, 1.0f, 1300, 450);\n    loadAndSetupImage(infButton, \"assets/image/Element/inf.png\", 1.0f, 1.0f, 900, 450);\n    loadAndSetupImage(supButton, \"assets/image/Element/sup.png\", 1.0f, 1.0f, 1700, 450);\n    loadAndSetupImage(screenResolutionImage, \"assets/image/Element/resolution.png\", 1.0f, 1.0f, 250,\n                      650);\n    loadAndSetupImage(screen_infButton, \"assets/image/Element/inf.png\", 1.0f, 1.0f, 900, 650);\n    loadAndSetupImage(screen_supButton, \"assets/image/Element/sup.png\", 1.0f, 1.0f, 1700, 650);\n    loadAndSetupImage(goBackButtonImage, \"assets/image/Element/back.png\", 1.0f, 1.0f, 100, 900);\n    loadAndSetupImage(applyChangesButtonImage, \"assets/image/Element/apply.png\", 1.0f, 1.0f, 1320,\n                      900);\n}\n\nvoid Menu::loadAndSetupImage(ImageManager &amp;img, const std::string &amp;path, float scaleX, float scaleY,\n                             float posX, float posY)\n{\n    img.createImage(path);\n    img.setScale(scaleX, scaleY);\n    img.setPosition(posX, posY);\n}\n\n// void Menu::handleEvents() {\n//     sf::Event event;\n//     while (window.pollEvent(event)) {\n//         handleWindowEvents(event);\n//         handleMouseEvents(event);\n//     }\n// }\n\nvoid Menu::handleWindowEvents(const sf::Event &amp;event)\n{\n    if (event.type == sf::Event::Closed)\n    {\n        window.close();\n    }\n    // inputManager.handleInput(event, window);\n    // mouseManager.handleMousePosition(window);\n    // if (inputManager.getButton().escape) {\n    //     window.close();\n    // }\n}\n\nvoid Menu::handleMouseEvents(const sf::Event &amp;event)\n{\n    if (event.type == sf::Event::MouseButtonPressed)\n    {\n        float mouseX = mouseManager.getMouseX();\n        float mouseY = mouseManager.getMouseY();\n        handleButtonClicks(mouseX, mouseY);\n    }\n}\n\nvoid Menu::handleButtonClicks(float mouseX, float mouseY)\n{\n    if (startButtonImage.getGlobalBounds().contains(mouseX, mouseY))\n    {\n        std::cout &lt;&lt; \"Start button clicked\" &lt;&lt; std::endl;\n    }\n    if (settingsButtonImage.getGlobalBounds().contains(mouseX, mouseY))\n    {\n        std::cout &lt;&lt; \"Settings button clicked\" &lt;&lt; std::endl;\n        openSettings();\n    }\n}\n\nvoid Menu::update()\n{\n}\n\nvoid Menu::render()\n{\n    window.clear(sf::Color::Black);\n\n    float windowWidth = window.getSize().x;\n    float windowHeight = window.getSize().y;\n    if (setBackground(\"assets/image/Background/background1.png\", windowWidth, windowHeight))\n    {\n        drawBackground(window);\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to set background\" &lt;&lt; std::endl;\n    }\n    window.display();\n}\n\n// void Menu::drawMainMenu() {\n//     // backgroundImage.draw(window);\n//     // titleImage.draw(window);\n//     // startButtonImage.draw(window);\n//     // settingsButtonImage.draw(window);\n// }\n\nvoid Menu::centerImage(ImageManager &amp;img, float windowWidth, float windowHeight)\n{\n    sf::Sprite &amp;sprite = img.getSprite();\n    sf::FloatRect bounds = sprite.getLocalBounds();\n    sprite.setOrigin(bounds.width / 2, bounds.height / 2);\n    sprite.setPosition(windowWidth / 2, windowHeight / 2);\n}\n\nvoid Menu::run()\n{\n    while (window.isOpen())\n    {\n        // handleEvents();\n        // update();\n        render();\n    }\n}\n\nint main()\n{\n    Menu menu;\n    menu.run();\n    return 0;\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Menu_8hpp/","title":"File Menu.hpp","text":"<p>FileList &gt; Client &gt; Save &gt; Menu.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;SFML/Audio.hpp&gt;</code></li> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include \"../../include/Engine/Animation/Animation.hpp\"</code></li> <li><code>#include \"../../include/Engine/Audio/AudioManager.hpp\"</code></li> <li><code>#include \"../../include/Engine/Image/ImageManager.hpp\"</code></li> <li><code>#include \"../../include/Engine/Input/InputManager.hpp\"</code></li> <li><code>#include \"../../include/Engine/Mouse/MouseManager.hpp\"</code></li> <li><code>#include \"../../include/Engine/Shape/ShapeManager.hpp\"</code></li> <li><code>#include \"MenuWindowManager.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Menu_8hpp/#classes","title":"Classes","text":"Type Name class Menu"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Menu_8hpp/#macros","title":"Macros","text":"Type Name define BASE_HEIGHT  1080 define BASE_WIDTH  1920"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Menu_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Menu_8hpp/#define-base_height","title":"define BASE_HEIGHT","text":"<pre><code>#define BASE_HEIGHT 1080\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Menu_8hpp/#define-base_width","title":"define BASE_WIDTH","text":"<pre><code>#define BASE_WIDTH 1920\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Client/Save/Menu.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Menu_8hpp_source/","title":"File Menu.hpp","text":"<p>File List &gt; Client &gt; Save &gt; Menu.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef MENU_HPP\n#define MENU_HPP\n#include &lt;SFML/Audio.hpp&gt;\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;iostream&gt;\n\n#include \"../../include/Engine/Animation/Animation.hpp\"\n#include \"../../include/Engine/Audio/AudioManager.hpp\"\n#include \"../../include/Engine/Image/ImageManager.hpp\"\n#include \"../../include/Engine/Input/InputManager.hpp\"\n#include \"../../include/Engine/Mouse/MouseManager.hpp\"\n#include \"../../include/Engine/Shape/ShapeManager.hpp\"\n#include \"MenuWindowManager.hpp\"\n\n#define BASE_WIDTH 1920\n#define BASE_HEIGHT 1080\n\nclass Menu\n{\npublic:\n    Menu();\n    void run();\n\n    sf::RectangleShape &amp;getRect1() { return rect1; }\n    sf::RectangleShape &amp;getRect2() { return rect2; }\n\n    // const sf::Sprite&amp; getBackgroundSprite() const;\n    const sf::Sprite &amp;getBackgroundSprite() const { return backgroundImage.getSprite(); }\n    const sf::Sprite &amp;getPlayButtonSprite() const;\n    void drawGameLobby(sf::RenderWindow &amp;window);\n\n    const sf::Sprite &amp;getGameLobbySprite() const { return GameLobbyImage.getSprite(); }\n\n    bool setBackground(const std::string &amp;filePath, float windowWidth, float windowHeight)\n    {\n        if (backgroundImage.createImage(filePath))\n        {\n            backgroundImage.fitToScreen(windowWidth, windowHeight);\n            return true;\n        }\n        else\n        {\n            std::cerr &lt;&lt; \"Failed to load background image.\" &lt;&lt; std::endl;\n            return false;\n        }\n    }\n\n    void drawBackground(sf::RenderWindow &amp;window) { window.draw(getBackgroundSprite()); }\n\nprivate:\n    void handleEvents();\n    void update();\n    void render();\n    void openSettings();\n    void applyChanges();\n    void initializeMusic();\n    void loadImages();\n    void drawMainMenu();\n    void renderSettings();\n    void handleNavigationClicks(float mouseX, float mouseY);\n    void loadAndSetupImage(ImageManager &amp;img, const std::string &amp;path, float scaleX, float scaleY,\n                           float posX, float posY);\n    void handleButtonClicks(float mouseX, float mouseY);\n    void handleWindowEvents(const sf::Event &amp;event);\n    void handleMouseEvents(const sf::Event &amp;event);\n    void handleSettingsClicks(const sf::Event &amp;event);\n    void handleVolumeClicks(float mouseX, float mouseY);\n    void decreaseVolume();\n    void increaseVolume();\n    void decreaseResolution();\n    void increaseResolution();\n    void drawSettingsBackground();\n    void drawSettingsElements();\n    void drawSoundToggle();\n    void updateElementPositions(const sf::Vector2u &amp;windowSize);\n    void updateElementPosition(ImageManager &amp;img, float x, float y, float scaleX, float scaleY);\n    bool handleSettingsEvents();\n    void handleSoundToggleClicks(float mouseX, float mouseY);\n    void handleResolutionClicks(float mouseX, float mouseY);\n    void loadVolumeImages();\n    void updateVolumeImage();\n    void loadResolutionImages();\n    void updateResolutionImage();\n\n    void centerImage(ImageManager &amp;img, float windowWidth, float windowHeight);\n\n    WindowManager windowManager;\n    AudioManager audioManager;\n\n    sf::RectangleShape rect1, rect2;\n\n    ImageManager GameLobbyImage, backgroundImage, startButtonImage, settingsButtonImage;\n    ImageManager setVolumeImage, soundImage, screenResolutionImage, goBackButtonImage;\n    ImageManager applyChangesButtonImage, plusButton, moinsButton, onImage;\n    ImageManager offImage, infButton, supButton, screen_infButton, screen_supButton;\n    ImageManager asteroid_1, asteroid_2, asteroid_3, asteroid_4;\n\n    InputManager inputManager;\n    MouseManager mouseManager;\n\n    sf::RenderWindow &amp;window;\n    bool settingsOpen = true;\n    bool isSoundOn;\n    int volumeLevel;\n    sf::Music music;\n\n    std::vector&lt;sf::Texture&gt; volumeTextures;\n    std::vector&lt;sf::Texture&gt; resolutionTextures;\n    sf::Sprite resolutionSprite;\n    sf::Sprite volumeSprite;\n\n    std::vector&lt;sf::Vector2u&gt; resolutions = {{1920, 1080}};\n    int currentResolutionIndex;\n};\n\n#endif\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/MouseManager_8cpp/","title":"File MouseManager.cpp","text":"<p>FileList &gt; Engine &gt; Mouse &gt; MouseManager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../../include/Engine/Mouse/MouseManager.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Engine/Mouse/MouseManager.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/MouseManager_8cpp_source/","title":"File MouseManager.cpp","text":"<p>File List &gt; Engine &gt; Mouse &gt; MouseManager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"../../../include/Engine/Mouse/MouseManager.hpp\"\n\nMouseManager::MouseManager()\n{\n}\n\nMouseManager::~MouseManager()\n{\n}\n\nvoid MouseManager::handleMousePosition(sf::RenderWindow &amp;window)\n{\n    sf::Vector2i mousePosition = sf::Mouse::getPosition(window);\n    x = mousePosition.x;\n    y = mousePosition.y;\n}\n\nfloat MouseManager::getMouseX() const\n{\n    return x;\n}\n\nfloat MouseManager::getMouseY() const\n{\n    return y;\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/MouseManager_8hpp/","title":"File MouseManager.hpp","text":"<p>FileList &gt; Engine &gt; Mouse &gt; MouseManager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> <li><code>#include &lt;SFML/Window.hpp&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/MouseManager_8hpp/#classes","title":"Classes","text":"Type Name class MouseManager Manages mouse input and tracks the mouse position within a window. <p>The documentation for this class was generated from the following file <code>include/Engine/Mouse/MouseManager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/MouseManager_8hpp_source/","title":"File MouseManager.hpp","text":"<p>File List &gt; Engine &gt; Mouse &gt; MouseManager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef MOUSEMANAGER_HPP\n#define MOUSEMANAGER_HPP\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;SFML/Window.hpp&gt;\n#include &lt;iostream&gt;\n\nclass MouseManager\n{\nprivate:\n    float x;\n\n    float y;\n\npublic:\n    MouseManager();\n\n    ~MouseManager();\n\n    void handleMousePosition(sf::RenderWindow &amp;window);\n\n    float getMouseX() const;\n\n    float getMouseY() const;\n};\n\n#endif // MOUSEMANAGER_HPP\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Mouvement__system_8cpp/","title":"File Mouvement_system.cpp","text":"<p>FileList &gt; Server &gt; Mouvement_system.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../include/Server/Mouvement_system.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Server/Mouvement_system.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Mouvement__system_8cpp_source/","title":"File Mouvement_system.cpp","text":"<p>File List &gt; Server &gt; Mouvement_system.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** game_logic\n** File description:\n** Mouvement_system.cpp\n*/\n\n#include \"../../include/Server/Mouvement_system.hpp\"\n\nvoid MouvementSystem::handleInput(Registry &amp;registry, std::string move_direction, std::string name)\n{\n    auto &amp;players = registry.get_entities(\"Player\");\n    if (players.empty())\n        return;\n    for (auto &amp;player : players)\n    {\n        player-&gt;input-&gt;reset();\n        if (!player-&gt;transform || !player-&gt;bbox)\n            return;\n        auto &amp;input = player-&gt;input;\n        if (player-&gt;name-&gt;name == name)\n        {\n            if (move_direction == \"keyup\")\n                input-&gt;up = true;\n            if (move_direction == \"keydown\")\n                input-&gt;down = true;\n            if (move_direction == \"keyleft\")\n                input-&gt;left = true;\n            if (move_direction == \"keyright\")\n                input-&gt;right = true;\n            if (move_direction == \"shoot\")\n                input-&gt;shoot = true;\n        }\n    }\n}\n\nVector2D MouvementSystem::move_player(Registry &amp;registry, std::string name)\n{\n    auto &amp;players = registry.get_entities(\"Player\");\n    if (players.empty())\n        return {0, 0};\n    for (auto &amp;player : players)\n    {\n        if (!player-&gt;transform || !player-&gt;bbox)\n            return {0, 0};\n        if (player-&gt;name-&gt;name == name)\n        {\n            player-&gt;transform-&gt;velocity = Vector2D(0, 0);\n            if (player-&gt;input-&gt;up)\n                player-&gt;transform-&gt;velocity.y = -5;\n            if (player-&gt;input-&gt;down)\n                player-&gt;transform-&gt;velocity.y = 5;\n            if (player-&gt;input-&gt;left)\n                player-&gt;transform-&gt;velocity.x = -5;\n            if (player-&gt;input-&gt;right)\n                player-&gt;transform-&gt;velocity.x = 5;\n\n            Vector2D newPosition = player-&gt;transform-&gt;position - player-&gt;transform-&gt;velocity;\n            if (newPosition.x &lt; 0)\n                newPosition.x = 0;\n            if (newPosition.y &lt; 0)\n                newPosition.y = 0;\n            std::cout &lt;&lt; \"Player \" &lt;&lt; name &lt;&lt; \" moved to: (\" &lt;&lt; newPosition.x &lt;&lt; \", \"\n                      &lt;&lt; newPosition.y &lt;&lt; \")\" &lt;&lt; std::endl;\n            return newPosition;\n        }\n    }\n    return {0, 0};\n}\n\nvoid MouvementSystem::system_movement(EntityVector &amp;entities)\n{\n    for (auto &amp;entity : entities)\n    {\n        if (entity-&gt;transform)\n        {\n            entity-&gt;transform-&gt;position = entity-&gt;transform-&gt;position + entity-&gt;transform-&gt;velocity;\n            if (entity-&gt;transform-&gt;position.x &lt; 0)\n                entity-&gt;transform-&gt;position.x = 0;\n            if (entity-&gt;transform-&gt;position.y &lt; 0)\n                entity-&gt;transform-&gt;position.y = 0;\n        }\n    }\n}\n\nVector2D MouvementSystem::enemy_move(Registry &amp;registry)\n{\n    auto enemies = registry.get_entities(\"Enemy\");\n\n    for (auto enemy : enemies)\n    {\n        enemy-&gt;transform-&gt;velocity = Vector2D(0, 0);\n        enemy-&gt;transform-&gt;velocity.x = -5;\n        return (enemy-&gt;transform-&gt;position - enemy-&gt;transform-&gt;velocity);\n    }\n    return {0, 0};\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Mouvement__system_8hpp/","title":"File Mouvement_system.hpp","text":"<p>FileList &gt; include &gt; Server &gt; Mouvement_system.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Entity.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Mouvement__system_8hpp/#classes","title":"Classes","text":"Type Name class MouvementSystem Forward declaration of the Registry class. <p>The documentation for this class was generated from the following file <code>include/Server/Mouvement_system.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Mouvement__system_8hpp_source/","title":"File Mouvement_system.hpp","text":"<p>File List &gt; include &gt; Server &gt; Mouvement_system.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** game_logic\n** File description:\n** Movement_system.hpp\n*/\n\n#ifndef MOVEMENT_SYSTEM_HPP_\n#define MOVEMENT_SYSTEM_HPP_\n#include \"Entity.hpp\"\n\nclass Registry; \n\nclass MouvementSystem\n{\npublic:\n    MouvementSystem(){};\n\n    ~MouvementSystem(){};\n\n    Vector2D move_player(Registry &amp;registry, std::string name);\n\n    void handleInput(Registry &amp;registry, std::string move_direction, std::string name);\n\n    void system_movement(EntityVector &amp;entities);\n\n    Vector2D enemy_move(Registry &amp;registry);\n};\n\n#endif // MOVEMENT_SYSTEM_HPP_\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/RoomLobby_8cpp/","title":"File RoomLobby.cpp","text":"<p>FileList &gt; Client &gt; RoomLobby.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"RoomLobby.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Client/RoomLobby.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/RoomLobby_8cpp_source/","title":"File RoomLobby.cpp","text":"<p>File List &gt; Client &gt; RoomLobby.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"RoomLobby.hpp\"\n\nGameUI::RoomLobby::RoomLobby(ScreenManager &amp;screenManager)\n    : screenManager(screenManager), activeInput(0)\n{\n    if (!font.loadFromFile(\"assets/font/Bangers.ttf\"))\n    {\n        std::cerr &lt;&lt; \"Failed to load font.\" &lt;&lt; std::endl;\n    }\n    textfieldsetter(font);\n}\n\nvoid GameUI::RoomLobby::update()\n{\n}\n\nvoid GameUI::RoomLobby::loadFont(const std::string &amp;fontPath)\n{\n    if (!font.loadFromFile(fontPath))\n    {\n        std::cerr &lt;&lt; \"Failed to load font.\" &lt;&lt; std::endl;\n    }\n}\n\nbool GameUI::RoomLobby::setRoomLobby(const std::string &amp;filePath, float windowWidth,\n                                     float windowHeight)\n{\n    if (RoomLobbyImage.createImage(filePath))\n    {\n        RoomLobbyImage.fitToScreen(windowWidth / 3.5, windowHeight / 3.5);\n        centerImage(RoomLobbyImage, windowWidth, windowHeight);\n        return true;\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to load RoomLobby image.\" &lt;&lt; std::endl;\n        return false;\n    }\n}\n\nbool GameUI::RoomLobby::setBackground(const std::string &amp;filePath, float windowWidth,\n                                      float windowHeight)\n{\n    if (backgroundImage.createImage(filePath))\n    {\n        backgroundImage.fitToScreen(windowWidth, windowHeight);\n        return true;\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to load background image.\" &lt;&lt; std::endl;\n        return false;\n    }\n}\n\nbool GameUI::RoomLobby::setBackButton(const std::string &amp;filePath, float windowWidth,\n                                      float windowHeight)\n{\n    if (backgroundImage.createImage(filePath))\n    {\n        backButtonImage.setPosition(10, 10);\n        return true;\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to load background image.\" &lt;&lt; std::endl;\n        return false;\n    }\n}\n\nvoid GameUI::RoomLobby::drawBackground(sf::RenderWindow &amp;window)\n{\n    window.draw(getBackgroundSprite());\n}\n\nvoid GameUI::RoomLobby::drawRoomLobby(sf::RenderWindow &amp;window)\n{\n    window.draw(getRoomLobbySprite());\n}\n\nvoid GameUI::RoomLobby::drawBackButton(sf::RenderWindow &amp;window)\n{\n    window.draw(getBackgroundSprite());\n}\n\nconst sf::Sprite &amp;GameUI::RoomLobby::getRoomLobbySprite() const\n{\n    return RoomLobbyImage.getSprite();\n}\n\nconst sf::Sprite &amp;GameUI::RoomLobby::getBackgroundSprite() const\n{\n    return backgroundImage.getSprite();\n}\n\nconst sf::Sprite &amp;GameUI::RoomLobby::getBackButtonSprite() const\n{\n    return backButtonImage.getSprite();\n}\n\nvoid GameUI::RoomLobby::centerImage(ImageManager &amp;img, float windowWidth, float windowHeight)\n{\n    sf::Sprite &amp;sprite = img.getSprite();\n    sf::FloatRect bounds = sprite.getLocalBounds();\n    sprite.setOrigin(bounds.width / 2, bounds.height / 2);\n    sprite.setPosition(windowWidth / 2, windowHeight / 2);\n}\n\nvoid GameUI::RoomLobby::textfieldsetter(sf::Font &amp;font)\n{\n    textip.setFont(font);\n    textip.setCharacterSize(40);\n    textip.setFillColor(sf::Color::Black);\n    textip.setPosition(515.f, 150.f);\n\n    textport.setFont(font);\n    textport.setCharacterSize(40);\n    textport.setFillColor(sf::Color::Black);\n    textport.setPosition(515.f, 320.f);\n\n    textname.setFont(font);\n    textname.setCharacterSize(40);\n    textname.setFillColor(sf::Color::Black);\n    textname.setPosition(515.f, 490.f);\n}\n\nvoid GameUI::RoomLobby::shapebuilder(sf::RenderWindow &amp;window)\n{\n    this-&gt;rect1 = shapeManager1.drawRectangle(window, 515, 150, 340, 35, sf::Color::Red, 5);\n    sf::FloatRect textBounds = textip.getLocalBounds();\n    textip.setOrigin(textBounds.left + textBounds.width / 2.0f,\n                     textBounds.top + textBounds.height / 2.0f);\n    textip.setPosition(rect1.getPosition().x + rect1.getSize().x / 2.0f,\n                       rect1.getPosition().y + rect1.getSize().y / 2.0f);\n    window.draw(textip);\n\n    this-&gt;rect2 = shapeManager2.drawRectangle(window, 515, 320, 340, 35, sf::Color::Red, 5);\n    sf::FloatRect textBounds2 = textport.getLocalBounds();\n    textport.setOrigin(textBounds2.left + textBounds2.width / 2.0f,\n                       textBounds2.top + textBounds2.height / 2.0f);\n    textport.setPosition(rect2.getPosition().x + rect2.getSize().x / 2.0f,\n                         rect2.getPosition().y + rect2.getSize().y / 2.0f);\n    window.draw(textport);\n\n    this-&gt;rect3 = shapeManager3.drawRectangle(window, 515, 490, 340, 35, sf::Color::Red, 5);\n    sf::FloatRect textBounds3 = textname.getLocalBounds();\n    textname.setOrigin(textBounds3.left + textBounds3.width / 2.0f,\n                       textBounds3.top + textBounds3.height / 2.0f);\n    textname.setPosition(rect3.getPosition().x + rect3.getSize().x / 2.0f,\n                         rect3.getPosition().y + rect3.getSize().y / 2.0f);\n    window.draw(textname);\n\n    this-&gt;rect4 = shapeManager4.drawRectangle(window, 550, 590, 230, 35, sf::Color::Red, 5);\n    sf::FloatRect textBounds4 = textname.getLocalBounds();\n    textname.setOrigin(textBounds4.left + textBounds4.width / 2.0f,\n                       textBounds4.top + textBounds4.height / 2.0f);\n    textname.setPosition(rect4.getPosition().x + rect4.getSize().x / 2.0f,\n                         rect4.getPosition().y + rect4.getSize().y / 2.0f);\n}\n\nvoid GameUI::RoomLobby::render(sf::RenderWindow &amp;window)\n{\n    window.clear();\n\n    float windowWidth = window.getSize().x;\n    float windowHeight = window.getSize().y;\n    if (setBackground(\"assets/image/Background/background1.png\", windowWidth, windowHeight))\n    {\n        drawBackground(window);\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to set background\" &lt;&lt; std::endl;\n    }\n\n    if (setRoomLobby(\"assets/image/Element/panel.png\", windowWidth, windowHeight))\n    {\n        drawRoomLobby(window);\n    }\n    else\n    {\n        std::cerr &lt;&lt; \"Failed to set setting\" &lt;&lt; std::endl;\n    }\n\n    shapebuilder(window);\n    window.display();\n}\n\nvoid GameUI::RoomLobby::handleEvent(sf::Event &amp;event)\n{\n    if (event.type == sf::Event::TextEntered)\n\n    {\n        if (event.text.unicode &lt; 128)\n        {\n            if (event.text.unicode == '\\b')\n            {\n                if (!inputIp.empty() &amp;&amp; activeInput == 0)\n                {\n                    inputIp.pop_back();\n                    getTextIp().setString(inputIp);\n                }\n                else if (!inputPort.empty() &amp;&amp; activeInput == 1)\n                {\n                    inputPort.pop_back();\n                    getTextPort().setString(inputPort);\n                }\n                else if (!inputName.empty() &amp;&amp; activeInput == 2)\n                {\n                    inputName.pop_back();\n                    getTextName().setString(inputName);\n                }\n            }\n            else if (event.text.unicode == '\\t')\n            {\n                activeInput = (activeInput + 1) % 3;\n            }\n            else\n            {\n                if (activeInput == 0)\n                {\n                    inputIp += static_cast&lt;char&gt;(event.text.unicode);\n                    getTextIp().setString(inputIp);\n                }\n                else if (activeInput == 1)\n                {\n                    inputPort += static_cast&lt;char&gt;(event.text.unicode);\n                    getTextPort().setString(inputPort);\n                }\n                else if (activeInput == 2)\n                {\n                    inputName += static_cast&lt;char&gt;(event.text.unicode);\n                    getTextName().setString(inputName);\n                }\n            }\n        }\n    }\n\n    if (event.type == sf::Event::MouseButtonPressed)\n    {\n        sf::Vector2i mousePos = sf::Vector2i(event.mouseButton.x, event.mouseButton.y);\n        if (getRect1().getGlobalBounds().contains(static_cast&lt;sf::Vector2f&gt;(mousePos)))\n        {\n            activeInput = 0;\n        }\n        else if (getRect2().getGlobalBounds().contains(static_cast&lt;sf::Vector2f&gt;(mousePos)))\n        {\n            activeInput = 1;\n        }\n        else if (getRect3().getGlobalBounds().contains(static_cast&lt;sf::Vector2f&gt;(mousePos)))\n        {\n            activeInput = 2;\n        }\n        else if (getRect4().getGlobalBounds().contains(static_cast&lt;sf::Vector2f&gt;(mousePos)))\n        {\n            std::cout &lt;&lt; \"Button clicked\" &lt;&lt; std::endl;\n            getButtonSound().playSound(\"assets/audio/Effect/button.mp3\");\n            screenManager.switchToScreen(\"GameLobby\");\n            std::cout &lt;&lt; inputIp &lt;&lt; std::endl;\n            std::cout &lt;&lt; inputPort &lt;&lt; std::endl;\n            std::cout &lt;&lt; inputName &lt;&lt; std::endl;\n            // std::string server_ip = \"127.0.0.1\";\n            protocol::PlayerAction player_action = {1, 1, {0x04, 0x02}};\n            std::thread udp_thread(&amp;Client::send_udp_message, &amp;screenManager.client,\n                                   std::ref(player_action), inputIp, std::stoi(inputPort),\n                                   std::ref(inputName));\n            udp_thread.join();\n            event.type = sf::Event::Closed;\n        }\n    }\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/RoomLobby_8hpp/","title":"File RoomLobby.hpp","text":"<p>FileList &gt; Client &gt; RoomLobby.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../include/Engine/Audio/AudioManager.hpp\"</code></li> <li><code>#include \"../../include/Engine/Image/ImageManager.hpp\"</code></li> <li><code>#include \"../../include/Engine/Mouse/MouseManager.hpp\"</code></li> <li><code>#include \"../../include/Engine/Shape/ShapeManager.hpp\"</code></li> <li><code>#include \"GameLobby.hpp\"</code></li> <li><code>#include \"ScreenManager.hpp\"</code></li> <li><code>#include &lt;boost/asio.hpp&gt;</code></li> <li><code>#include &lt;boost/asio/ip/udp.hpp&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/RoomLobby_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace GameUI"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/RoomLobby_8hpp/#classes","title":"Classes","text":"Type Name class RoomLobby <p>The documentation for this class was generated from the following file <code>src/Client/RoomLobby.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/RoomLobby_8hpp_source/","title":"File RoomLobby.hpp","text":"<p>File List &gt; Client &gt; RoomLobby.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"../../include/Engine/Audio/AudioManager.hpp\"\n#include \"../../include/Engine/Image/ImageManager.hpp\"\n#include \"../../include/Engine/Mouse/MouseManager.hpp\"\n#include \"../../include/Engine/Shape/ShapeManager.hpp\"\n#include \"GameLobby.hpp\"\n#include \"ScreenManager.hpp\"\n#include &lt;boost/asio.hpp&gt;\n#include &lt;boost/asio/ip/udp.hpp&gt;\n#include &lt;thread&gt;\n\nusing boost::asio::ip::udp;\nnamespace GameUI\n{\n    class RoomLobby : public IScreen\n    {\n    private:\n        sf::Font font;\n        std::string input;\n        int activeInput;\n        ScreenManager &amp;screenManager;\n        ImageManager RoomLobbyImage, backgroundImage, backButtonImage;\n        AudioManager ButtonSound;\n        MouseManager mouse;\n        sf::RectangleShape rect1, rect2, rect3, rect4;\n        ShapeManager shapeManager1, shapeManager2, shapeManager3, shapeManager4;\n        // Client client;\n        void centerImage(ImageManager &amp;img, float windowWidth, float windowHeight);\n\n    public:\n        std::string inputIp;\n        std::string inputPort;\n        std::string inputName;\n        sf::Text textip, textport, textname;\n        RoomLobby(ScreenManager &amp;screenManager);\n        void render(sf::RenderWindow &amp;window) override;\n        void loadFont(const std::string &amp;fontPath);\n        void handleEvent(sf::Event &amp;event) override;\n        void update() override;\n\n        bool setBackButton(const std::string &amp;filePath, float windowWidth, float windowHeight);\n        bool setBackground(const std::string &amp;filePath, float windowWidth, float windowHeight);\n        bool setRoomLobby(const std::string &amp;filePath, float windowWidth, float windowHeight);\n\n        void drawRoomLobby(sf::RenderWindow &amp;window);\n        void drawBackground(sf::RenderWindow &amp;window);\n        void drawBackButton(sf::RenderWindow &amp;window);\n\n        const sf::Sprite &amp;getRoomLobbySprite() const;\n        const sf::Sprite &amp;getBackgroundSprite() const;\n        const sf::Sprite &amp;getBackButtonSprite() const;\n\n        void textfieldsetter(sf::Font &amp;font);\n        void shapebuilder(sf::RenderWindow &amp;window);\n\n        sf::Text &amp;getTextIp() { return textip; }\n        sf::Text &amp;getTextPort() { return textport; }\n        sf::Text &amp;getTextName() { return textname; }\n\n        sf::RectangleShape &amp;getRect1() { return rect1; }\n        sf::RectangleShape &amp;getRect2() { return rect2; }\n        sf::RectangleShape &amp;getRect3() { return rect3; }\n        sf::RectangleShape &amp;getRect4() { return rect4; }\n\n        AudioManager &amp;getButtonSound() { return ButtonSound; }\n        MouseManager &amp;getMouse() { return mouse; }\n    };\n} // namespace GameUI\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/ScreenManager_8cpp/","title":"File ScreenManager.cpp","text":"<p>FileList &gt; Client &gt; ScreenManager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ScreenManager.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Client/ScreenManager.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/ScreenManager_8cpp_source/","title":"File ScreenManager.cpp","text":"<p>File List &gt; Client &gt; ScreenManager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"ScreenManager.hpp\"\n\nGameUI::ScreenManager::ScreenManager(sf::RenderWindow &amp;window) : window(window)\n{\n}\n\nvoid GameUI::ScreenManager::switchToScreen(const std::string &amp;name)\n{\n    auto it = screens.find(name);\n    if (it != screens.end())\n    {\n        currentScreen = it-&gt;second();\n    }\n}\n\nvoid GameUI::ScreenManager::update()\n{\n    if (currentScreen)\n    {\n        currentScreen-&gt;update();\n    }\n}\n\nvoid GameUI::ScreenManager::render()\n{\n    if (currentScreen)\n    {\n        currentScreen-&gt;render(window);\n    }\n}\n\nvoid GameUI::ScreenManager::handleEvent(sf::Event &amp;event)\n{\n    if (currentScreen)\n    {\n        currentScreen-&gt;handleEvent(event);\n    }\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/ScreenManager_8hpp/","title":"File ScreenManager.hpp","text":"<p>FileList &gt; Client &gt; ScreenManager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include \"../../include/Engine/Animation/Animation.hpp\"</code></li> <li><code>#include \"../../include/Engine/Audio/AudioManager.hpp\"</code></li> <li><code>#include \"../../include/Engine/Image/ImageManager.hpp\"</code></li> <li><code>#include \"../../include/Engine/Mouse/MouseManager.hpp\"</code></li> <li><code>#include \"../../include/Engine/Shape/ShapeManager.hpp\"</code></li> <li><code>#include \"../../include/Server/Client.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/ScreenManager_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace GameUI"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/ScreenManager_8hpp/#classes","title":"Classes","text":"Type Name class ScreenManager class IScreen <p>The documentation for this class was generated from the following file <code>src/Client/ScreenManager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/ScreenManager_8hpp_source/","title":"File ScreenManager.hpp","text":"<p>File List &gt; Client &gt; ScreenManager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;unordered_map&gt;\n\n#include \"../../include/Engine/Animation/Animation.hpp\"\n#include \"../../include/Engine/Audio/AudioManager.hpp\"\n#include \"../../include/Engine/Image/ImageManager.hpp\"\n#include \"../../include/Engine/Mouse/MouseManager.hpp\"\n#include \"../../include/Engine/Shape/ShapeManager.hpp\"\n#include \"../../include/Server/Client.hpp\"\nclass IScreen\n{\npublic:\n    virtual void update() = 0;\n    virtual void render(sf::RenderWindow &amp;window) = 0;\n    virtual void handleEvent(sf::Event &amp;event) = 0;\n    virtual ~IScreen() = default;\n};\n\nnamespace GameUI\n{\n    class ScreenManager\n    {\n    public:\n        ScreenManager(sf::RenderWindow &amp;window);\n\n        template &lt;typename T&gt;\n        void addScreen(const std::string &amp;name, std::function&lt;std::unique_ptr&lt;T&gt;()&gt; factory)\n        {\n            screens[name] = [factory]() -&gt; std::unique_ptr&lt;IScreen&gt; { return factory(); };\n        }\n\n        void switchToScreen(const std::string &amp;name);\n        void update();\n        void render();\n        void handleEvent(sf::Event &amp;event);\n        Client client;\n\n    private:\n        sf::RenderWindow &amp;window;\n        std::unordered_map&lt;std::string, std::function&lt;std::unique_ptr&lt;IScreen&gt;()&gt;&gt; screens;\n        std::unique_ptr&lt;IScreen&gt; currentScreen;\n    };\n} // namespace GameUI\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Server_8cpp/","title":"File Server.cpp","text":"<p>FileList &gt; Server &gt; Server.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../include/Server/Server.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Server_8cpp/#public-functions","title":"Public Functions","text":"Type Name int main (int ac, char ** av)"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Server_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Server_8cpp/#function-main","title":"function main","text":"<pre><code>int main (\n    int ac,\n    char ** av\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Server/Server.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Server_8cpp_source/","title":"File Server.cpp","text":"<p>File List &gt; Server &gt; Server.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** server\n** File description:\n** Server\n*/\n\n#include \"../../include/Server/Server.hpp\"\n\nEntity &amp;Server::get_player_entity(const std::string &amp;player_name)\n{\n    for (auto &amp;entity : registry.get_entities(\"Player\"))\n    {\n        if (entity-&gt;name-&gt;name == player_name)\n        {\n            return *entity;\n        }\n    }\n    throw std::runtime_error(\"Player not found\");\n}\n\nServer::Server(boost::asio::io_context &amp;io_context, server_t server_me)\n    : room_system(), _game_time_manager(io_context, std::chrono::milliseconds(16))\n{\n    ThreadPool thread_pool(io_context, std::thread::hardware_concurrency());\n    std::thread udp_server_thread([this, &amp;io_context, server_me]()\n                                  { start_udp_server(io_context, server_me.udp_port); });\n    std::thread tcp_server_thread([this, &amp;io_context, server_me]()\n                                  { start_tcp_server(io_context, server_me.tcp_port); });\n    start_heartbeat_monitor(io_context);\n    udp_server_thread.join();\n    tcp_server_thread.join();\n    thread_pool.release();\n}\n\nServer::~Server()\n{\n}\n\nvoid Server::process_message(udp::socket &amp;socket, const std::vector&lt;uint8_t&gt; &amp;buffer,\n                             const udp::endpoint &amp;client_endpoint)\n{\n    process_message_contain(socket, buffer, client_endpoint);\n    check_player_message(socket, buffer, client_endpoint);\n}\n\nvoid Server::handle_tcp_connection(boost::asio::io_context &amp;io_context, tcp::socket socket)\n{\n    auto self = std::make_shared&lt;tcp::socket&gt;(std::move(socket));\n\n    auto recv_buffer = std::make_shared&lt;std::vector&lt;uint8_t&gt;&gt;(128);\n\n    self-&gt;async_read_some(\n        boost::asio::buffer(*recv_buffer),\n        [self, recv_buffer](boost::system::error_code ec, std::size_t length)\n        {\n            if (!ec)\n            {\n                std::string message(recv_buffer-&gt;begin(), recv_buffer-&gt;begin() + length);\n                std::cout &lt;&lt; \"Received TCP message: \" &lt;&lt; message &lt;&lt; std::endl;\n\n                std::string response = \"ACK\";\n                boost::asio::async_write(\n                    *self, boost::asio::buffer(response),\n                    [self](boost::system::error_code ec, std::size_t)\n                    {\n                        if (!ec)\n                        {\n                            std::cout &lt;&lt; \"Sent TCP acknowledgment\" &lt;&lt; std::endl;\n                        }\n                        else\n                        {\n                            std::cerr &lt;&lt; \"Error in sending TCP acknowledgment: \" &lt;&lt; ec.message()\n                                      &lt;&lt; std::endl;\n                        }\n                    });\n            }\n            else\n            {\n                std::cerr &lt;&lt; \"Error in reading TCP message: \" &lt;&lt; ec.message() &lt;&lt; std::endl;\n            }\n        });\n}\n\nvoid Server::start_tcp_server(boost::asio::io_context &amp;io_context, int port)\n{\n    boost::asio::ip::tcp::acceptor acceptor(\n        io_context, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port));\n    std::cout &lt;&lt; \"Server is listening on port: \" &lt;&lt; port &lt;&lt; std::endl;\n\n    boost::asio::ip::tcp::socket socket(io_context);\n    acceptor.accept(socket);\n    std::cout &lt;&lt; \"Accepted a connection!\" &lt;&lt; std::endl;\n}\n\nvoid Server::start_udp_server(boost::asio::io_context &amp;io_context, int port)\n{\n    try\n    {\n        udp::socket udp_socket(io_context, udp::endpoint(udp::v4(), port));\n        std::cout &lt;&lt; \"UDP server started on port \" &lt;&lt; port &lt;&lt; std::endl;\n        std::array&lt;uint8_t, 128&gt; recv_buffer;\n        udp::endpoint remote_endpoint;\n        boost::system::error_code error;\n        size_t len = 0;\n        do\n        {\n            len = udp_socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint, 0,\n                                          error);\n            if (!error &amp;&amp; len &gt; 0)\n            {\n                std::cout &lt;&lt; \"First client connected from: \" &lt;&lt; remote_endpoint &lt;&lt; std::endl;\n                _connected_clients.push_back(remote_endpoint);\n            }\n        } while (error == boost::asio::error::would_block || len == 0);\n        udp_socket.non_blocking(true);\n        while (true)\n        {\n            auto enemies = registry.get_entities(\"Enemy\");\n            len = udp_socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint, 0,\n                                          error);\n            if (std::find(_connected_clients.begin(), _connected_clients.end(), remote_endpoint) ==\n                _connected_clients.end())\n            {\n                _connected_clients.push_back(remote_endpoint);\n                std::cout &lt;&lt; \"New client connected: \" &lt;&lt; remote_endpoint &lt;&lt; std::endl;\n            }\n            if (error == boost::asio::error::would_block)\n            {\n                if (game_run)\n                {\n                    if (enemyTimer.getElapsedTimeInSeconds() &gt; 7)\n                    {\n                        std::cout &lt;&lt; \"Spawning enemy\" &lt;&lt; std::endl;\n                        Vector2D pos = registry.spawn_enemy();\n                        std::vector&lt;uint16_t&gt; response = {0x04, enemy_count++,\n                                                          static_cast&lt;uint16_t&gt;(pos.x),\n                                                          static_cast&lt;uint16_t&gt;(pos.y)};\n                        for (auto client : _connected_clients)\n                        {\n                            udp_socket.send_to(boost::asio::buffer(response), client);\n                        }\n                        registry.entity_update();\n                        enemyTimer.restart();\n                    }\n                    if (shootTimer.getElapsedTimeInSeconds() &gt; 5)\n                    {\n                        std::string name = get_player_name(remote_endpoint);\n                        Vector2D pos = shoot.spawn_projectile(registry, get_player_entity(name));\n                        std::vector&lt;uint16_t&gt; response = {0x08, projectile_count++,\n                                                          static_cast&lt;uint16_t&gt;(pos.x),\n                                                          static_cast&lt;uint16_t&gt;(pos.y)};\n                        for (auto client : _connected_clients)\n                        {\n                            udp_socket.send_to(boost::asio::buffer(response), client);\n                        }\n                        registry.entity_update();\n                        shootTimer.restart();\n                    }\n                    if (coinTimer.getElapsedTimeInSeconds() &gt; 7)\n                    {\n                        registry.spawn_coin();\n                        std::vector&lt;uint16_t&gt; response = {0x010, coin_count++};\n                        coinTimer.restart();\n                    }\n                    for (int i = 0; i &lt; enemies.size(); i++)\n                    {\n                        if (!enemies[i]-&gt;_alive || enemies[i]-&gt;transform-&gt;position.x &lt; 0)\n                        {\n                            std::vector&lt;uint16_t&gt; remove_response = {0x09,\n                                                                     static_cast&lt;uint16_t&gt;(i)};\n                            for (auto &amp;client : _connected_clients)\n                            {\n                                udp_socket.send_to(boost::asio::buffer(remove_response), client);\n                            }\n                            enemies[i]-&gt;_alive = false;\n                            registry.entity_update();\n                            std::cout &lt;&lt; \"Enemy \" &lt;&lt; i &lt;&lt; \" died.\" &lt;&lt; std::endl;\n                        }\n                    }\n                    for (auto player : registry.get_entities(\"Player\"))\n                    {\n                        if (player-&gt;health-&gt;currentHealth &lt;= 0)\n                        {\n                            player-&gt;_alive = false;\n                            int id = get_player_id(remote_endpoint);\n                            std::vector&lt;uint16_t&gt; remove_response = {0x011,\n                                                                     static_cast&lt;uint16_t&gt;(id)};\n                            for (auto &amp;client : _connected_clients)\n                            {\n                                udp_socket.send_to(boost::asio::buffer(remove_response), client);\n                            }\n\n                            std::cout &lt;&lt; \"Game over.\" &lt;&lt; std::endl;\n                        }\n                    }\n                    if (updateTimer.getElapsedTimeInSeconds() &gt; 0.5)\n                    {\n                        for (int i = 0; i &lt; enemies.size(); i++)\n                        {\n                            if (enemies[i] == nullptr || !enemies[i]-&gt;_alive)\n                            {\n                                continue;\n                            }\n                            enemies[i]-&gt;transform-&gt;position.x -= 30;\n                            if (enemies[i]-&gt;transform-&gt;position.x &lt;= 2)\n                            {\n                                std::vector&lt;uint16_t&gt; remove_response = {0x09,\n                                                                         static_cast&lt;uint16_t&gt;(i)};\n                                for (auto client : _connected_clients)\n                                {\n                                    udp_socket.send_to(boost::asio::buffer(remove_response),\n                                                       client);\n                                }\n                                enemies[i]-&gt;_alive = false;\n                                registry.entity_update();\n                            }\n                            else\n                            {\n                                std::vector&lt;uint16_t&gt; update_response = {\n                                    0x04, static_cast&lt;uint16_t&gt;(i),\n                                    static_cast&lt;uint16_t&gt;(enemies[i]-&gt;transform-&gt;position.x),\n                                    static_cast&lt;uint16_t&gt;(enemies[i]-&gt;transform-&gt;position.y)};\n                                std::cout &lt;&lt; \"Enemy \" &lt;&lt; i &lt;&lt; \" position: (\"\n                                          &lt;&lt; enemies[i]-&gt;transform-&gt;position.x &lt;&lt; \", \"\n                                          &lt;&lt; enemies[i]-&gt;transform-&gt;position.y &lt;&lt; \")\" &lt;&lt; std::endl;\n                                for (auto client : _connected_clients)\n                                {\n                                    udp_socket.send_to(boost::asio::buffer(update_response),\n                                                       client);\n                                }\n                            }\n                        }\n                        auto projectiles = registry.get_entities(\"Projectile\");\n                        for (int i = 0; i &lt; projectiles.size(); i++)\n                        {\n                            projectiles[i]-&gt;transform-&gt;position.x += 40;\n                            if (projectiles[i]-&gt;transform-&gt;position.x &gt;= 1366)\n                            {\n                                projectiles[i]-&gt;_alive = false;\n                                registry.entity_update();\n                            }\n                            else\n                            {\n                                std::vector&lt;uint16_t&gt; update_response = {\n                                    0x08, static_cast&lt;uint16_t&gt;(i),\n                                    static_cast&lt;uint16_t&gt;(projectiles[i]-&gt;transform-&gt;position.x),\n                                    static_cast&lt;uint16_t&gt;(projectiles[i]-&gt;transform-&gt;position.y)};\n                                for (auto client : _connected_clients)\n                                {\n                                    udp_socket.send_to(boost::asio::buffer(update_response),\n                                                       client);\n                                }\n                            }\n                        }\n                        for (auto player : registry.get_entities(\"Player\"))\n                        {\n                            u_int16_t health = player-&gt;health-&gt;currentHealth;\n                            u_int16_t score = player-&gt;score-&gt;getScore();\n                            int id = get_player_id(remote_endpoint);\n                            std::vector&lt;uint16_t&gt; update_response = {0x07, health, score};\n                            // if (player-&gt;health-&gt;currentHealth &lt;= 0)\n                            // {\n                            //     std::vector&lt;uint16_t&gt; remove_response = {0x011,\n                            //                                              static_cast&lt;uint16_t&gt;(id)};\n                            //     for (auto client : _connected_clients)\n                            //     {\n                            //         udp_socket.send_to(boost::asio::buffer(remove_response),\n                            //                            client);\n                            //     }\n                            // }\n                            for (auto client : _connected_clients)\n                            {\n                                udp_socket.send_to(boost::asio::buffer(update_response), client);\n                            }\n                        }\n                        updateTimer.restart();\n                    }\n                }\n                continue;\n            }\n            else if (error &amp;&amp; error != boost::asio::error::message_size)\n            {\n                std::cerr &lt;&lt; \"UDP Receive error: \" &lt;&lt; error.message() &lt;&lt; std::endl;\n                break;\n            }\n            if (len &gt; 0)\n            {\n                std::vector&lt;uint8_t&gt; data(recv_buffer.begin(), recv_buffer.begin() + len);\n                std::thread process_thread([this, &amp;udp_socket, data, remote_endpoint]()\n                                           { process_message(udp_socket, data, remote_endpoint); });\n                process_thread.detach();\n            }\n            movement.system_movement(registry.get_entities());\n            collision.collision_player_enemy(registry);\n            collision.collision_enemy_projectiles(registry);\n            registry.entity_update();\n            handle_client_ping(remote_endpoint);\n            std::string response = \"ACK\";\n            udp_socket.send_to(boost::asio::buffer(response), remote_endpoint);\n            std::cout &lt;&lt; \"Sent UDP acknowledgment to \" &lt;&lt; remote_endpoint &lt;&lt; std::endl;\n        }\n    }\n    catch (const std::exception &amp;e)\n    {\n        std::cerr &lt;&lt; \"UDP Exception: \" &lt;&lt; e.what() &lt;&lt; \"\\n\";\n    }\n}\n\nint main(int ac, char **av)\n{\n    server_t server_me;\n    if (recup_args(&amp;server_me, ac, av) == false)\n    {\n        return (84);\n    }\n    try\n    {\n        boost::asio::io_context io_context;\n        Server server(io_context, server_me);\n        io_context.run();\n    }\n    catch (std::exception &amp;e)\n    {\n        std::cerr &lt;&lt; \"Server Exception: \" &lt;&lt; e.what() &lt;&lt; \"\\n\";\n    }\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Server_8hpp/","title":"File Server.hpp","text":"<p>FileList &gt; include &gt; Server &gt; Server.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;boost/asio.hpp&gt;</code></li> <li><code>#include &lt;boost/bind/bind.hpp&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"Coin_system.hpp\"</code></li> <li><code>#include \"Collision_system.hpp\"</code></li> <li><code>#include \"Entity.hpp\"</code></li> <li><code>#include \"Health_system.hpp\"</code></li> <li><code>#include \"Mouvement_system.hpp\"</code></li> <li><code>#include \"Shoot_system.hpp\"</code></li> <li><code>#include \"ThreadPool.hpp\"</code></li> <li><code>#include \"Time_manager.hpp\"</code></li> <li><code>#include \"protocol.hpp\"</code></li> <li><code>#include \"room_system.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Server_8hpp/#classes","title":"Classes","text":"Type Name struct EndpointEqual Comparator for UDP endpoints. struct EndpointHash Hash function for UDP endpoints. class Server A class representing the server managing TCP/UDP connections and game state. struct parameter_t Structure representing a command-line parameter. struct server_me_t Struct representing the server configuration."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Server_8hpp/#public-types","title":"Public Types","text":"Type Name typedef struct server_me_t server_t Struct representing the server configuration."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Server_8hpp/#public-functions","title":"Public Functions","text":"Type Name bool recup_args (server_t * server, int ac, char ** av)"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Server_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Server_8hpp/#typedef-server_t","title":"typedef server_t","text":"<p>Struct representing the server configuration. <pre><code>typedef struct server_me_t server_t;\n</code></pre></p> <p>This structure holds the port numbers for both TCP and UDP communication. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Server_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Server_8hpp/#function-recup_args","title":"function recup_args","text":"<pre><code>bool recup_args (\n    server_t * server,\n    int ac,\n    char ** av\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Server/Server.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Server_8hpp_source/","title":"File Server.hpp","text":"<p>File List &gt; include &gt; Server &gt; Server.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** SERVER\n** File description:\n** Server\n*/\n\n#ifndef SERVER_HPP_\n#define SERVER_HPP_\n#include &lt;array&gt;\n#include &lt;boost/asio.hpp&gt;\n#include &lt;boost/bind/bind.hpp&gt;\n#include &lt;chrono&gt;\n#include &lt;cstring&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;string_view&gt;\n#include &lt;thread&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\n#include \"Coin_system.hpp\"\n#include \"Collision_system.hpp\"\n#include \"Entity.hpp\"\n#include \"Health_system.hpp\"\n#include \"Mouvement_system.hpp\"\n#include \"Shoot_system.hpp\"\n#include \"ThreadPool.hpp\"\n#include \"Time_manager.hpp\"\n#include \"protocol.hpp\"\n#include \"room_system.hpp\"\n\nusing boost::asio::ip::tcp;\nusing boost::asio::ip::udp;\n\ntypedef struct server_me_t\n{\n    int tcp_port; \n    int udp_port; \n} server_t;\n\nstruct parameter_t\n{\n    std::string argument; \n    std::function&lt;bool(int *, char **)&gt; add_new_param; \n    std::string name;  \n    std::string usage; \n    int check_me;      \n};\n\nstruct EndpointHash\n{\n    std::size_t operator()(const boost::asio::ip::udp::endpoint &amp;endpoint) const\n    {\n        return std::hash&lt;std::string&gt;()(endpoint.address().to_string() + \":\" +\n                                        std::to_string(endpoint.port()));\n    }\n};\n\nstruct EndpointEqual\n{\n    bool operator()(const boost::asio::ip::udp::endpoint &amp;lhs,\n                    const boost::asio::ip::udp::endpoint &amp;rhs) const\n    {\n        return lhs.address() == rhs.address() &amp;&amp; lhs.port() == rhs.port();\n    }\n};\n\nclass Server\n{\npublic:\n    Server(boost::asio::io_context &amp;io_context, server_t server_me);\n\n    ~Server();\n\n    void process_message(udp::socket &amp;socket, const std::vector&lt;uint8_t&gt; &amp;buffer,\n                         const udp::endpoint &amp;client_endpoint);\n\n    void process_message_contain(udp::socket &amp;socket, const std::vector&lt;uint8_t&gt; &amp;buffer,\n                                 const udp::endpoint &amp;client_endpoint);\n\n    void notify_clients_of_disconnection(boost::asio::io_context &amp;io_context,\n                                         const udp::endpoint &amp;disconnected_client);\n\n    void check_player_message(udp::socket &amp;socket, const std::vector&lt;uint8_t&gt; &amp;buffer,\n                              const udp::endpoint &amp;client_endpoint);\n\n    void start_udp_server(boost::asio::io_context &amp;io_context, int port);\n\n    void handle_tcp_connection(boost::asio::io_context &amp;io_context, tcp::socket socket);\n\n    void start_tcp_server(boost::asio::io_context &amp;io_context, int port);\n\n    void start_heartbeat_monitor(boost::asio::io_context &amp;io_context);\n\n    void handle_client_ping(const udp::endpoint &amp;client_endpoint);\n\n    void send_udp_with_ack(udp::socket &amp;socket, const std::vector&lt;uint8_t&gt; &amp;message,\n                           const udp::endpoint &amp;client_endpoint);\n\n    void handle_room_creation(udp::socket &amp;socket, const std::string &amp;room_name,\n                              const udp::endpoint &amp;client_endpoint);\n\n    void handle_room_joining(udp::socket &amp;socket, int room_id,\n                             const udp::endpoint &amp;client_endpoint);\n\n    void handle_list_rooms(udp::socket &amp;socket, const udp::endpoint &amp;client_endpoint);\n\n    void run_game();\n\n    std::vector&lt;std::pair&lt;udp::endpoint, std::string&gt;&gt;\n        id_name; \n    boost::asio::steady_timer _game_time_manager;  \n    Registry registry;                             \n    MouvementSystem movement;                      \n    TimeManager enemyTimer;                        \n    TimeManager updateTimer;                       \n    CollisionSystem collision;                     \n    TimeManager shootTimer;                        \n    ShootSystem shoot;                             \n    TimeManager coinTimer;                         \n    bool game_run = false;                         \n    u_int16_t players_count = 0;                   \n    u_int16_t enemy_count = 0;                     \n    u_int16_t projectile_count = 0;                \n    u_int16_t coin_count = 0;                      \n    std::vector&lt;udp::endpoint&gt; _connected_clients; \n    std::string _name;                             \n\n    int get_player_id(const udp::endpoint &amp;client_endpoint);\n\n    std::string get_player_name(const udp::endpoint &amp;client_endpoint);\n\n    void check_player_position(udp::socket &amp;socket, const std::vector&lt;uint8_t&gt; &amp;buffer,\n                               const udp::endpoint &amp;client_endpoint);\n\n    Entity &amp;get_player_entity(const std::string &amp;player_name);\n\nprotected:\nprivate:\n    struct ClientInfo\n    {\n        std::chrono::steady_clock::time_point last_ping; \n    };\n\n    std::unordered_map&lt;udp::endpoint, ClientInfo, EndpointHash, EndpointEqual&gt;\n        clients_me; \n    std::unordered_map&lt;udp::endpoint, std::string, EndpointHash, EndpointEqual&gt;\n        clients;             \n    Room_System room_system; \n};\n\nbool recup_args(server_t *server, int ac, char **av);\n\n#endif /* !SERVER_HPP_ */\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/SettingGame_8cpp/","title":"File SettingGame.cpp","text":"<p>FileList &gt; Client &gt; Save &gt; SettingGame.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Menu.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Client/Save/SettingGame.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/SettingGame_8cpp_source/","title":"File SettingGame.cpp","text":"<p>File List &gt; Client &gt; Save &gt; SettingGame.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Menu.hpp\"\n\nvoid Menu::loadVolumeImages()\n{\n    for (int i = 10; i &lt;= 100; i += 10)\n    {\n        sf::Texture texture;\n        if (texture.loadFromFile(\"assets/image/Element/Volume/\" + std::to_string(i) + \".png\"))\n        {\n            volumeTextures.push_back(texture);\n        }\n        else\n        {\n            std::cerr &lt;&lt; \"Error loading volume image for \" &lt;&lt; i &lt;&lt; std::endl;\n        }\n    }\n}\n\nvoid Menu::loadResolutionImages()\n{\n    std::vector&lt;sf::Vector2u&gt; availableResolutions = {{BASE_WIDTH, BASE_HEIGHT}};\n\n    for (const auto &amp;res : availableResolutions)\n    {\n        sf::Texture texture;\n        std::string resolutionStr = std::to_string(res.x) + \"_\" + std::to_string(res.y);\n        if (texture.loadFromFile(\"assets/image/Element/Screen/\" + resolutionStr + \".png\"))\n        {\n            resolutionTextures.push_back(texture);\n        }\n        else\n        {\n            std::cerr &lt;&lt; \"Error: Unable to load resolution image \" &lt;&lt; resolutionStr &lt;&lt; std::endl;\n        }\n    }\n}\n\nvoid Menu::updateResolutionImage()\n{\n    if (currentResolutionIndex &gt;= 0 &amp;&amp; currentResolutionIndex &lt; resolutionTextures.size())\n    {\n        resolutionSprite.setTexture(resolutionTextures[currentResolutionIndex]);\n        resolutionSprite.setPosition(1200, 650);\n        resolutionSprite.setScale(1.0f, 1.0f);\n    }\n}\n\nvoid Menu::updateVolumeImage()\n{\n    int index = volumeLevel / 10 - 1;\n    if (index &gt;= 0 &amp;&amp; index &lt; volumeTextures.size())\n    {\n        volumeSprite.setTexture(volumeTextures[index]);\n        volumeSprite.setPosition(1320, 250);\n        volumeSprite.setScale(1.0f, 1.0f);\n    }\n}\n\nvoid Menu::openSettings()\n{\n    bool settingsOpen = true;\n    while (settingsOpen &amp;&amp; window.isOpen())\n    {\n        settingsOpen = handleSettingsEvents();\n        renderSettings();\n    }\n}\n\nbool Menu::handleSettingsEvents()\n{\n    sf::Event event;\n    while (window.pollEvent(event))\n    {\n        if (event.type == sf::Event::Closed)\n        {\n            window.close();\n            return false;\n        }\n        if (event.type == sf::Event::KeyPressed &amp;&amp; event.key.code == sf::Keyboard::Escape)\n        {\n            return false;\n        }\n        if (event.type == sf::Event::MouseButtonPressed &amp;&amp;\n            event.mouseButton.button == sf::Mouse::Left)\n        {\n            handleSettingsClicks(event);\n        }\n    }\n    return true;\n}\n\nvoid Menu::handleSettingsClicks(const sf::Event &amp;event)\n{\n    float mouseX = static_cast&lt;float&gt;(event.mouseButton.x);\n    float mouseY = static_cast&lt;float&gt;(event.mouseButton.y);\n\n    handleVolumeClicks(mouseX, mouseY);\n    handleSoundToggleClicks(mouseX, mouseY);\n    handleResolutionClicks(mouseX, mouseY);\n    handleNavigationClicks(mouseX, mouseY);\n}\n\nvoid Menu::handleVolumeClicks(float mouseX, float mouseY)\n{\n    if (moinsButton.getGlobalBounds().contains(mouseX, mouseY))\n    {\n        decreaseVolume();\n    }\n    if (plusButton.getGlobalBounds().contains(mouseX, mouseY))\n    {\n        increaseVolume();\n    }\n}\n\nvoid Menu::decreaseVolume()\n{\n    if (volumeLevel &gt; 0)\n    {\n        volumeLevel -= 10;\n        music.setVolume(volumeLevel);\n        updateVolumeImage();\n    }\n}\n\nvoid Menu::increaseVolume()\n{\n    if (volumeLevel &lt; 100)\n    {\n        volumeLevel += 10;\n        music.setVolume(volumeLevel);\n        updateVolumeImage();\n    }\n}\n\nvoid Menu::handleSoundToggleClicks(float mouseX, float mouseY)\n{\n    if (infButton.getGlobalBounds().contains(mouseX, mouseY))\n    {\n        isSoundOn = false;\n        music.pause();\n    }\n    if (supButton.getGlobalBounds().contains(mouseX, mouseY))\n    {\n        isSoundOn = true;\n        music.play();\n    }\n}\n\nvoid Menu::handleResolutionClicks(float mouseX, float mouseY)\n{\n    if (screen_infButton.getGlobalBounds().contains(mouseX, mouseY))\n    {\n        decreaseResolution();\n    }\n    if (screen_supButton.getGlobalBounds().contains(mouseX, mouseY))\n    {\n        increaseResolution();\n    }\n}\n\nvoid Menu::decreaseResolution()\n{\n    if (currentResolutionIndex &gt; 0)\n    {\n        currentResolutionIndex--;\n        updateResolutionImage();\n    }\n}\n\nvoid Menu::increaseResolution()\n{\n    if (currentResolutionIndex &lt; resolutions.size() - 1)\n    {\n        currentResolutionIndex++;\n        updateResolutionImage();\n    }\n}\n\nvoid Menu::handleNavigationClicks(float mouseX, float mouseY)\n{\n    if (goBackButtonImage.getGlobalBounds().contains(mouseX, mouseY))\n    {\n        std::cout &lt;&lt; \"Go back button clicked\" &lt;&lt; std::endl;\n        settingsOpen = false;\n    }\n    if (applyChangesButtonImage.getGlobalBounds().contains(mouseX, mouseY))\n    {\n        std::cout &lt;&lt; \"Apply changes button clicked\" &lt;&lt; std::endl;\n        applyChanges();\n    }\n}\n\nvoid Menu::renderSettings()\n{\n    window.clear(sf::Color::Black);\n    drawSettingsBackground();\n    drawSettingsElements();\n    window.display();\n}\n\nvoid Menu::drawSettingsBackground()\n{\n    backgroundImage.draw(window);\n}\n\nvoid Menu::drawSettingsElements()\n{\n    setVolumeImage.draw(window);\n    soundImage.draw(window);\n    screenResolutionImage.draw(window);\n    goBackButtonImage.draw(window);\n    applyChangesButtonImage.draw(window);\n    plusButton.draw(window);\n    moinsButton.draw(window);\n    window.draw(volumeSprite);\n    drawSoundToggle();\n    infButton.draw(window);\n    supButton.draw(window);\n    screen_infButton.draw(window);\n    screen_supButton.draw(window);\n    window.draw(resolutionSprite);\n}\n\nvoid Menu::drawSoundToggle()\n{\n    if (isSoundOn)\n    {\n        onImage.draw(window);\n    }\n    else\n    {\n        offImage.draw(window);\n    }\n}\n\nvoid Menu::applyChanges()\n{\n    sf::Vector2u selectedResolution = resolutions[currentResolutionIndex];\n    window.create(sf::VideoMode(selectedResolution.x, selectedResolution.y), \"Game Menu\");\n    updateElementPositions(selectedResolution);\n}\n\nvoid Menu::updateElementPositions(const sf::Vector2u &amp;newResolution)\n{\n    float scaleX = static_cast&lt;float&gt;(newResolution.x) / BASE_WIDTH;\n    float scaleY = static_cast&lt;float&gt;(newResolution.y) / BASE_HEIGHT;\n\n    // updateElementPosition(backgroundImage, 0, 0, scaleX, scaleY);\n    // centerImage(titleImage, newResolution.x, newResolution.y);\n    // updateElementPosition(titleImage, 700, 200, 1.5f * scaleX, 1.5f * scaleY);\n    // updateElementPosition(startButtonImage, 860, 600, scaleX, scaleY);\n    // updateElementPosition(settingsButtonImage, 860, 770, scaleX, scaleY);\n\n    updateElementPosition(goBackButtonImage, 100, 900, scaleX, scaleY);\n    updateElementPosition(applyChangesButtonImage, 1320, 900, scaleX, scaleY);\n    updateElementPosition(setVolumeImage, 250, 250, scaleX, scaleY);\n    updateElementPosition(moinsButton, 900, 200, scaleX, scaleY);\n    updateElementPosition(plusButton, 1700, 250, scaleX, scaleY);\n    updateElementPosition(soundImage, 250, 450, scaleX, scaleY);\n    updateElementPosition(onImage, 1300, 450, scaleX, scaleY);\n    updateElementPosition(offImage, 1300, 450, scaleX, scaleY);\n    updateElementPosition(infButton, 900, 450, scaleX, scaleY);\n    updateElementPosition(supButton, 1700, 450, scaleX, scaleY);\n    updateElementPosition(screenResolutionImage, 250, 650, scaleX, scaleY);\n    updateElementPosition(screen_infButton, 900, 650, scaleX, scaleY);\n    updateElementPosition(screen_supButton, 1700, 650, scaleX, scaleY);\n}\n\nvoid Menu::updateElementPosition(ImageManager &amp;element, float x, float y, float scaleX,\n                                 float scaleY)\n{\n    element.setPosition(x * scaleX, y * scaleY);\n    element.setScale(scaleX, scaleY);\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/ShapeManager_8cpp/","title":"File ShapeManager.cpp","text":"<p>FileList &gt; Engine &gt; Shape &gt; ShapeManager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../../include/Engine/Shape/ShapeManager.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Engine/Shape/ShapeManager.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/ShapeManager_8cpp_source/","title":"File ShapeManager.cpp","text":"<p>File List &gt; Engine &gt; Shape &gt; ShapeManager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"../../../include/Engine/Shape/ShapeManager.hpp\"\n\nShapeManager::ShapeManager()\n{\n}\n\nShapeManager::~ShapeManager()\n{\n}\n\nsf::RectangleShape ShapeManager::drawRectangle(sf::RenderWindow &amp;window, float x, float y,\n                                               float width, float height, sf::Color color,\n                                               float outlineThickness, bool drawState)\n{\n    sf::RectangleShape rectangle(sf::Vector2f(width, height));\n\n    rectangle.setPosition(x, y);\n\n    rectangle.setFillColor(color);\n\n    rectangle.setOutlineThickness(outlineThickness);\n\n    if (drawState)\n        window.draw(rectangle);\n\n    return rectangle;\n}\n\nvoid ShapeManager::drawCircle(sf::RenderWindow &amp;window, float x, float y, float radius,\n                              const sf::Color &amp;color, float thickness = 1)\n{\n    sf::CircleShape circle(radius);\n    circle.setPosition(x, y);\n    circle.setFillColor(color);\n    circle.setOutlineThickness(thickness);\n    window.draw(circle);\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/ShapeManager_8hpp/","title":"File ShapeManager.hpp","text":"<p>FileList &gt; Engine &gt; Shape &gt; ShapeManager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/ShapeManager_8hpp/#classes","title":"Classes","text":"Type Name class ShapeManager Manages and renders geometric shapes using the SFML graphics library. <p>The documentation for this class was generated from the following file <code>include/Engine/Shape/ShapeManager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/ShapeManager_8hpp_source/","title":"File ShapeManager.hpp","text":"<p>File List &gt; Engine &gt; Shape &gt; ShapeManager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef SHAPEMANAGER_HPP\n#define SHAPEMANAGER_HPP\n\n#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;iostream&gt;\n\nclass ShapeManager\n{\npublic:\n    ShapeManager();\n\n    ~ShapeManager();\n\n    sf::RectangleShape drawRectangle(sf::RenderWindow &amp;window, float x, float y, float width,\n                                     float height, sf::Color color, float outlineThickness,\n                                     bool drawState = false);\n\n    void drawCircle(sf::RenderWindow &amp;window, float x, float y, float radius,\n                    const sf::Color &amp;color, float thickness);\n\nprivate:\n    // Private data members for managing internal state could be added here.\n};\n\n#endif // SHAPEMANAGER_HPP\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Shoot__system_8cpp/","title":"File Shoot_system.cpp","text":"<p>FileList &gt; Server &gt; Shoot_system.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../include/Server/Shoot_system.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Server/Shoot_system.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Shoot__system_8cpp_source/","title":"File Shoot_system.cpp","text":"<p>File List &gt; Server &gt; Shoot_system.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** game_logic\n** File description:\n** Shoot_system.cpp\n*/\n\n#include \"../../include/Server/Shoot_system.hpp\"\n\nVector2D ShootSystem::spawn_projectile(Registry &amp;registry, Entity &amp;player)\n{\n    auto proj = registry.add_entity(\"Projectile\");\n    proj-&gt;transform = std::make_unique&lt;Transform&gt;(Vector2D(200, 200), Vector2D(0.05f, 0));\n    proj-&gt;bbox = std::make_unique&lt;BBox&gt;(Vector2D(50, 50));\n    proj-&gt;transform-&gt;position.y = player.transform-&gt;position.y + (player.bbox-&gt;size.y / 2);\n    proj-&gt;transform-&gt;position.x = player.transform-&gt;position.x + (player.bbox-&gt;size.x / 2);\n    registry.entity_update();\n    std::cout &lt;&lt; \"Projectile spawned at: (\" &lt;&lt; proj-&gt;transform-&gt;position.x &lt;&lt; \", \"\n              &lt;&lt; proj-&gt;transform-&gt;position.y &lt;&lt; \")\" &lt;&lt; std::endl;\n    return proj-&gt;transform-&gt;position;\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Shoot__system_8hpp/","title":"File Shoot_system.hpp","text":"<p>FileList &gt; include &gt; Server &gt; Shoot_system.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Entity.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Shoot__system_8hpp/#classes","title":"Classes","text":"Type Name class ShootSystem &lt; Includes the Entity class for representing game entities. <p>The documentation for this class was generated from the following file <code>include/Server/Shoot_system.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Shoot__system_8hpp_source/","title":"File Shoot_system.hpp","text":"<p>File List &gt; include &gt; Server &gt; Shoot_system.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** game_logic\n** File description:\n** Shoot_system.hpp\n*/\n#ifndef SHOOT_SYSTEM_HPP\n#define SHOOT_SYSTEM_HPP\n#include \"Entity.hpp\" \n\nclass ShootSystem\n{\npublic:\n    Vector2D spawn_projectile(Registry &amp;registry, Entity &amp;player);\n};\n#endif // SHOOT_SYSTEM_HPP_\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/ThreadPool_8hpp/","title":"File ThreadPool.hpp","text":"<p>FileList &gt; include &gt; Server &gt; ThreadPool.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/asio.hpp&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/ThreadPool_8hpp/#classes","title":"Classes","text":"Type Name class ThreadPool A class representing a thread pool for managing asynchronous tasks. <p>The documentation for this class was generated from the following file <code>include/Server/ThreadPool.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/ThreadPool_8hpp_source/","title":"File ThreadPool.hpp","text":"<p>File List &gt; include &gt; Server &gt; ThreadPool.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** threadpool\n** File description:\n** ThreadPool\n*/\n\n#ifndef THREADPOOL_HPP_\n#define THREADPOOL_HPP_\n#include &lt;boost/asio.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nclass ThreadPool\n{\npublic:\n    ThreadPool(boost::asio::io_context &amp;io_context, std::size_t num_threads)\n        : io_context(io_context)\n    {\n        add_threads(num_threads);\n    }\n\n    ~ThreadPool() { release(); }\n\n    void add_threads(std::size_t num_threads)\n    {\n        for (std::size_t i = 0; i &lt; num_threads; ++i)\n        {\n            thread_pool.emplace_back([this]() { io_context.run(); });\n        }\n    }\n\n    void remove_threads(std::size_t num_threads)\n    {\n        for (std::size_t i = 0; i &lt; num_threads &amp;&amp; !thread_pool.empty(); ++i)\n        {\n            if (thread_pool.back().joinable())\n            {\n                thread_pool.back().join();\n            }\n            thread_pool.pop_back();\n        }\n    }\n\n    void release()\n    {\n        io_context.stop();\n        for (auto &amp;thread : thread_pool)\n        {\n            if (thread.joinable())\n            {\n                thread.join();\n            }\n        }\n        thread_pool.clear();\n    }\n\nprotected:\nprivate:\n    std::vector&lt;std::thread&gt; thread_pool; \n    boost::asio::io_context\n        &amp;io_context; \n};\n\n#endif /* !THREADPOOL_HPP_ */\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Time__manager_8cpp/","title":"File Time_manager.cpp","text":"<p>FileList &gt; Server &gt; Time_manager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../include/Server/Time_manager.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Server/Time_manager.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Time__manager_8cpp_source/","title":"File Time_manager.cpp","text":"<p>File List &gt; Server &gt; Time_manager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** game_logic\n** File description:\n** Time_manager.cpp\n*/\n\n#include \"../../include/Server/Time_manager.hpp\"\n\nvoid TimeManager::restart()\n{\n    start = std::chrono::steady_clock::now();\n}\n\nfloat TimeManager::getElapsedTimeInSeconds() const\n{\n    auto now = std::chrono::steady_clock::now();\n    std::chrono::duration&lt;float&gt; elapsed = now - start;\n    return elapsed.count();\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Time__manager_8hpp/","title":"File Time_manager.hpp","text":"<p>FileList &gt; include &gt; Server &gt; Time_manager.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include \"Entity.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Time__manager_8hpp/#classes","title":"Classes","text":"Type Name class TimeManager A class to manage time tracking for elapsed time measurements. <p>The documentation for this class was generated from the following file <code>include/Server/Time_manager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Time__manager_8hpp_source/","title":"File Time_manager.hpp","text":"<p>File List &gt; include &gt; Server &gt; Time_manager.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** game_logic\n** File description:\n** Time_manager.hpp\n*/\n\n#ifndef TIME_MANAGER_HPP_\n#define TIME_MANAGER_HPP_\n#include &lt;chrono&gt;\n\n#include \"Entity.hpp\"\n\nclass TimeManager\n{\nprivate:\n    std::chrono::steady_clock::time_point start; \n\npublic:\n    TimeManager() : start(std::chrono::steady_clock::now()) {}\n\n    void restart();\n\n    float getElapsedTimeInSeconds() const;\n};\n\n#endif // TIME_MANAGER_HPP_\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Vector3D_8cpp/","title":"File Vector3D.cpp","text":"<p>FileList &gt; Server &gt; Vector3D.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../include/Server/Vector.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Vector3D_8cpp/#public-functions","title":"Public Functions","text":"Type Name Vector2D operator* (double scalar, const Vector2D &amp; v) Overloads the * operator for scalar multiplication. Vector2D operator* (const Vector2D &amp; v, int scalar) Overloads the * operator for scalar multiplication. Vector2D operator*= (Vector2D &amp; v, double scalar)  Vector2D operator+ (const Vector2D &amp; u, const Vector2D &amp; v) Overloads the + operator for vector addition. Vector2D operator- (const Vector2D &amp; p, const Vector2D &amp; n) Overloads the - operator for vector subtraction."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Vector3D_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Vector3D_8cpp/#function-operator","title":"function operator*","text":"<p>Overloads the * operator for scalar multiplication. <pre><code>Vector2D operator* (\n    double scalar,\n    const Vector2D &amp; v\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>scalar</code> The scalar to multiply the vector by. </li> <li><code>v</code> The vector to multiply. </li> </ul> <p>Returns:</p> <p>The result of the scalar multiplication. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Vector3D_8cpp/#function-operator_1","title":"function operator*","text":"<p>Overloads the * operator for scalar multiplication. <pre><code>Vector2D operator* (\n    const Vector2D &amp; v,\n    int scalar\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>v</code> The vector to multiply. </li> <li><code>scalar</code> The scalar to multiply the vector by. </li> </ul> <p>Returns:</p> <p>The result of the scalar multiplication. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Vector3D_8cpp/#function-operator_2","title":"function operator*=","text":"<pre><code>Vector2D operator*= (\n    Vector2D &amp; v,\n    double scalar\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Vector3D_8cpp/#function-operator_3","title":"function operator+","text":"<p>Overloads the + operator for vector addition. <pre><code>Vector2D operator+ (\n    const Vector2D &amp; u,\n    const Vector2D &amp; v\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>u</code> The first vector. </li> <li><code>v</code> The second vector. </li> </ul> <p>Returns:</p> <p>The result of the vector addition. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Vector3D_8cpp/#function-operator-","title":"function operator-","text":"<p>Overloads the - operator for vector subtraction. <pre><code>Vector2D operator- (\n    const Vector2D &amp; p,\n    const Vector2D &amp; n\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p</code> The first vector. </li> <li><code>n</code> The second vector. </li> </ul> <p>Returns:</p> <p>The result of the vector subtraction. </p> <p>The documentation for this class was generated from the following file <code>src/Server/Vector3D.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Vector3D_8cpp_source/","title":"File Vector3D.cpp","text":"<p>File List &gt; Server &gt; Vector3D.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2023\n** B-OOP-400-COT-4-1-raytracer-shalom.dosseh\n** File description:\n** Vector3D.cpp\n*/\n\n#include \"../../include/Server/Vector.hpp\"\n\nVector2D operator+(const Vector2D &amp;u, const Vector2D &amp;v)\n{\n    return Vector2D(u.x + v.x, u.y + v.y);\n}\nVector2D operator-(const Vector2D &amp;p, const Vector2D &amp;n)\n{\n    return Vector2D(p.x - n.x, p.y - n.y);\n}\nVector2D operator*(double scalar, const Vector2D &amp;v)\n{\n    return Vector2D(scalar * v.x, scalar * v.y);\n}\nVector2D operator*(const Vector2D &amp;v, int scalar)\n{\n    return Vector2D(scalar * v.x, scalar * v.y);\n}\nVector2D operator*=(Vector2D &amp;v, double scalar)\n{\n    v.x *= scalar;\n    v.y *= scalar;\n    return v;\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Vector_8hpp/","title":"File Vector.hpp","text":"<p>FileList &gt; include &gt; Server &gt; Vector.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;cctype&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;limits&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;regex&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Vector_8hpp/#classes","title":"Classes","text":"Type Name class Vector2D A class to represent a 2D vector."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Vector_8hpp/#public-functions","title":"Public Functions","text":"Type Name Vector2D operator* (double scalar, const Vector2D &amp; v) Overloads the * operator for scalar multiplication. Vector2D operator* (const Vector2D &amp; v, int scalar) Overloads the * operator for scalar multiplication. Vector2D operator+ (const Vector2D &amp; u, const Vector2D &amp; v) Overloads the + operator for vector addition. Vector2D operator- (const Vector2D &amp; p, const Vector2D &amp; n) Overloads the - operator for vector subtraction."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Vector_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Vector_8hpp/#function-operator","title":"function operator*","text":"<p>Overloads the * operator for scalar multiplication. <pre><code>Vector2D operator* (\n    double scalar,\n    const Vector2D &amp; v\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>scalar</code> The scalar to multiply the vector by. </li> <li><code>v</code> The vector to multiply. </li> </ul> <p>Returns:</p> <p>The result of the scalar multiplication. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Vector_8hpp/#function-operator_1","title":"function operator*","text":"<p>Overloads the * operator for scalar multiplication. <pre><code>Vector2D operator* (\n    const Vector2D &amp; v,\n    int scalar\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>v</code> The vector to multiply. </li> <li><code>scalar</code> The scalar to multiply the vector by. </li> </ul> <p>Returns:</p> <p>The result of the scalar multiplication. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Vector_8hpp/#function-operator_2","title":"function operator+","text":"<p>Overloads the + operator for vector addition. <pre><code>Vector2D operator+ (\n    const Vector2D &amp; u,\n    const Vector2D &amp; v\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>u</code> The first vector. </li> <li><code>v</code> The second vector. </li> </ul> <p>Returns:</p> <p>The result of the vector addition. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Vector_8hpp/#function-operator-","title":"function operator-","text":"<p>Overloads the - operator for vector subtraction. <pre><code>Vector2D operator- (\n    const Vector2D &amp; p,\n    const Vector2D &amp; n\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p</code> The first vector. </li> <li><code>n</code> The second vector. </li> </ul> <p>Returns:</p> <p>The result of the vector subtraction. </p> <p>The documentation for this class was generated from the following file <code>include/Server/Vector.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/Vector_8hpp_source/","title":"File Vector.hpp","text":"<p>File List &gt; include &gt; Server &gt; Vector.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2023\n** B-OOP-400-COT-4-1-raytracer-shalom.dosseh\n** File description:\n** Vector.hpp\n*/\n\n#ifndef VECTOR_HPP_\n#define VECTOR_HPP_\n#include &lt;algorithm&gt;\n#include &lt;array&gt;\n#include &lt;cctype&gt;\n#include &lt;cmath&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;regex&gt;\n#include &lt;sstream&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n#include &lt;tuple&gt;\n#include &lt;vector&gt;\n\nclass Vector2D\n{\npublic:\n    double x; \n    double y; \n\n    Vector2D() : x(0), y(0) {}\n\n    Vector2D(double x, double y) : x(x), y(y) {}\n\n    double length() const { return std::sqrt(x * x + y * y); }\n\n    Vector2D vector_unit() const { return *this / length(); }\n\n    Vector2D &amp;operator/=(double scalar)\n    {\n        x /= scalar;\n        y /= scalar;\n        return *this;\n    }\n\n    Vector2D operator/(double scalar) const\n    {\n        Vector2D result(*this);\n        result /= scalar;\n        return result;\n    }\n\n    double dot(const Vector2D &amp;other) const { return x * other.x + y * other.y; }\n\n    double length_squared() const { return x * x + y * y; }\n\n    Vector2D normalize()\n    {\n        double length = std::sqrt(x * x + y * y);\n        return Vector2D(x / length, y / length);\n    }\n\n    /*\n     * @brief add two vectors\n     * @param vector v\n     * @return Vector2D&amp;\n     */\n    Vector2D &amp;add(const Vector2D &amp;v)\n    {\n        x += v.x;\n        y += v.y;\n        return *this;\n    }\n\n    Vector2D &amp;scale(double scalar)\n    {\n        x *= scalar;\n        y *= scalar;\n        return *this;\n    }\n\n    /*\n     * @brief rotate the vector by an angle\n     * @param double angle\n     * @return Vector2D&amp;\n     */\n\n    Vector2D &amp;rotate(double angle)\n    {\n        double rad = angle * M_PI / 180;\n        double c = cos(rad);\n        double s = sin(rad);\n        double nx = x * c - y * s;\n        double ny = x * s + y * c;\n        x = nx;\n        y = ny;\n        return *this;\n    }\n};\n\nVector2D operator+(const Vector2D &amp;u, const Vector2D &amp;v);\n\nVector2D operator-(const Vector2D &amp;p, const Vector2D &amp;n);\n\nVector2D operator*(double scalar, const Vector2D &amp;v);\n\nVector2D operator*(const Vector2D &amp;v, int scalar);\n\n#endif /* !VECTOR_HPP_ */\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class Animation </li> <li>struct AnimationData </li> <li>class AudioManager Handles sound and music playback using the SFML audio library. </li> <li>class BBox Component representing the size of an entity's bounding box. </li> <li>class Client Manages the client's interaction with the server and handles rendering, networking, and gameplay logic. </li> <li>class CoinSystem Manages the logic related to coins within the ECS ( Entity Component System). </li> <li>class CollisionSystem Handles collision detection and responses in the ECS ( Entity Component System). </li> <li>struct EndpointEqual Comparator for UDP endpoints. </li> <li>struct EndpointHash Hash function for UDP endpoints. </li> <li>class Entity Represents a game object composed of multiple components. </li> <li>namespace GameUI <ul> <li>class GameCore </li> <li>class GameLobby </li> <li>class GamePlay </li> <li>class GameSetting </li> <li>class RoomLobby </li> <li>class ScreenManager </li> </ul> </li> <li>class Health Component to manage an entity's health state. </li> <li>class HealthSystem Forward declaration of the Registry class. </li> <li>class IScreen </li> <li>class ImageManager Handles image loading, manipulation, and rendering using the SFML graphics library. </li> <li>class Input Component to track player input actions (e.g., movement or shooting). </li> <li>class InputManager Manages keyboard and window input events using the SFML library. </li> <li>struct Button Tracks the state of specific control buttons. </li> <li>class Menu </li> <li>class MouseManager Manages mouse input and tracks the mouse position within a window. </li> <li>class MouvementSystem Forward declaration of the Registry class. </li> <li>class Name Component to store the name of an entity. </li> <li>class Parallax </li> <li>class Registry Manages all entities in the game and their lifecycle. </li> <li>class Room_System Class responsible for managing game rooms. </li> <li>struct Room Struct representing a game room. </li> <li>class Score Component to manage an entity's score during gameplay. </li> <li>class Server A class representing the server managing TCP/UDP connections and game state. </li> <li>struct ClientInfo Structure containing information about connected clients. </li> <li>class ShapeManager Manages and renders geometric shapes using the SFML graphics library. </li> <li>class ShootSystem &lt; Includes the Entity class for representing game entities. </li> <li>struct TemporaryText </li> <li>class TextManager </li> <li>class ThreadPool A class representing a thread pool for managing asynchronous tasks. </li> <li>class TimeManager A class to manage time tracking for elapsed time measurements. </li> <li>class Transform Component representing an entity's position and velocity in 2D space. </li> <li>class Vector2D A class to represent a 2D vector. </li> <li>class WindowManager </li> <li>struct parameter_t Structure representing a command-line parameter. </li> <li>namespace protocol <ul> <li>struct EventNotification Structure representing a notification about a game event. </li> <li>struct GameStateUpdate Structure representing an update to the game state. </li> <li>struct PlayerAction Structure representing a player's action. </li> </ul> </li> <li>struct server_me_t Struct representing the server configuration. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/check__message_8cpp/","title":"File check_message.cpp","text":"<p>FileList &gt; Server &gt; check_message.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../include/Server/Server.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Server/check_message.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/check__message_8cpp_source/","title":"File check_message.cpp","text":"<p>File List &gt; Server &gt; check_message.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** B-CPP-500-COT-5-1-rtype-kafui.hounkpatin\n** File description:\n** check_message\n*/\n\n#include \"../../include/Server/Server.hpp\"\n\nint Server::get_player_id(const udp::endpoint &amp;client_endpoint)\n{\n    int i = 1;\n    for (auto client : _connected_clients)\n    {\n        if (client == client_endpoint)\n        {\n            return i;\n        }\n        i++;\n    }\n    return -1;\n}\n\nstd::string Server::get_player_name(const udp::endpoint &amp;client_endpoint)\n{\n    for (auto player : id_name)\n    {\n        if (player.first == client_endpoint)\n        {\n            return player.second;\n        }\n    }\n    return \"\";\n}\n\nvoid Server::check_player_message(udp::socket &amp;socket, const std::vector&lt;uint8_t&gt; &amp;buffer,\n                                  const udp::endpoint &amp;client_endpoint)\n{\n    if (buffer.empty())\n    {\n        return;\n    }\n    std::string pl_name;\n    uint8_t command = buffer[0];\n    switch (command)\n    {\n    case 0x01:\n    {\n        std::cout &lt;&lt; \"Player connected from \" &lt;&lt; client_endpoint &lt;&lt; std::endl;\n        std::string response = \"Player connected\";\n        socket.send_to(boost::asio::buffer(response), client_endpoint);\n        break;\n    }\n    case 0x02:\n    {\n        if (buffer.size() &lt; 21)\n        {\n            std::cerr &lt;&lt; \"Invalid player name input\" &lt;&lt; std::endl;\n            return;\n        }\n        std::string player_name(buffer.begin() + 1, buffer.end());\n        std::cout &lt;&lt; \"Player name: \" &lt;&lt; player_name &lt;&lt; \" from \" &lt;&lt; client_endpoint &lt;&lt; std::endl;\n        uint8_t command = 0x02;\n        players_count++;\n        std::vector&lt;u_int16_t&gt; response = {0x02, players_count};\n        id_name.push_back(std::make_pair(client_endpoint, player_name));\n        registry.spawn_player(player_name);\n        registry.entity_update();\n        game_run = true;\n        int i = 1;\n        for (auto client : _connected_clients)\n        {\n            socket.send_to(boost::asio::buffer(response), client);\n        }\n        std::vector&lt;std::vector&lt;u_int16_t&gt;&gt; updates;\n        if (registry.get_entities(\"Player\").size() &gt; 0)\n        {\n            for (auto player : id_name)\n            {\n                auto pos = movement.move_player(registry, player.second);\n                std::vector&lt;u_int16_t&gt; update = {0x05, static_cast&lt;u_int16_t&gt;(i),\n                                                 static_cast&lt;u_int16_t&gt;(pos.x),\n                                                 static_cast&lt;u_int16_t&gt;(pos.y)};\n                std::cout &lt;&lt; \"New player position: (\" &lt;&lt; \" id :\" &lt;&lt; i &lt;&lt; \" \" &lt;&lt; pos.x &lt;&lt; \", \"\n                          &lt;&lt; pos.y &lt;&lt; \")\" &lt;&lt; std::endl;\n                updates.push_back(update);\n                i++;\n            }\n        }\n        for (auto update : updates)\n        {\n            for (auto client : _connected_clients)\n            {\n                socket.send_to(boost::asio::buffer(update), client);\n            }\n        }\n        u_int16_t health = 100;\n        u_int16_t score = 0;\n        std::vector&lt;u_int16_t&gt; player_info = {0x07, health, score};\n        socket.send_to(boost::asio::buffer(player_info), client_endpoint);\n        break;\n    }\n    case 0x03:\n    {\n        if (buffer.size() &lt; 2)\n        {\n            std::cerr &lt;&lt; \"Invalid player movement input\" &lt;&lt; std::endl;\n            return;\n        }\n        uint8_t direction = buffer[1];\n        std::string move_direction;\n        switch (direction)\n        {\n        case 0x01:\n            move_direction = \"keyup\";\n            break;\n        case 0x02:\n            move_direction = \"keydown\";\n            break;\n        case 0x03:\n            move_direction = \"keyleft\";\n            break;\n        case 0x04:\n            move_direction = \"keyright\";\n            break;\n        default:\n            std::cerr &lt;&lt; \"Unknown direction\" &lt;&lt; std::endl;\n            return;\n        }\n\n        auto it = std::find_if(id_name.begin(), id_name.end(),\n                               [&amp;client_endpoint](const std::pair&lt;udp::endpoint, std::string&gt; &amp;pair)\n                               { return pair.first == client_endpoint; });\n        if (it != id_name.end())\n        {\n            pl_name = it-&gt;second;\n        }\n        else\n        {\n            std::cerr &lt;&lt; \"Player name not found for endpoint \" &lt;&lt; client_endpoint &lt;&lt; std::endl;\n            return;\n        }\n        Vector2D pos = {0, 0};\n        movement.handleInput(registry, move_direction, pl_name);\n        pos = movement.move_player(registry, pl_name);\n        int id = get_player_id(client_endpoint);\n        std::vector&lt;u_int16_t&gt; response = {0x03, static_cast&lt;u_int16_t&gt;(id),\n                                           static_cast&lt;u_int16_t&gt;(pos.x),\n                                           static_cast&lt;u_int16_t&gt;(pos.y)};\n        std::vector&lt;u_int16_t&gt; update = {0x05, static_cast&lt;u_int16_t&gt;(id),\n                                         static_cast&lt;u_int16_t&gt;(pos.x),\n                                         static_cast&lt;u_int16_t&gt;(pos.y)};\n        socket.send_to(boost::asio::buffer(response), client_endpoint);\n        for (auto client : _connected_clients)\n        {\n            socket.send_to(boost::asio::buffer(update), client);\n        }\n        break;\n    }\n    case 0x06:\n    {\n    }\n    default:\n        std::cerr &lt;&lt; \"Unknown command received\" &lt;&lt; std::endl;\n        break;\n    }\n}\n\nvoid Server::check_player_position(udp::socket &amp;socket, const std::vector&lt;uint8_t&gt; &amp;buffer,\n                                   const udp::endpoint &amp;client_endpoint)\n{\n    if (buffer.empty())\n    {\n        return;\n    }\n    if (buffer.size() &lt; 3)\n    {\n        std::cerr &lt;&lt; \"Invalid player position input\" &lt;&lt; std::endl;\n        return;\n    }\n    uint8_t id = buffer[1];\n    uint8_t pos_x = buffer[2];\n    uint8_t pos_y = buffer[3];\n    std::cout &lt;&lt; \"Player \" &lt;&lt; static_cast&lt;int&gt;(id) &lt;&lt; \" position: (\" &lt;&lt; static_cast&lt;int&gt;(pos_x)\n              &lt;&lt; \", \" &lt;&lt; static_cast&lt;int&gt;(pos_y) &lt;&lt; \")\" &lt;&lt; std::endl;\n    std::vector&lt;u_int16_t&gt; response = {0x05, id, pos_x, pos_y};\n    for (auto client : _connected_clients)\n    {\n        socket.send_to(boost::asio::buffer(response), client);\n    }\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/check__params_8cpp/","title":"File check_params.cpp","text":"<p>FileList &gt; Server &gt; check_params.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../include/Server/Server.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/check__params_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const server_t CHECK_SERVER   = = {.tcp_port = -1, .udp_port = -1} const std::vector&lt; parameter_t &gt; ZAPPY_SERVER_PARAMS   = = { {\"-tcp\",  -&gt; bool { return sup_int_spec(param, av); }, \"tcp_port\", \"is the tcp port number\", static_cast&lt;int&gt;(reinterpret_cast&lt;const char *&gt;(&amp;CHECK_SERVER.tcp_port) - reinterpret_cast&lt;const char *&gt;(&amp;CHECK_SERVER))}, {\"-udp\",  -&gt; bool { return sup_int_spec(param, av); }, \"udp_port\", \"is the udp port number\", static_cast&lt;int&gt;(reinterpret_cast&lt;const char *&gt;(&amp;CHECK_SERVER.udp_port) - reinterpret_cast&lt;const char *&gt;(&amp;CHECK_SERVER))}}"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/check__params_8cpp/#public-functions","title":"Public Functions","text":"Type Name bool add_to_server_struct (server_t * server, char ** av, int i)  void initialize_parameters (server_t * server)  bool recup_args (server_t * server, int ac, char ** av)  bool sup_int_spec (int * param, char ** av)  void usage ()"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/check__params_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/check__params_8cpp/#variable-check_server","title":"variable CHECK_SERVER","text":"<pre><code>const server_t CHECK_SERVER;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/check__params_8cpp/#variable-zappy_server_params","title":"variable ZAPPY_SERVER_PARAMS","text":"<pre><code>const std::vector&lt;parameter_t&gt; ZAPPY_SERVER_PARAMS;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/check__params_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/check__params_8cpp/#function-add_to_server_struct","title":"function add_to_server_struct","text":"<pre><code>bool add_to_server_struct (\n    server_t * server,\n    char ** av,\n    int i\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/check__params_8cpp/#function-initialize_parameters","title":"function initialize_parameters","text":"<pre><code>void initialize_parameters (\n    server_t * server\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/check__params_8cpp/#function-recup_args","title":"function recup_args","text":"<pre><code>bool recup_args (\n    server_t * server,\n    int ac,\n    char ** av\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/check__params_8cpp/#function-sup_int_spec","title":"function sup_int_spec","text":"<pre><code>bool sup_int_spec (\n    int * param,\n    char ** av\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/check__params_8cpp/#function-usage","title":"function usage","text":"<pre><code>void usage () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Server/check_params.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/check__params_8cpp_source/","title":"File check_params.cpp","text":"<p>File List &gt; Server &gt; check_params.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** check_param\n** File description:\n** check_params\n*/\n\n#include \"../../include/Server/Server.hpp\"\n\nstatic const server_t CHECK_SERVER = {.tcp_port = -1, .udp_port = -1};\n\nbool sup_int_spec(int *param, char **av)\n{\n    if (!av || !av[0])\n    {\n        return false;\n    }\n    try\n    {\n        *param = std::stoi(av[0]);\n    }\n    catch (const std::invalid_argument &amp;)\n    {\n        return false;\n    }\n    return (*param &gt; 0);\n}\n\nstatic const std::vector&lt;parameter_t&gt; ZAPPY_SERVER_PARAMS = {\n    {\"-tcp\", [](int *param, char **av) -&gt; bool { return sup_int_spec(param, av); }, \"tcp_port\",\n     \"is the tcp port number\",\n     static_cast&lt;int&gt;(reinterpret_cast&lt;const char *&gt;(&amp;CHECK_SERVER.tcp_port) -\n                      reinterpret_cast&lt;const char *&gt;(&amp;CHECK_SERVER))},\n    {\"-udp\", [](int *param, char **av) -&gt; bool { return sup_int_spec(param, av); }, \"udp_port\",\n     \"is the udp port number\",\n     static_cast&lt;int&gt;(reinterpret_cast&lt;const char *&gt;(&amp;CHECK_SERVER.udp_port) -\n                      reinterpret_cast&lt;const char *&gt;(&amp;CHECK_SERVER))}};\n\nvoid usage()\n{\n    std::cout &lt;&lt; \"USAGE: ./r_type_server -tcp tcp_port -udp udp_port\\n\"\n                 \"tcp_port\\tis the tcp port number\\n\"\n                 \"udp_port\\tis the udp port number\\n\";\n    std::exit(0);\n}\n\nbool add_to_server_struct(server_t *server, char **av, int i)\n{\n    for (const auto &amp;param : ZAPPY_SERVER_PARAMS)\n    {\n        if (!strcmp(av[i], param.argument.c_str()) &amp;&amp;\n            !param.add_new_param(\n                reinterpret_cast&lt;int *&gt;(reinterpret_cast&lt;char *&gt;(server) + param.check_me),\n                &amp;av[i + 1]))\n        {\n            std::cerr &lt;&lt; \"Invalid \" &lt;&lt; param.name &lt;&lt; \"\\n\"\n                      &lt;&lt; param.name &lt;&lt; \" \" &lt;&lt; param.usage &lt;&lt; \"\\n\";\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid initialize_parameters(server_t *server)\n{\n    server-&gt;tcp_port = 0;\n    server-&gt;udp_port = 0;\n}\n\nbool recup_args(server_t *server, int ac, char **av)\n{\n    initialize_parameters(server);\n    for (int i = 0; i &lt; ac; ++i)\n    {\n        if (!add_to_server_struct(server, av, i))\n            return false;\n    }\n    if (server-&gt;tcp_port &lt;= 0 || server-&gt;udp_port &lt;= 0)\n    {\n        usage();\n        return false;\n    }\n    return true;\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAnimation/","title":"Class Animation","text":"<p>ClassList &gt; Animation</p> <ul> <li><code>#include &lt;Animation.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAnimation/#public-functions","title":"Public Functions","text":"Type Name Animation ()  sf::Vector2f getPosition (const std::string &amp; name_by_color)  sf::Sprite &amp; getSprite ()  void loadAnimation (const std::string &amp; name_by_color, int frames, float x, float y)  void moveXLeft (const std::string &amp; name_by_color, float SpeedX)  void moveXRight (const std::string &amp; name_by_color, float SpeedX)  void moveY (const std::string &amp; name_by_color, float SpeedY)  void moveYUp (const std::string &amp; name_by_color, float SpeedY)  void render (sf::RenderWindow &amp; window, const std::string &amp; name_by_color)  void setPosition (const std::string &amp; name_by_color, float x, float y)  void setScale (float scaleX, float scaleY)  void update (const std::string &amp; name_by_color)  ~Animation ()"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAnimation/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAnimation/#function-animation","title":"function Animation","text":"<pre><code>Animation::Animation () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAnimation/#function-getposition","title":"function getPosition","text":"<pre><code>sf::Vector2f Animation::getPosition (\n    const std::string &amp; name_by_color\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAnimation/#function-getsprite","title":"function getSprite","text":"<pre><code>inline sf::Sprite &amp; Animation::getSprite () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAnimation/#function-loadanimation","title":"function loadAnimation","text":"<pre><code>void Animation::loadAnimation (\n    const std::string &amp; name_by_color,\n    int frames,\n    float x,\n    float y\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAnimation/#function-movexleft","title":"function moveXLeft","text":"<pre><code>void Animation::moveXLeft (\n    const std::string &amp; name_by_color,\n    float SpeedX\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAnimation/#function-movexright","title":"function moveXRight","text":"<pre><code>void Animation::moveXRight (\n    const std::string &amp; name_by_color,\n    float SpeedX\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAnimation/#function-movey","title":"function moveY","text":"<pre><code>void Animation::moveY (\n    const std::string &amp; name_by_color,\n    float SpeedY\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAnimation/#function-moveyup","title":"function moveYUp","text":"<pre><code>void Animation::moveYUp (\n    const std::string &amp; name_by_color,\n    float SpeedY\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAnimation/#function-render","title":"function render","text":"<pre><code>void Animation::render (\n    sf::RenderWindow &amp; window,\n    const std::string &amp; name_by_color\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAnimation/#function-setposition","title":"function setPosition","text":"<pre><code>void Animation::setPosition (\n    const std::string &amp; name_by_color,\n    float x,\n    float y\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAnimation/#function-setscale","title":"function setScale","text":"<pre><code>void Animation::setScale (\n    float scaleX,\n    float scaleY\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAnimation/#function-update","title":"function update","text":"<pre><code>void Animation::update (\n    const std::string &amp; name_by_color\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAnimation/#function-animation_1","title":"function ~Animation","text":"<pre><code>Animation::~Animation () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Engine/Animation/Animation.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAudioManager/","title":"Class AudioManager","text":"<p>ClassList &gt; AudioManager</p> <p>Handles sound and music playback using the SFML audio library. More...</p> <ul> <li><code>#include &lt;AudioManager.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAudioManager/#public-functions","title":"Public Functions","text":"Type Name AudioManager () Constructs an AudioManager instance. void pauseMusic () Pauses the currently playing music. void playMusic (const std::string &amp; Path) Plays a music track from a specified file. void playSound (const std::string &amp; Path) Plays a sound effect from a specified file. void resumeMusic () Resumes music playback from the paused position. void setMusicVolume (float volume=100) Sets the volume level for music playback. void setPitch (float pitch=1.0) Adjusts the pitch of the sound effect. void setSoundVolume (float volume=100) Sets the volume level for sound effects playback. ~AudioManager () Destructs the AudioManager instance."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAudioManager/#detailed-description","title":"Detailed Description","text":"<p>The AudioManager class provides a comprehensive interface for managing and controlling audio playback in an application. It supports both short sound effects via sf::Sound and longer music tracks via sf::Music, offering functionality for loading, playing, pausing, resuming, and adjusting audio properties such as volume and pitch.</p> <p>This class is implemented as a singleton to ensure centralized audio management and prevent multiple instances from causing resource conflicts or duplicate sound playback.</p> <p>Note:</p> <p>AudioManager assumes the audio resources are properly initialized, and the paths provided are valid audio file formats supported by SFML. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAudioManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAudioManager/#function-audiomanager","title":"function AudioManager","text":"<p>Constructs an AudioManager instance. <pre><code>AudioManager::AudioManager () \n</code></pre></p> <p>Initializes the AudioManager for managing sound and music playback. In a full singleton implementation, this constructor should be private, and a static method would control instance creation. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAudioManager/#function-pausemusic","title":"function pauseMusic","text":"<p>Pauses the currently playing music. <pre><code>void AudioManager::pauseMusic () \n</code></pre></p> <p>Temporarily halts music playback, preserving the current position. This allows the music to be resumed from the same point using resumeMusic().</p> <p>Note:</p> <p>This function only affects music playback and not sound effects. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAudioManager/#function-playmusic","title":"function playMusic","text":"<p>Plays a music track from a specified file. <pre><code>void AudioManager::playMusic (\n    const std::string &amp; Path\n) \n</code></pre></p> <p>Loads and streams music from the given file path, starting playback once the music file is successfully opened. Music files should be larger audio tracks intended for extended playback.</p> <p>Parameters:</p> <ul> <li><code>Path</code> A string representing the file path of the music track. </li> </ul> <p>Exception:</p> <ul> <li><code>std::runtime_error</code> if the music file cannot be opened.</li> </ul> <p>Note:</p> <p>Supported music formats include OGG, FLAC, MP3 and WAV. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAudioManager/#function-playsound","title":"function playSound","text":"<p>Plays a sound effect from a specified file. <pre><code>void AudioManager::playSound (\n    const std::string &amp; Path\n) \n</code></pre></p> <p>Loads a sound from the provided file path into the buffer and immediately plays it using the sf::Sound object.</p> <p>Parameters:</p> <ul> <li><code>Path</code> A string representing the file path of the sound effect. </li> </ul> <p>Exception:</p> <ul> <li><code>std::runtime_error</code> if the sound file cannot be loaded.</li> </ul> <p>Note:</p> <p>Ensure the sound file is in a supported format (e.g., WAV, OGG, MP3). </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAudioManager/#function-resumemusic","title":"function resumeMusic","text":"<p>Resumes music playback from the paused position. <pre><code>void AudioManager::resumeMusic () \n</code></pre></p> <p>Continues playing the previously paused music from the exact position it was paused.</p> <p>Note:</p> <p>Music must have been paused using pauseMusic() for this method to work. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAudioManager/#function-setmusicvolume","title":"function setMusicVolume","text":"<p>Sets the volume level for music playback. <pre><code>void AudioManager::setMusicVolume (\n    float volume=100\n) \n</code></pre></p> <p>Adjusts the volume for the music being played. The volume is a floating-point value between 0 (mute) and 100 (full volume).</p> <p>Parameters:</p> <ul> <li><code>volume</code> A float representing the desired volume level (default is 100).</li> </ul> <p>Note:</p> <p>This function only affects the music volume, not sound effects. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAudioManager/#function-setpitch","title":"function setPitch","text":"<p>Adjusts the pitch of the sound effect. <pre><code>void AudioManager::setPitch (\n    float pitch=1.0\n) \n</code></pre></p> <p>Sets the pitch for the sound effect currently loaded into the sf::Sound object. The pitch determines how high or low the sound is played, with a value of 1.0 being the normal pitch.</p> <p>Parameters:</p> <ul> <li><code>pitch</code> A float representing the desired pitch level (default is 1.0).</li> </ul> <p>Note:</p> <p>This function only affects sound effects, not music. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAudioManager/#function-setsoundvolume","title":"function setSoundVolume","text":"<p>Sets the volume level for sound effects playback. <pre><code>void AudioManager::setSoundVolume (\n    float volume=100\n) \n</code></pre></p> <p>Adjusts the volume of the sound effects being played. The volume is a floating-point value between 0 (mute) and 100 (full volume).</p> <p>Parameters:</p> <ul> <li><code>volume</code> A float representing the desired volume level (default is 100).</li> </ul> <p>Note:</p> <p>This function only affects sound effects volume, not music. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classAudioManager/#function-audiomanager_1","title":"function ~AudioManager","text":"<p>Destructs the AudioManager instance. <pre><code>AudioManager::~AudioManager () \n</code></pre></p> <p>Cleans up and releases any audio resources associated with sound or music playback, ensuring proper resource deallocation. </p> <p>The documentation for this class was generated from the following file <code>include/Engine/Audio/AudioManager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classBBox/","title":"Class BBox","text":"<p>ClassList &gt; BBox</p> <p>Component representing the size of an entity's bounding box. More...</p> <ul> <li><code>#include &lt;Entity.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classBBox/#public-attributes","title":"Public Attributes","text":"Type Name Vector2D size Size of the entity's bounding box."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classBBox/#public-functions","title":"Public Functions","text":"Type Name BBox () Default constructor initializes the bounding box size to (0, 0). BBox (Vector2D s) Constructor to set the bounding box size."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classBBox/#detailed-description","title":"Detailed Description","text":"<p>This component is useful for collision detection, determining how much space the entity occupies in the game world. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classBBox/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classBBox/#variable-size","title":"variable size","text":"<pre><code>Vector2D BBox::size;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classBBox/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classBBox/#function-bbox-12","title":"function BBox [1/2]","text":"<pre><code>inline BBox::BBox () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classBBox/#function-bbox-22","title":"function BBox [2/2]","text":"<p>Constructor to set the bounding box size. <pre><code>inline BBox::BBox (\n    Vector2D s\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>s</code> The size of the bounding box. </li> </ul> <p>The documentation for this class was generated from the following file <code>include/Server/Entity.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/","title":"Class Client","text":"<p>ClassList &gt; Client</p> <p>Manages the client's interaction with the server and handles rendering, networking, and gameplay logic. More...</p> <ul> <li><code>#include &lt;Client.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#public-attributes","title":"Public Attributes","text":"Type Name AudioManager ButtonSound Manager for handling button sounds. ImageManager GamePlayImage Image managers for rendering various game assets. ImageManager LifeBoardImage ImageManager TeamScoreImage int _health   = = 100The current health of the player. boost::asio::io_context _io_context The Boost Asio context for managing asynchronous operations. udp::endpoint _receiver_endpoint The server's endpoint for UDP communication. int _score   = = 0The current score of the player. udp::socket _soc The UDP socket for communication with the server. ImageManager backgroundImage Animation enemie1 Animation enemie2 Animation enemie3 Animation enemie4 Animation enemie5 Animation enemie6 Animation enemie7 Animation enemie8 Animation enemie9 Animation enemieBoss std::vector&lt; sf::CircleShape &gt; enemies List of enemy shapes. std::vector&lt; std::pair&lt; int, Animation &gt; &gt; enemies_id List of enemy IDs and their animations. sf::Event event The event object used to handle player input and window events. sf::Font font Font used for rendering text in the game. bool game_over   = = falseWhether the game has ended or not. std::string input Input string for capturing user data. Animation player1 Animations for players and enemies. Animation player2 std::vector&lt; sf::RectangleShape &gt; players List of player shapes in the game. std::vector&lt; std::pair&lt; int, Animation &gt; &gt; players_id List of player IDs and their corresponding animations. std::vector&lt; sf::CircleShape &gt; projectiles List of projectiles. std::vector&lt; std::pair&lt; int, sf::CircleShape &gt; &gt; projectiles_id List of projectile IDs and shapes. ShapeManager shapeManager1 Shape managers for rendering various objects in the game. ShapeManager shapeManager2 sf::RenderWindow window The main window used for rendering the game. TextManager window_manager Manager for rendering text in the game window."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#public-functions","title":"Public Functions","text":"Type Name Client () Default constructor for initializing the Client . void assign_enemy () Assigns enemy colors to specific IDs based on predefined values. void create_player_1 () Creates player 1 and adds it to the list of players. void create_player_2 () Creates player 2 and adds it to the list of players. void create_player_3 () Creates player 3 and adds it to the list of players. void create_player_4 () Creates player 4 and adds it to the list of players. Animation create_random_enemy (int id) Creates an enemy entity with a random animation. std::string get_enemy_color (int id) Retrieves the color associated with a specific enemy. std::string get_name () Retrieves the player's name from the input field. std::string get_player_color (int id) Retrieves the color associated with a specific player. void send_tcp_message (const protocol::PlayerAction &amp; message, const std::string &amp; server_ip, int server_port) Sends a TCP message containing a player's action to the server. void send_udp_message (const protocol::PlayerAction &amp; message, const std::string &amp; server_ip, int server_port, std::string player_name) Sends a UDP message containing a player's action to the server. ~Client () Destructor to clean up resources."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#protected-attributes","title":"Protected Attributes","text":"Type Name int server_tcp_ip The TCP IP address of the server. int server_udp_ip The UDP IP address of the server."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#detailed-description","title":"Detailed Description","text":"<p>This class establishes the client's connection to the game server using both UDP and TCP protocols. It also manages rendering the game window, handling user input, and managing entities such as players, enemies, and projectiles. The class integrates various managers (image, audio, shape, text) for smooth gameplay.</p> <p>Note:</p> <p>The client interacts with the server through <code>send_tcp_message</code> and <code>send_udp_message</code>. It also manages various players, enemies, and their animations. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-buttonsound","title":"variable ButtonSound","text":"<pre><code>AudioManager Client::ButtonSound;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-gameplayimage","title":"variable GamePlayImage","text":"<pre><code>ImageManager Client::GamePlayImage;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-lifeboardimage","title":"variable LifeBoardImage","text":"<pre><code>ImageManager Client::LifeBoardImage;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-teamscoreimage","title":"variable TeamScoreImage","text":"<pre><code>ImageManager Client::TeamScoreImage;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-_health","title":"variable _health","text":"<pre><code>int Client::_health;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-_io_context","title":"variable _io_context","text":"<pre><code>boost::asio::io_context Client::_io_context;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-_receiver_endpoint","title":"variable _receiver_endpoint","text":"<pre><code>udp::endpoint Client::_receiver_endpoint;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-_score","title":"variable _score","text":"<pre><code>int Client::_score;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-_soc","title":"variable _soc","text":"<pre><code>udp::socket Client::_soc;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-backgroundimage","title":"variable backgroundImage","text":"<pre><code>ImageManager Client::backgroundImage;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-enemie1","title":"variable enemie1","text":"<pre><code>Animation Client::enemie1;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-enemie2","title":"variable enemie2","text":"<pre><code>Animation Client::enemie2;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-enemie3","title":"variable enemie3","text":"<pre><code>Animation Client::enemie3;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-enemie4","title":"variable enemie4","text":"<pre><code>Animation Client::enemie4;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-enemie5","title":"variable enemie5","text":"<pre><code>Animation Client::enemie5;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-enemie6","title":"variable enemie6","text":"<pre><code>Animation Client::enemie6;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-enemie7","title":"variable enemie7","text":"<pre><code>Animation Client::enemie7;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-enemie8","title":"variable enemie8","text":"<pre><code>Animation Client::enemie8;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-enemie9","title":"variable enemie9","text":"<pre><code>Animation Client::enemie9;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-enemieboss","title":"variable enemieBoss","text":"<pre><code>Animation Client::enemieBoss;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-enemies","title":"variable enemies","text":"<pre><code>std::vector&lt;sf::CircleShape&gt; Client::enemies;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-enemies_id","title":"variable enemies_id","text":"<pre><code>std::vector&lt;std::pair&lt;int, Animation&gt; &gt; Client::enemies_id;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-event","title":"variable event","text":"<pre><code>sf::Event Client::event;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-font","title":"variable font","text":"<pre><code>sf::Font Client::font;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-game_over","title":"variable game_over","text":"<pre><code>bool Client::game_over;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-input","title":"variable input","text":"<pre><code>std::string Client::input;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-player1","title":"variable player1","text":"<pre><code>Animation Client::player1;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-player2","title":"variable player2","text":"<pre><code>Animation Client::player2;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-players","title":"variable players","text":"<pre><code>std::vector&lt;sf::RectangleShape&gt; Client::players;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-players_id","title":"variable players_id","text":"<pre><code>std::vector&lt;std::pair&lt;int, Animation&gt; &gt; Client::players_id;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-projectiles","title":"variable projectiles","text":"<pre><code>std::vector&lt;sf::CircleShape&gt; Client::projectiles;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-projectiles_id","title":"variable projectiles_id","text":"<pre><code>std::vector&lt;std::pair&lt;int, sf::CircleShape&gt; &gt; Client::projectiles_id;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-shapemanager1","title":"variable shapeManager1","text":"<pre><code>ShapeManager Client::shapeManager1;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-shapemanager2","title":"variable shapeManager2","text":"<pre><code>ShapeManager Client::shapeManager2;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-window","title":"variable window","text":"<pre><code>sf::RenderWindow Client::window;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-window_manager","title":"variable window_manager","text":"<pre><code>TextManager Client::window_manager;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#function-client","title":"function Client","text":"<pre><code>Client::Client () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#function-assign_enemy","title":"function assign_enemy","text":"<pre><code>void Client::assign_enemy () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#function-create_player_1","title":"function create_player_1","text":"<pre><code>void Client::create_player_1 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#function-create_player_2","title":"function create_player_2","text":"<pre><code>void Client::create_player_2 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#function-create_player_3","title":"function create_player_3","text":"<pre><code>void Client::create_player_3 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#function-create_player_4","title":"function create_player_4","text":"<pre><code>void Client::create_player_4 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#function-create_random_enemy","title":"function create_random_enemy","text":"<p>Creates an enemy entity with a random animation. <pre><code>Animation Client::create_random_enemy (\n    int id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> The unique ID of the enemy to be created. </li> </ul> <p>Returns:</p> <p>The animation object representing the enemy. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#function-get_enemy_color","title":"function get_enemy_color","text":"<p>Retrieves the color associated with a specific enemy. <pre><code>std::string Client::get_enemy_color (\n    int id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> The ID of the enemy. </li> </ul> <p>Returns:</p> <p>A string representing the enemy's color. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#function-get_name","title":"function get_name","text":"<p>Retrieves the player's name from the input field. <pre><code>std::string Client::get_name () \n</code></pre></p> <p>Returns:</p> <p>A string representing the player's name. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#function-get_player_color","title":"function get_player_color","text":"<p>Retrieves the color associated with a specific player. <pre><code>std::string Client::get_player_color (\n    int id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> The ID of the player. </li> </ul> <p>Returns:</p> <p>A string representing the player's color. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#function-send_tcp_message","title":"function send_tcp_message","text":"<p>Sends a TCP message containing a player's action to the server. <pre><code>void Client::send_tcp_message (\n    const protocol::PlayerAction &amp; message,\n    const std::string &amp; server_ip,\n    int server_port\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>message</code> The player action to send. </li> <li><code>server_ip</code> The IP address of the server. </li> <li><code>server_port</code> The TCP port on which the server is listening. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#function-send_udp_message","title":"function send_udp_message","text":"<p>Sends a UDP message containing a player's action to the server. <pre><code>void Client::send_udp_message (\n    const protocol::PlayerAction &amp; message,\n    const std::string &amp; server_ip,\n    int server_port,\n    std::string player_name\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>message</code> The player action to send. </li> <li><code>server_ip</code> The IP address of the server. </li> <li><code>server_port</code> The UDP port on which the server is listening. </li> <li><code>player_name</code> The name of the player sending the message.</li> </ul> <p>Note:</p> <p>UDP is used for fast, lightweight communication. Messages may not always be delivered, so ACK mechanisms may be necessary. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#function-client_1","title":"function ~Client","text":"<pre><code>Client::~Client () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-server_tcp_ip","title":"variable server_tcp_ip","text":"<pre><code>int Client::server_tcp_ip;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classClient/#variable-server_udp_ip","title":"variable server_udp_ip","text":"<pre><code>int Client::server_udp_ip;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Server/Client.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classCoinSystem/","title":"Class CoinSystem","text":"<p>ClassList &gt; CoinSystem</p> <p>Manages the logic related to coins within the ECS ( Entity Component System).More...</p> <ul> <li><code>#include &lt;Coin_system.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classCoinSystem/#public-functions","title":"Public Functions","text":"Type Name void checkCoins (Registry &amp; registry) Checks and updates the status of coins for entities in the registry."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classCoinSystem/#detailed-description","title":"Detailed Description","text":"<p>The CoinSystem class contains methods responsible for verifying and processing coin-related aspects for entities managed by the ECS. This is a system class that interacts with the entity registry to apply logic to components. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classCoinSystem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classCoinSystem/#function-checkcoins","title":"function checkCoins","text":"<p>Checks and updates the status of coins for entities in the registry. <pre><code>void CoinSystem::checkCoins (\n    Registry &amp; registry\n) \n</code></pre></p> <p>This method loops through the relevant entities in the provided registry and applies the coin-related logic, such as updating coin counts, triggering rewards, or handling coin collection events.</p> <p>Parameters:</p> <ul> <li><code>registry</code> Reference to the Registry object that holds all the entities and their components. This allows the CoinSystem to access and modify the state of entities related to coins. </li> </ul> <p>The documentation for this class was generated from the following file <code>include/Server/Coin_system.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classCollisionSystem/","title":"Class CollisionSystem","text":"<p>ClassList &gt; CollisionSystem</p> <p>Handles collision detection and responses in the ECS ( Entity Component System).More...</p> <ul> <li><code>#include &lt;Collision_system.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classCollisionSystem/#public-functions","title":"Public Functions","text":"Type Name CollisionSystem () Default constructor for the CollisionSystem . Initializes the collision system but currently does not require any specific setup. bool check_collision (std::shared_ptr&lt; Entity &gt; &amp; proj, std::shared_ptr&lt; Entity &gt; &amp; enemy) Checks if a collision occurred between two entities. bool collision_enemy_projectiles (Registry &amp; registry) Handles collisions between enemy entities and projectiles. void collision_player_enemy (Registry &amp; registry) Handles collisions between the player and enemies. void collison_player_coins (Registry &amp; registry) Handles interactions between the player and coins. ~CollisionSystem () Default destructor for the CollisionSystem . Ensures proper cleanup of any allocated resources, though none are explicitly required here."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classCollisionSystem/#detailed-description","title":"Detailed Description","text":"<p>This system manages various types of collisions, such as player-enemy collisions, player-coin interactions, and enemy-projectile collisions. It utilizes the ECS registry to access and modify entity states and interactions. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classCollisionSystem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classCollisionSystem/#function-collisionsystem","title":"function CollisionSystem","text":"<pre><code>inline CollisionSystem::CollisionSystem () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classCollisionSystem/#function-check_collision","title":"function check_collision","text":"<p>Checks if a collision occurred between two entities. <pre><code>bool CollisionSystem::check_collision (\n    std::shared_ptr&lt; Entity &gt; &amp; proj,\n    std::shared_ptr&lt; Entity &gt; &amp; enemy\n) \n</code></pre></p> <p>This method determines if a collision has occurred between a projectile and an enemy entity. It returns <code>true</code> if a collision is detected and <code>false</code> otherwise.</p> <p>Parameters:</p> <ul> <li><code>proj</code> Shared pointer to the projectile entity involved in the potential collision. </li> <li><code>enemy</code> Shared pointer to the enemy entity involved in the potential collision. </li> </ul> <p>Returns:</p> <p><code>true</code> if a collision is detected, <code>false</code> otherwise. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classCollisionSystem/#function-collision_enemy_projectiles","title":"function collision_enemy_projectiles","text":"<p>Handles collisions between enemy entities and projectiles. <pre><code>bool CollisionSystem::collision_enemy_projectiles (\n    Registry &amp; registry\n) \n</code></pre></p> <p>This method checks if any projectiles have hit enemies, applying damage and potentially removing either the enemy or the projectile based on game logic.</p> <p>Parameters:</p> <ul> <li><code>registry</code> Reference to the Registry object containing all entities and components. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classCollisionSystem/#function-collision_player_enemy","title":"function collision_player_enemy","text":"<p>Handles collisions between the player and enemies. <pre><code>void CollisionSystem::collision_player_enemy (\n    Registry &amp; registry\n) \n</code></pre></p> <p>This function detects if the player has collided with any enemy entities and updates the state accordingly (e.g., reducing player health, triggering death animations, etc.).</p> <p>Parameters:</p> <ul> <li><code>registry</code> Reference to the Registry object containing all entities and components. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classCollisionSystem/#function-collison_player_coins","title":"function collison_player_coins","text":"<p>Handles interactions between the player and coins. <pre><code>void CollisionSystem::collison_player_coins (\n    Registry &amp; registry\n) \n</code></pre></p> <p>Detects if the player has collected any coins and updates the game state, such as increasing the player's coin count or triggering a reward.</p> <p>Parameters:</p> <ul> <li><code>registry</code> Reference to the Registry object containing all entities and components. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classCollisionSystem/#function-collisionsystem_1","title":"function ~CollisionSystem","text":"<pre><code>inline CollisionSystem::~CollisionSystem () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Server/Collision_system.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classEntity/","title":"Class Entity","text":"<p>ClassList &gt; Entity</p> <p>Represents a game object composed of multiple components. More...</p> <ul> <li><code>#include &lt;Entity.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classEntity/#public-attributes","title":"Public Attributes","text":"Type Name bool _alive   = = trueWhether the entity is active or destroyed. const size_t _id Unique identifier of the entity. const std::string _tag Tag representing the entity's type. std::unique_ptr&lt; BBox &gt; bbox Bounding box component. std::unique_ptr&lt; Health &gt; health Health component. std::unique_ptr&lt; Input &gt; input Input component. std::unique_ptr&lt; Name &gt; name Name component. std::unique_ptr&lt; Score &gt; score Score component. std::unique_ptr&lt; Transform &gt; transform Transform component."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classEntity/#public-functions","title":"Public Functions","text":"Type Name Entity (size_t id, std::string tag) Constructs an entity with a given ID and tag. void destroy () Marks the entity as destroyed."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classEntity/#detailed-description","title":"Detailed Description","text":"<p>Entities serve as building blocks for all game objects. They contain components such as position, health, and input to define their behavior and state. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classEntity/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classEntity/#variable-_alive","title":"variable _alive","text":"<pre><code>bool Entity::_alive;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classEntity/#variable-_id","title":"variable _id","text":"<pre><code>const size_t Entity::_id;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classEntity/#variable-_tag","title":"variable _tag","text":"<pre><code>const std::string Entity::_tag;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classEntity/#variable-bbox","title":"variable bbox","text":"<pre><code>std::unique_ptr&lt;BBox&gt; Entity::bbox;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classEntity/#variable-health","title":"variable health","text":"<pre><code>std::unique_ptr&lt;Health&gt; Entity::health;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classEntity/#variable-input","title":"variable input","text":"<pre><code>std::unique_ptr&lt;Input&gt; Entity::input;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classEntity/#variable-name","title":"variable name","text":"<pre><code>std::unique_ptr&lt;Name&gt; Entity::name;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classEntity/#variable-score","title":"variable score","text":"<pre><code>std::unique_ptr&lt;Score&gt; Entity::score;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classEntity/#variable-transform","title":"variable transform","text":"<pre><code>std::unique_ptr&lt;Transform&gt; Entity::transform;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classEntity/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classEntity/#function-entity","title":"function Entity","text":"<p>Constructs an entity with a given ID and tag. <pre><code>inline Entity::Entity (\n    size_t id,\n    std::string tag\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> The unique ID of the entity. </li> <li><code>tag</code> The tag representing the type of entity. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classEntity/#function-destroy","title":"function destroy","text":"<pre><code>inline void Entity::destroy () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Server/Entity.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameCore/","title":"Class GameUI::GameCore","text":"<p>ClassList &gt; GameUI &gt; GameCore</p> <ul> <li><code>#include &lt;GameCore.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameCore/#public-attributes","title":"Public Attributes","text":"Type Name RoomLobby roomLobby"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameCore/#public-functions","title":"Public Functions","text":"Type Name GameCore ()  void run ()"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameCore/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameCore/#variable-roomlobby","title":"variable roomLobby","text":"<pre><code>RoomLobby GameUI::GameCore::roomLobby;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameCore/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameCore/#function-gamecore","title":"function GameCore","text":"<pre><code>GameUI::GameCore::GameCore () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameCore/#function-run","title":"function run","text":"<pre><code>void GameUI::GameCore::run () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Client/GameCore.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/","title":"Class GameUI::GameLobby","text":"<p>ClassList &gt; GameUI &gt; GameLobby</p> <ul> <li><code>#include &lt;GameLobby.hpp&gt;</code></li> </ul> <p>Inherits the following classes: IScreen</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#public-functions","title":"Public Functions","text":"Type Name GameLobby (ScreenManager &amp; screenManager)  void drawAsteriodFour (sf::RenderWindow &amp; window)  void drawAsteriodOne (sf::RenderWindow &amp; window)  void drawAsteriodThree (sf::RenderWindow &amp; window)  void drawAsteriodTwo (sf::RenderWindow &amp; window)  void drawBackground (sf::RenderWindow &amp; window)  void drawGameLobby (sf::RenderWindow &amp; window)  const sf::Sprite &amp; getAsteriodFourSprite () const const sf::Sprite &amp; getAsteriodOneSprite () const const sf::Sprite &amp; getAsteriodThreeSprite () const const sf::Sprite &amp; getAsteriodTwoSprite () const const sf::Sprite &amp; getBackgroundSprite () const AudioManager &amp; getButtonSound ()  const sf::Sprite &amp; getGameLobbySprite () const MouseManager &amp; getMouse ()  sf::RectangleShape &amp; getRect1 ()  sf::RectangleShape &amp; getRect2 ()  AudioManager &amp; getRoomMusic ()  virtual void handleEvent (sf::Event &amp; event) override void loadFont (const std::string &amp; fontPath)  virtual void render (sf::RenderWindow &amp; window) override bool setAsteriodFour (const std::string &amp; filePath)  bool setAsteriodOne (const std::string &amp; filePath)  bool setAsteriodThree (const std::string &amp; filePath)  bool setAsteriodTwo (const std::string &amp; filePath)  bool setBackground (const std::string &amp; filePath, float windowWidth, float windowHeight)  bool setGameLobby (const std::string &amp; filePath, float windowWidth, float windowHeight)  void shapebuilder (sf::RenderWindow &amp; window)  virtual void update () override"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#public-functions-inherited-from-iscreen","title":"Public Functions inherited from IScreen","text":"<p>See IScreen</p> Type Name virtual void handleEvent (sf::Event &amp; event) = 0 virtual void render (sf::RenderWindow &amp; window) = 0 virtual void update () = 0 virtual ~IScreen () = default"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-gamelobby","title":"function GameLobby","text":"<pre><code>GameUI::GameLobby::GameLobby (\n    ScreenManager &amp; screenManager\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-drawasteriodfour","title":"function drawAsteriodFour","text":"<pre><code>void GameUI::GameLobby::drawAsteriodFour (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-drawasteriodone","title":"function drawAsteriodOne","text":"<pre><code>void GameUI::GameLobby::drawAsteriodOne (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-drawasteriodthree","title":"function drawAsteriodThree","text":"<pre><code>void GameUI::GameLobby::drawAsteriodThree (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-drawasteriodtwo","title":"function drawAsteriodTwo","text":"<pre><code>void GameUI::GameLobby::drawAsteriodTwo (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-drawbackground","title":"function drawBackground","text":"<pre><code>void GameUI::GameLobby::drawBackground (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-drawgamelobby","title":"function drawGameLobby","text":"<pre><code>void GameUI::GameLobby::drawGameLobby (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-getasteriodfoursprite","title":"function getAsteriodFourSprite","text":"<pre><code>const sf::Sprite &amp; GameUI::GameLobby::getAsteriodFourSprite () const\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-getasteriodonesprite","title":"function getAsteriodOneSprite","text":"<pre><code>const sf::Sprite &amp; GameUI::GameLobby::getAsteriodOneSprite () const\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-getasteriodthreesprite","title":"function getAsteriodThreeSprite","text":"<pre><code>const sf::Sprite &amp; GameUI::GameLobby::getAsteriodThreeSprite () const\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-getasteriodtwosprite","title":"function getAsteriodTwoSprite","text":"<pre><code>const sf::Sprite &amp; GameUI::GameLobby::getAsteriodTwoSprite () const\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-getbackgroundsprite","title":"function getBackgroundSprite","text":"<pre><code>const sf::Sprite &amp; GameUI::GameLobby::getBackgroundSprite () const\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-getbuttonsound","title":"function getButtonSound","text":"<pre><code>inline AudioManager &amp; GameUI::GameLobby::getButtonSound () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-getgamelobbysprite","title":"function getGameLobbySprite","text":"<pre><code>const sf::Sprite &amp; GameUI::GameLobby::getGameLobbySprite () const\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-getmouse","title":"function getMouse","text":"<pre><code>inline MouseManager &amp; GameUI::GameLobby::getMouse () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-getrect1","title":"function getRect1","text":"<pre><code>inline sf::RectangleShape &amp; GameUI::GameLobby::getRect1 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-getrect2","title":"function getRect2","text":"<pre><code>inline sf::RectangleShape &amp; GameUI::GameLobby::getRect2 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-getroommusic","title":"function getRoomMusic","text":"<pre><code>inline AudioManager &amp; GameUI::GameLobby::getRoomMusic () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-handleevent","title":"function handleEvent","text":"<pre><code>virtual void GameUI::GameLobby::handleEvent (\n    sf::Event &amp; event\n) override\n</code></pre> <p>Implements IScreen::handleEvent</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-loadfont","title":"function loadFont","text":"<pre><code>void GameUI::GameLobby::loadFont (\n    const std::string &amp; fontPath\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-render","title":"function render","text":"<pre><code>virtual void GameUI::GameLobby::render (\n    sf::RenderWindow &amp; window\n) override\n</code></pre> <p>Implements IScreen::render</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-setasteriodfour","title":"function setAsteriodFour","text":"<pre><code>bool GameUI::GameLobby::setAsteriodFour (\n    const std::string &amp; filePath\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-setasteriodone","title":"function setAsteriodOne","text":"<pre><code>bool GameUI::GameLobby::setAsteriodOne (\n    const std::string &amp; filePath\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-setasteriodthree","title":"function setAsteriodThree","text":"<pre><code>bool GameUI::GameLobby::setAsteriodThree (\n    const std::string &amp; filePath\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-setasteriodtwo","title":"function setAsteriodTwo","text":"<pre><code>bool GameUI::GameLobby::setAsteriodTwo (\n    const std::string &amp; filePath\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-setbackground","title":"function setBackground","text":"<pre><code>bool GameUI::GameLobby::setBackground (\n    const std::string &amp; filePath,\n    float windowWidth,\n    float windowHeight\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-setgamelobby","title":"function setGameLobby","text":"<pre><code>bool GameUI::GameLobby::setGameLobby (\n    const std::string &amp; filePath,\n    float windowWidth,\n    float windowHeight\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-shapebuilder","title":"function shapebuilder","text":"<pre><code>void GameUI::GameLobby::shapebuilder (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameLobby/#function-update","title":"function update","text":"<pre><code>virtual void GameUI::GameLobby::update () override\n</code></pre> <p>Implements IScreen::update</p> <p>The documentation for this class was generated from the following file <code>src/Client/GameLobby.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/","title":"Class GameUI::GamePlay","text":"<p>ClassList &gt; GameUI &gt; GamePlay</p> <ul> <li><code>#include &lt;GamePlay.hpp&gt;</code></li> </ul> <p>Inherits the following classes: IScreen</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#public-attributes","title":"Public Attributes","text":"Type Name bool playIsDown bool playIsLeft bool playIsRight bool playIsUp"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#public-functions","title":"Public Functions","text":"Type Name GamePlay (ScreenManager &amp; screenManager)  void createEnamies5 ()  void createEnamies6 ()  void createEnamies7 ()  void createEnamies8 ()  void createEnamies9 ()  void createEnamiesBoss ()  void createEnemies ()  void createEnemies2 ()  void createEnemies3 ()  void createEnemies4 ()  void createPlayer1 ()  void createPlayer2 ()  void drawBackground (sf::RenderWindow &amp; window)  void drawLifeBoard (sf::RenderWindow &amp; window)  void drawTeamScore (sf::RenderWindow &amp; window)  const sf::Sprite &amp; getBackgroundSprite () const AudioManager &amp; getButtonSound ()  const sf::Sprite &amp; getLifeBoardSprite () const const sf::Sprite &amp; getTeamScoreSprite () const virtual void handleEvent (sf::Event &amp; event) override void loadFont (const std::string &amp; fontPath)  virtual void render (sf::RenderWindow &amp; window) override bool setBackground (const std::string &amp; filePath, float windowWidth, float windowHeight)  bool setLifeBoard (const std::string &amp; filePath, float windowWidth, float windowHeight)  bool setTeamScore (const std::string &amp; filePath, float windowWidth, float windowHeight)  void shapebuilder (sf::RenderWindow &amp; window)  void spawnRandomEnemies ()  virtual void update () override"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#public-functions-inherited-from-iscreen","title":"Public Functions inherited from IScreen","text":"<p>See IScreen</p> Type Name virtual void handleEvent (sf::Event &amp; event) = 0 virtual void render (sf::RenderWindow &amp; window) = 0 virtual void update () = 0 virtual ~IScreen () = default"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#variable-playisdown","title":"variable playIsDown","text":"<pre><code>bool GameUI::GamePlay::playIsDown;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#variable-playisleft","title":"variable playIsLeft","text":"<pre><code>bool GameUI::GamePlay::playIsLeft;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#variable-playisright","title":"variable playIsRight","text":"<pre><code>bool GameUI::GamePlay::playIsRight;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#variable-playisup","title":"variable playIsUp","text":"<pre><code>bool GameUI::GamePlay::playIsUp;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-gameplay","title":"function GamePlay","text":"<pre><code>GameUI::GamePlay::GamePlay (\n    ScreenManager &amp; screenManager\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-createenamies5","title":"function createEnamies5","text":"<pre><code>void GameUI::GamePlay::createEnamies5 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-createenamies6","title":"function createEnamies6","text":"<pre><code>void GameUI::GamePlay::createEnamies6 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-createenamies7","title":"function createEnamies7","text":"<pre><code>void GameUI::GamePlay::createEnamies7 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-createenamies8","title":"function createEnamies8","text":"<pre><code>void GameUI::GamePlay::createEnamies8 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-createenamies9","title":"function createEnamies9","text":"<pre><code>void GameUI::GamePlay::createEnamies9 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-createenamiesboss","title":"function createEnamiesBoss","text":"<pre><code>void GameUI::GamePlay::createEnamiesBoss () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-createenemies","title":"function createEnemies","text":"<pre><code>void GameUI::GamePlay::createEnemies () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-createenemies2","title":"function createEnemies2","text":"<pre><code>void GameUI::GamePlay::createEnemies2 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-createenemies3","title":"function createEnemies3","text":"<pre><code>void GameUI::GamePlay::createEnemies3 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-createenemies4","title":"function createEnemies4","text":"<pre><code>void GameUI::GamePlay::createEnemies4 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-createplayer1","title":"function createPlayer1","text":"<pre><code>void GameUI::GamePlay::createPlayer1 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-createplayer2","title":"function createPlayer2","text":"<pre><code>void GameUI::GamePlay::createPlayer2 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-drawbackground","title":"function drawBackground","text":"<pre><code>void GameUI::GamePlay::drawBackground (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-drawlifeboard","title":"function drawLifeBoard","text":"<pre><code>void GameUI::GamePlay::drawLifeBoard (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-drawteamscore","title":"function drawTeamScore","text":"<pre><code>void GameUI::GamePlay::drawTeamScore (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-getbackgroundsprite","title":"function getBackgroundSprite","text":"<pre><code>const sf::Sprite &amp; GameUI::GamePlay::getBackgroundSprite () const\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-getbuttonsound","title":"function getButtonSound","text":"<pre><code>inline AudioManager &amp; GameUI::GamePlay::getButtonSound () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-getlifeboardsprite","title":"function getLifeBoardSprite","text":"<pre><code>const sf::Sprite &amp; GameUI::GamePlay::getLifeBoardSprite () const\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-getteamscoresprite","title":"function getTeamScoreSprite","text":"<pre><code>const sf::Sprite &amp; GameUI::GamePlay::getTeamScoreSprite () const\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-handleevent","title":"function handleEvent","text":"<pre><code>virtual void GameUI::GamePlay::handleEvent (\n    sf::Event &amp; event\n) override\n</code></pre> <p>Implements IScreen::handleEvent</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-loadfont","title":"function loadFont","text":"<pre><code>void GameUI::GamePlay::loadFont (\n    const std::string &amp; fontPath\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-render","title":"function render","text":"<pre><code>virtual void GameUI::GamePlay::render (\n    sf::RenderWindow &amp; window\n) override\n</code></pre> <p>Implements IScreen::render</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-setbackground","title":"function setBackground","text":"<pre><code>bool GameUI::GamePlay::setBackground (\n    const std::string &amp; filePath,\n    float windowWidth,\n    float windowHeight\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-setlifeboard","title":"function setLifeBoard","text":"<pre><code>bool GameUI::GamePlay::setLifeBoard (\n    const std::string &amp; filePath,\n    float windowWidth,\n    float windowHeight\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-setteamscore","title":"function setTeamScore","text":"<pre><code>bool GameUI::GamePlay::setTeamScore (\n    const std::string &amp; filePath,\n    float windowWidth,\n    float windowHeight\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-shapebuilder","title":"function shapebuilder","text":"<pre><code>void GameUI::GamePlay::shapebuilder (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-spawnrandomenemies","title":"function spawnRandomEnemies","text":"<pre><code>void GameUI::GamePlay::spawnRandomEnemies () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GamePlay/#function-update","title":"function update","text":"<pre><code>virtual void GameUI::GamePlay::update () override\n</code></pre> <p>Implements IScreen::update</p> <p>The documentation for this class was generated from the following file <code>src/Client/GamePlay.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameSetting/","title":"Class GameUI::GameSetting","text":"<p>ClassList &gt; GameUI &gt; GameSetting</p> <ul> <li><code>#include &lt;GameSetting.hpp&gt;</code></li> </ul> <p>Inherits the following classes: IScreen</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameSetting/#public-functions","title":"Public Functions","text":"Type Name GameSetting (ScreenManager &amp; screenManager)  void drawBackground (sf::RenderWindow &amp; window)  void drawGameSetting (sf::RenderWindow &amp; window)  const sf::Sprite &amp; getBackgroundSprite () const AudioManager &amp; getButtonSound ()  const sf::Sprite &amp; getGameSettingSprite () const sf::RectangleShape &amp; getRect1 ()  sf::RectangleShape &amp; getRect2 ()  virtual void handleEvent (sf::Event &amp; event) override void loadFont (const std::string &amp; fontPath)  virtual void render (sf::RenderWindow &amp; window) override bool setBackground (const std::string &amp; filePath, float windowWidth, float windowHeight)  bool setGameSetting (const std::string &amp; filePath, float windowWidth, float windowHeight)  void shapebuilder (sf::RenderWindow &amp; window)  virtual void update () override"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameSetting/#public-functions-inherited-from-iscreen","title":"Public Functions inherited from IScreen","text":"<p>See IScreen</p> Type Name virtual void handleEvent (sf::Event &amp; event) = 0 virtual void render (sf::RenderWindow &amp; window) = 0 virtual void update () = 0 virtual ~IScreen () = default"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameSetting/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameSetting/#function-gamesetting","title":"function GameSetting","text":"<pre><code>GameUI::GameSetting::GameSetting (\n    ScreenManager &amp; screenManager\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameSetting/#function-drawbackground","title":"function drawBackground","text":"<pre><code>void GameUI::GameSetting::drawBackground (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameSetting/#function-drawgamesetting","title":"function drawGameSetting","text":"<pre><code>void GameUI::GameSetting::drawGameSetting (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameSetting/#function-getbackgroundsprite","title":"function getBackgroundSprite","text":"<pre><code>const sf::Sprite &amp; GameUI::GameSetting::getBackgroundSprite () const\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameSetting/#function-getbuttonsound","title":"function getButtonSound","text":"<pre><code>inline AudioManager &amp; GameUI::GameSetting::getButtonSound () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameSetting/#function-getgamesettingsprite","title":"function getGameSettingSprite","text":"<pre><code>const sf::Sprite &amp; GameUI::GameSetting::getGameSettingSprite () const\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameSetting/#function-getrect1","title":"function getRect1","text":"<pre><code>inline sf::RectangleShape &amp; GameUI::GameSetting::getRect1 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameSetting/#function-getrect2","title":"function getRect2","text":"<pre><code>inline sf::RectangleShape &amp; GameUI::GameSetting::getRect2 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameSetting/#function-handleevent","title":"function handleEvent","text":"<pre><code>virtual void GameUI::GameSetting::handleEvent (\n    sf::Event &amp; event\n) override\n</code></pre> <p>Implements IScreen::handleEvent</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameSetting/#function-loadfont","title":"function loadFont","text":"<pre><code>void GameUI::GameSetting::loadFont (\n    const std::string &amp; fontPath\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameSetting/#function-render","title":"function render","text":"<pre><code>virtual void GameUI::GameSetting::render (\n    sf::RenderWindow &amp; window\n) override\n</code></pre> <p>Implements IScreen::render</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameSetting/#function-setbackground","title":"function setBackground","text":"<pre><code>bool GameUI::GameSetting::setBackground (\n    const std::string &amp; filePath,\n    float windowWidth,\n    float windowHeight\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameSetting/#function-setgamesetting","title":"function setGameSetting","text":"<pre><code>bool GameUI::GameSetting::setGameSetting (\n    const std::string &amp; filePath,\n    float windowWidth,\n    float windowHeight\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameSetting/#function-shapebuilder","title":"function shapebuilder","text":"<pre><code>void GameUI::GameSetting::shapebuilder (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1GameSetting/#function-update","title":"function update","text":"<pre><code>virtual void GameUI::GameSetting::update () override\n</code></pre> <p>Implements IScreen::update</p> <p>The documentation for this class was generated from the following file <code>src/Client/GameSetting.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/","title":"Class GameUI::RoomLobby","text":"<p>ClassList &gt; GameUI &gt; RoomLobby</p> <ul> <li><code>#include &lt;RoomLobby.hpp&gt;</code></li> </ul> <p>Inherits the following classes: IScreen</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#public-attributes","title":"Public Attributes","text":"Type Name std::string inputIp std::string inputName std::string inputPort sf::Text textip sf::Text textname sf::Text textport"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#public-functions","title":"Public Functions","text":"Type Name RoomLobby (ScreenManager &amp; screenManager)  void drawBackButton (sf::RenderWindow &amp; window)  void drawBackground (sf::RenderWindow &amp; window)  void drawRoomLobby (sf::RenderWindow &amp; window)  const sf::Sprite &amp; getBackButtonSprite () const const sf::Sprite &amp; getBackgroundSprite () const AudioManager &amp; getButtonSound ()  MouseManager &amp; getMouse ()  sf::RectangleShape &amp; getRect1 ()  sf::RectangleShape &amp; getRect2 ()  sf::RectangleShape &amp; getRect3 ()  sf::RectangleShape &amp; getRect4 ()  const sf::Sprite &amp; getRoomLobbySprite () const sf::Text &amp; getTextIp ()  sf::Text &amp; getTextName ()  sf::Text &amp; getTextPort ()  virtual void handleEvent (sf::Event &amp; event) override void loadFont (const std::string &amp; fontPath)  virtual void render (sf::RenderWindow &amp; window) override bool setBackButton (const std::string &amp; filePath, float windowWidth, float windowHeight)  bool setBackground (const std::string &amp; filePath, float windowWidth, float windowHeight)  bool setRoomLobby (const std::string &amp; filePath, float windowWidth, float windowHeight)  void shapebuilder (sf::RenderWindow &amp; window)  void textfieldsetter (sf::Font &amp; font)  virtual void update () override"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#public-functions-inherited-from-iscreen","title":"Public Functions inherited from IScreen","text":"<p>See IScreen</p> Type Name virtual void handleEvent (sf::Event &amp; event) = 0 virtual void render (sf::RenderWindow &amp; window) = 0 virtual void update () = 0 virtual ~IScreen () = default"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#variable-inputip","title":"variable inputIp","text":"<pre><code>std::string GameUI::RoomLobby::inputIp;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#variable-inputname","title":"variable inputName","text":"<pre><code>std::string GameUI::RoomLobby::inputName;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#variable-inputport","title":"variable inputPort","text":"<pre><code>std::string GameUI::RoomLobby::inputPort;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#variable-textip","title":"variable textip","text":"<pre><code>sf::Text GameUI::RoomLobby::textip;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#variable-textname","title":"variable textname","text":"<pre><code>sf::Text GameUI::RoomLobby::textname;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#variable-textport","title":"variable textport","text":"<pre><code>sf::Text GameUI::RoomLobby::textport;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-roomlobby","title":"function RoomLobby","text":"<pre><code>GameUI::RoomLobby::RoomLobby (\n    ScreenManager &amp; screenManager\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-drawbackbutton","title":"function drawBackButton","text":"<pre><code>void GameUI::RoomLobby::drawBackButton (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-drawbackground","title":"function drawBackground","text":"<pre><code>void GameUI::RoomLobby::drawBackground (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-drawroomlobby","title":"function drawRoomLobby","text":"<pre><code>void GameUI::RoomLobby::drawRoomLobby (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-getbackbuttonsprite","title":"function getBackButtonSprite","text":"<pre><code>const sf::Sprite &amp; GameUI::RoomLobby::getBackButtonSprite () const\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-getbackgroundsprite","title":"function getBackgroundSprite","text":"<pre><code>const sf::Sprite &amp; GameUI::RoomLobby::getBackgroundSprite () const\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-getbuttonsound","title":"function getButtonSound","text":"<pre><code>inline AudioManager &amp; GameUI::RoomLobby::getButtonSound () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-getmouse","title":"function getMouse","text":"<pre><code>inline MouseManager &amp; GameUI::RoomLobby::getMouse () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-getrect1","title":"function getRect1","text":"<pre><code>inline sf::RectangleShape &amp; GameUI::RoomLobby::getRect1 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-getrect2","title":"function getRect2","text":"<pre><code>inline sf::RectangleShape &amp; GameUI::RoomLobby::getRect2 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-getrect3","title":"function getRect3","text":"<pre><code>inline sf::RectangleShape &amp; GameUI::RoomLobby::getRect3 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-getrect4","title":"function getRect4","text":"<pre><code>inline sf::RectangleShape &amp; GameUI::RoomLobby::getRect4 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-getroomlobbysprite","title":"function getRoomLobbySprite","text":"<pre><code>const sf::Sprite &amp; GameUI::RoomLobby::getRoomLobbySprite () const\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-gettextip","title":"function getTextIp","text":"<pre><code>inline sf::Text &amp; GameUI::RoomLobby::getTextIp () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-gettextname","title":"function getTextName","text":"<pre><code>inline sf::Text &amp; GameUI::RoomLobby::getTextName () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-gettextport","title":"function getTextPort","text":"<pre><code>inline sf::Text &amp; GameUI::RoomLobby::getTextPort () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-handleevent","title":"function handleEvent","text":"<pre><code>virtual void GameUI::RoomLobby::handleEvent (\n    sf::Event &amp; event\n) override\n</code></pre> <p>Implements IScreen::handleEvent</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-loadfont","title":"function loadFont","text":"<pre><code>void GameUI::RoomLobby::loadFont (\n    const std::string &amp; fontPath\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-render","title":"function render","text":"<pre><code>virtual void GameUI::RoomLobby::render (\n    sf::RenderWindow &amp; window\n) override\n</code></pre> <p>Implements IScreen::render</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-setbackbutton","title":"function setBackButton","text":"<pre><code>bool GameUI::RoomLobby::setBackButton (\n    const std::string &amp; filePath,\n    float windowWidth,\n    float windowHeight\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-setbackground","title":"function setBackground","text":"<pre><code>bool GameUI::RoomLobby::setBackground (\n    const std::string &amp; filePath,\n    float windowWidth,\n    float windowHeight\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-setroomlobby","title":"function setRoomLobby","text":"<pre><code>bool GameUI::RoomLobby::setRoomLobby (\n    const std::string &amp; filePath,\n    float windowWidth,\n    float windowHeight\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-shapebuilder","title":"function shapebuilder","text":"<pre><code>void GameUI::RoomLobby::shapebuilder (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-textfieldsetter","title":"function textfieldsetter","text":"<pre><code>void GameUI::RoomLobby::textfieldsetter (\n    sf::Font &amp; font\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1RoomLobby/#function-update","title":"function update","text":"<pre><code>virtual void GameUI::RoomLobby::update () override\n</code></pre> <p>Implements IScreen::update</p> <p>The documentation for this class was generated from the following file <code>src/Client/RoomLobby.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1ScreenManager/","title":"Class GameUI::ScreenManager","text":"<p>ClassList &gt; GameUI &gt; ScreenManager</p> <ul> <li><code>#include &lt;ScreenManager.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1ScreenManager/#public-attributes","title":"Public Attributes","text":"Type Name Client client"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1ScreenManager/#public-functions","title":"Public Functions","text":"Type Name ScreenManager (sf::RenderWindow &amp; window)  void addScreen (const std::string &amp; name, std::function&lt; std::unique_ptr&lt; T &gt;()&gt; factory)  void handleEvent (sf::Event &amp; event)  void render ()  void switchToScreen (const std::string &amp; name)  void update ()"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1ScreenManager/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1ScreenManager/#variable-client","title":"variable client","text":"<pre><code>Client GameUI::ScreenManager::client;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1ScreenManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1ScreenManager/#function-screenmanager","title":"function ScreenManager","text":"<pre><code>GameUI::ScreenManager::ScreenManager (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1ScreenManager/#function-addscreen","title":"function addScreen","text":"<pre><code>template&lt;typename T&gt;\ninline void GameUI::ScreenManager::addScreen (\n    const std::string &amp; name,\n    std::function&lt; std::unique_ptr&lt; T &gt;()&gt; factory\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1ScreenManager/#function-handleevent","title":"function handleEvent","text":"<pre><code>void GameUI::ScreenManager::handleEvent (\n    sf::Event &amp; event\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1ScreenManager/#function-render","title":"function render","text":"<pre><code>void GameUI::ScreenManager::render () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1ScreenManager/#function-switchtoscreen","title":"function switchToScreen","text":"<pre><code>void GameUI::ScreenManager::switchToScreen (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classGameUI_1_1ScreenManager/#function-update","title":"function update","text":"<pre><code>void GameUI::ScreenManager::update () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Client/ScreenManager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classHealth/","title":"Class Health","text":"<p>ClassList &gt; Health</p> <p>Component to manage an entity's health state. More...</p> <ul> <li><code>#include &lt;Entity.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classHealth/#public-attributes","title":"Public Attributes","text":"Type Name int currentHealth Current health of the entity. int maxHealth Maximum health of the entity."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classHealth/#public-functions","title":"Public Functions","text":"Type Name Health () Default constructor initializes health to 0. Health (int maxHp) Constructor to initialize the entity's health. void takeDamage (int damage) Reduces the current health by a specified amount."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classHealth/#detailed-description","title":"Detailed Description","text":"<p>This component tracks both the maximum and current health of an entity. It is used to handle damage, healing, and health-based logic during gameplay. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classHealth/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classHealth/#variable-currenthealth","title":"variable currentHealth","text":"<pre><code>int Health::currentHealth;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classHealth/#variable-maxhealth","title":"variable maxHealth","text":"<pre><code>int Health::maxHealth;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classHealth/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classHealth/#function-health-12","title":"function Health [1/2]","text":"<pre><code>inline Health::Health () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classHealth/#function-health-22","title":"function Health [2/2]","text":"<p>Constructor to initialize the entity's health. <pre><code>inline Health::Health (\n    int maxHp\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>maxHp</code> Maximum health of the entity. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classHealth/#function-takedamage","title":"function takeDamage","text":"<p>Reduces the current health by a specified amount. <pre><code>inline void Health::takeDamage (\n    int damage\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>damage</code> The amount of health to reduce. </li> </ul> <p>Note:</p> <p>The health will not drop below 0. </p> <p>The documentation for this class was generated from the following file <code>include/Server/Entity.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classHealthSystem/","title":"Class HealthSystem","text":"<p>ClassList &gt; HealthSystem</p> <p>Forward declaration of the Registry class.More...</p> <ul> <li><code>#include &lt;Health_system.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classHealthSystem/#public-functions","title":"Public Functions","text":"Type Name void checkHealth (Registry &amp; registry) Checks and updates the health status of entities in the registry."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classHealthSystem/#detailed-description","title":"Detailed Description","text":"<p>The HealthSystem class handles the logic related to the health status of entities within the game. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classHealthSystem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classHealthSystem/#function-checkhealth","title":"function checkHealth","text":"<p>Checks and updates the health status of entities in the registry. <pre><code>void HealthSystem::checkHealth (\n    Registry &amp; registry\n) \n</code></pre></p> <p>This function iterates through relevant entities and performs health-related operations, such as verifying if the entities are still alive, applying health changes, or marking entities for removal if their health reaches zero.</p> <p>Parameters:</p> <ul> <li><code>registry</code> Reference to the Registry instance containing the entities to process. </li> </ul> <p>The documentation for this class was generated from the following file <code>include/Server/Health_system.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classIScreen/","title":"Class IScreen","text":"<p>ClassList &gt; IScreen</p> <ul> <li><code>#include &lt;ScreenManager.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: GameUI::GameLobby,  GameUI::GamePlay,  GameUI::GameSetting,  GameUI::RoomLobby</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classIScreen/#public-functions","title":"Public Functions","text":"Type Name virtual void handleEvent (sf::Event &amp; event) = 0 virtual void render (sf::RenderWindow &amp; window) = 0 virtual void update () = 0 virtual ~IScreen () = default"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classIScreen/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classIScreen/#function-handleevent","title":"function handleEvent","text":"<pre><code>virtual void IScreen::handleEvent (\n    sf::Event &amp; event\n) = 0\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classIScreen/#function-render","title":"function render","text":"<pre><code>virtual void IScreen::render (\n    sf::RenderWindow &amp; window\n) = 0\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classIScreen/#function-update","title":"function update","text":"<pre><code>virtual void IScreen::update () = 0\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classIScreen/#function-iscreen","title":"function ~IScreen","text":"<pre><code>virtual IScreen::~IScreen () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Client/ScreenManager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classImageManager/","title":"Class ImageManager","text":"<p>ClassList &gt; ImageManager</p> <p>Handles image loading, manipulation, and rendering using the SFML graphics library. More...</p> <ul> <li><code>#include &lt;ImageManager.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classImageManager/#public-attributes","title":"Public Attributes","text":"Type Name sf::Texture texture Texture object for storing the image data."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classImageManager/#public-functions","title":"Public Functions","text":"Type Name ImageManager () Constructs an ImageManager instance. bool createImage (const std::string &amp; filePath) Loads an image from the specified file path. void destroyImage () Destroys the image and releases its resources. void draw (sf::RenderWindow &amp; window) Draws the image sprite to the specified render window. void fitToScreen (float windowWidth, float windowHeight)  sf::FloatRect getGlobalBounds () Gets the global bounding rectangle of the sprite. sf::Sprite &amp; getSprite () Sprite object for rendering the image. const sf::Sprite &amp; getSprite () const void setPosition (float x, float y) Sets the position of the sprite on the screen. void setScale (float scaleX, float scaleY) Sets the scale of the image sprite. ~ImageManager () Destructs the ImageManager instance."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classImageManager/#detailed-description","title":"Detailed Description","text":"<p>The ImageManager class provides a set of methods to manage and display 2D images using SFML. It supports loading images from files, positioning, scaling, and drawing them on the screen via an sf::RenderWindow.</p> <p>Note:</p> <p>ImageManager assumes the image resources are properly initialized, and the paths provided are valid image file formats supported by SFML. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classImageManager/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classImageManager/#variable-texture","title":"variable texture","text":"<p>Texture object for storing the image data. <pre><code>sf::Texture ImageManager::texture;\n</code></pre></p> <p>The sf::Texture object holds the image data loaded from a file, which is applied to the sprite for rendering. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classImageManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classImageManager/#function-imagemanager","title":"function ImageManager","text":"<p>Constructs an ImageManager instance. <pre><code>ImageManager::ImageManager () \n</code></pre></p> <p>Initializes the ImageManager to handle image loading and rendering. This constructor prepares the necessary objects for managing images. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classImageManager/#function-createimage","title":"function createImage","text":"<p>Loads an image from the specified file path. <pre><code>bool ImageManager::createImage (\n    const std::string &amp; filePath\n) \n</code></pre></p> <p>Loads an image into an sf::Texture object from the provided file path and applies it to an sf::Sprite for rendering.</p> <p>Parameters:</p> <ul> <li><code>filePath</code> A string representing the file path of the image. </li> </ul> <p>Returns:</p> <p>Returns true if the image is successfully loaded, false otherwise. </p> <p>Exception:</p> <ul> <li><code>std::runtime_error</code> if the image file cannot be loaded.</li> </ul> <p>Note:</p> <p>Supported image formats include PNG, JPEG, and BMP. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classImageManager/#function-destroyimage","title":"function destroyImage","text":"<p>Destroys the image and releases its resources. <pre><code>void ImageManager::destroyImage () \n</code></pre></p> <p>Cleans up the loaded image and resets the texture and sprite. This is useful for freeing up memory when the image is no longer needed. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classImageManager/#function-draw","title":"function draw","text":"<p>Draws the image sprite to the specified render window. <pre><code>void ImageManager::draw (\n    sf::RenderWindow &amp; window\n) \n</code></pre></p> <p>Renders the sprite on the provided sf::RenderWindow.</p> <p>Parameters:</p> <ul> <li><code>window</code> A reference to the sf::RenderWindow where the sprite will be drawn. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classImageManager/#function-fittoscreen","title":"function fitToScreen","text":"<pre><code>void ImageManager::fitToScreen (\n    float windowWidth,\n    float windowHeight\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classImageManager/#function-getglobalbounds","title":"function getGlobalBounds","text":"<p>Gets the global bounding rectangle of the sprite. <pre><code>sf::FloatRect ImageManager::getGlobalBounds () \n</code></pre></p> <p>Retrieves the boundaries of the sprite in global coordinates, which can be used for collision detection or aligning sprites.</p> <p>Returns:</p> <p>An sf::FloatRect object representing the global bounding box of the sprite. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classImageManager/#function-getsprite-12","title":"function getSprite [1/2]","text":"<p>Sprite object for rendering the image. <pre><code>inline sf::Sprite &amp; ImageManager::getSprite () \n</code></pre></p> <p>The sf::Sprite object is used to display the image stored in the texture. It supports transformations such as scaling, rotation, and translation. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classImageManager/#function-getsprite-22","title":"function getSprite [2/2]","text":"<pre><code>inline const sf::Sprite &amp; ImageManager::getSprite () const\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classImageManager/#function-setposition","title":"function setPosition","text":"<p>Sets the position of the sprite on the screen. <pre><code>void ImageManager::setPosition (\n    float x,\n    float y\n) \n</code></pre></p> <p>Adjusts the position of the image sprite to the specified x and y coordinates within the window.</p> <p>Parameters:</p> <ul> <li><code>x</code> A float representing the x-coordinate of the new position. </li> <li><code>y</code> A float representing the y-coordinate of the new position. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classImageManager/#function-setscale","title":"function setScale","text":"<p>Sets the scale of the image sprite. <pre><code>void ImageManager::setScale (\n    float scaleX,\n    float scaleY\n) \n</code></pre></p> <p>Resizes the image sprite by setting its scale factors along the x and y axes.</p> <p>Parameters:</p> <ul> <li><code>scaleX</code> A float representing the scaling factor along the x-axis. </li> <li><code>scaleY</code> A float representing the scaling factor along the y-axis. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classImageManager/#function-imagemanager_1","title":"function ~ImageManager","text":"<p>Destructs the ImageManager instance. <pre><code>ImageManager::~ImageManager () \n</code></pre></p> <p>Cleans up any resources used for image handling and rendering, ensuring proper memory deallocation and resource management. </p> <p>The documentation for this class was generated from the following file <code>include/Engine/Image/ImageManager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInput/","title":"Class Input","text":"<p>ClassList &gt; Input</p> <p>Component to track player input actions (e.g., movement or shooting). More...</p> <ul> <li><code>#include &lt;Entity.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInput/#public-attributes","title":"Public Attributes","text":"Type Name bool down Whether the 'down' key is pressed. bool left Whether the 'left' key is pressed. bool right Whether the 'right' key is pressed. bool shoot Whether the 'shoot' action is performed. bool up Whether the 'up' key is pressed."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInput/#public-functions","title":"Public Functions","text":"Type Name Input () Default constructor initializes all input actions to false. void reset () Resets all input actions to false."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInput/#detailed-description","title":"Detailed Description","text":"<p>This component helps manage input events such as pressing keys or performing actions. It is typically associated with player-controlled entities. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInput/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInput/#variable-down","title":"variable down","text":"<pre><code>bool Input::down;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInput/#variable-left","title":"variable left","text":"<pre><code>bool Input::left;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInput/#variable-right","title":"variable right","text":"<pre><code>bool Input::right;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInput/#variable-shoot","title":"variable shoot","text":"<pre><code>bool Input::shoot;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInput/#variable-up","title":"variable up","text":"<pre><code>bool Input::up;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInput/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInput/#function-input","title":"function Input","text":"<pre><code>inline Input::Input () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInput/#function-reset","title":"function reset","text":"<pre><code>inline void Input::reset () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Server/Entity.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInputManager/","title":"Class InputManager","text":"<p>ClassList &gt; InputManager</p> <p>Manages keyboard and window input events using the SFML library. More...</p> <ul> <li><code>#include &lt;InputManager.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInputManager/#public-functions","title":"Public Functions","text":"Type Name InputManager () Constructs an InputManager instance. Button getButton (void) constRetrieves the current button states. void handleInput (sf::Event event, sf::RenderWindow &amp; window) Handles input events from the window. ~InputManager () Destructs the InputManager instance."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInputManager/#detailed-description","title":"Detailed Description","text":"<p>The InputManager class is responsible for handling user input, including keyboard events and window-related events (e.g., closing the window). It provides an interface to track specific key presses and allows easy retrieval of button states. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInputManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInputManager/#function-inputmanager","title":"function InputManager","text":"<p>Constructs an InputManager instance. <pre><code>InputManager::InputManager () \n</code></pre></p> <p>Initializes the InputManager and sets up the internal button state. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInputManager/#function-getbutton","title":"function getButton","text":"<p>Retrieves the current button states. <pre><code>Button InputManager::getButton (\n    void\n) const\n</code></pre></p> <p>Returns a copy of the Button structure containing the current states of all tracked buttons.</p> <p>Returns:</p> <p>A Button struct with the state of the control buttons. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInputManager/#function-handleinput","title":"function handleInput","text":"<p>Handles input events from the window. <pre><code>void InputManager::handleInput (\n    sf::Event event,\n    sf::RenderWindow &amp; window\n) \n</code></pre></p> <p>Processes the given SFML event and updates the internal button states based on key presses or releases. It also handles window-specific events such as closing.</p> <p>Parameters:</p> <ul> <li><code>event</code> The SFML event to process (e.g., key press or release). </li> <li><code>window</code> The SFML render window where the event is coming from. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classInputManager/#function-inputmanager_1","title":"function ~InputManager","text":"<p>Destructs the InputManager instance. <pre><code>InputManager::~InputManager () \n</code></pre></p> <p>Cleans up any resources used for input handling. Since no dynamic memory is allocated, this primarily exists for completeness. </p> <p>The documentation for this class was generated from the following file <code>include/Engine/Input/InputManager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMenu/","title":"Class Menu","text":"<p>ClassList &gt; Menu</p> <ul> <li><code>#include &lt;Menu.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMenu/#public-functions","title":"Public Functions","text":"Type Name Menu ()  void drawBackground (sf::RenderWindow &amp; window)  void drawGameLobby (sf::RenderWindow &amp; window)  const sf::Sprite &amp; getBackgroundSprite () const const sf::Sprite &amp; getGameLobbySprite () const const sf::Sprite &amp; getPlayButtonSprite () const sf::RectangleShape &amp; getRect1 ()  sf::RectangleShape &amp; getRect2 ()  void run ()  bool setBackground (const std::string &amp; filePath, float windowWidth, float windowHeight)"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMenu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMenu/#function-menu","title":"function Menu","text":"<pre><code>Menu::Menu () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMenu/#function-drawbackground","title":"function drawBackground","text":"<pre><code>inline void Menu::drawBackground (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMenu/#function-drawgamelobby","title":"function drawGameLobby","text":"<pre><code>void Menu::drawGameLobby (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMenu/#function-getbackgroundsprite","title":"function getBackgroundSprite","text":"<pre><code>inline const sf::Sprite &amp; Menu::getBackgroundSprite () const\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMenu/#function-getgamelobbysprite","title":"function getGameLobbySprite","text":"<pre><code>inline const sf::Sprite &amp; Menu::getGameLobbySprite () const\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMenu/#function-getplaybuttonsprite","title":"function getPlayButtonSprite","text":"<pre><code>const sf::Sprite &amp; Menu::getPlayButtonSprite () const\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMenu/#function-getrect1","title":"function getRect1","text":"<pre><code>inline sf::RectangleShape &amp; Menu::getRect1 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMenu/#function-getrect2","title":"function getRect2","text":"<pre><code>inline sf::RectangleShape &amp; Menu::getRect2 () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMenu/#function-run","title":"function run","text":"<pre><code>void Menu::run () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMenu/#function-setbackground","title":"function setBackground","text":"<pre><code>inline bool Menu::setBackground (\n    const std::string &amp; filePath,\n    float windowWidth,\n    float windowHeight\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Client/Save/Menu.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMouseManager/","title":"Class MouseManager","text":"<p>ClassList &gt; MouseManager</p> <p>Manages mouse input and tracks the mouse position within a window. More...</p> <ul> <li><code>#include &lt;MouseManager.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMouseManager/#public-functions","title":"Public Functions","text":"Type Name MouseManager () Constructs a MouseManager instance. float getMouseX () constRetrieves the current X coordinate of the mouse. float getMouseY () constRetrieves the current Y coordinate of the mouse. void handleMousePosition (sf::RenderWindow &amp; window) Updates the mouse position within the given window. ~MouseManager () Destructs the MouseManager instance."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMouseManager/#detailed-description","title":"Detailed Description","text":"<p>The MouseManager class provides functionality to track the mouse's position within an SFML render window. It retrieves and stores the current mouse coordinates (x, y) in real-time and provides access to these coordinates for further use. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMouseManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMouseManager/#function-mousemanager","title":"function MouseManager","text":"<p>Constructs a MouseManager instance. <pre><code>MouseManager::MouseManager () \n</code></pre></p> <p>Initializes the MouseManager, setting the initial mouse coordinates to zero. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMouseManager/#function-getmousex","title":"function getMouseX","text":"<p>Retrieves the current X coordinate of the mouse. <pre><code>float MouseManager::getMouseX () const\n</code></pre></p> <p>Returns the stored horizontal mouse position relative to the window.</p> <p>Returns:</p> <p>A float representing the current X coordinate of the mouse. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMouseManager/#function-getmousey","title":"function getMouseY","text":"<p>Retrieves the current Y coordinate of the mouse. <pre><code>float MouseManager::getMouseY () const\n</code></pre></p> <p>Returns the stored vertical mouse position relative to the window.</p> <p>Returns:</p> <p>A float representing the current Y coordinate of the mouse. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMouseManager/#function-handlemouseposition","title":"function handleMousePosition","text":"<p>Updates the mouse position within the given window. <pre><code>void MouseManager::handleMousePosition (\n    sf::RenderWindow &amp; window\n) \n</code></pre></p> <p>Retrieves the current position of the mouse relative to the provided SFML window and updates the internal x and y values accordingly.</p> <p>Parameters:</p> <ul> <li><code>window</code> The SFML render window from which the mouse position is retrieved. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMouseManager/#function-mousemanager_1","title":"function ~MouseManager","text":"<p>Destructs the MouseManager instance. <pre><code>MouseManager::~MouseManager () \n</code></pre></p> <p>Cleans up any resources used for mouse input handling. Since no dynamic memory is allocated, this primarily exists for completeness. </p> <p>The documentation for this class was generated from the following file <code>include/Engine/Mouse/MouseManager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMouvementSystem/","title":"Class MouvementSystem","text":"<p>ClassList &gt; MouvementSystem</p> <p>Forward declaration of the Registry class.More...</p> <ul> <li><code>#include &lt;Mouvement_system.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMouvementSystem/#public-functions","title":"Public Functions","text":"Type Name MouvementSystem () Default constructor. Vector2D enemy_move (Registry &amp; registry) Moves enemy entities and returns the new position. void handleInput (Registry &amp; registry, std::string move_direction, std::string name) Processes player input to trigger movement in a specific direction. Vector2D move_player (Registry &amp; registry, std::string name) Moves a player based on their input and updates their position. void system_movement (EntityVector &amp; entities) Applies movement logic to a vector of entities. ~MouvementSystem () Destructor."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMouvementSystem/#detailed-description","title":"Detailed Description","text":"<p>The MouvementSystem class handles all movement logic for players, enemies, and other entities in the game. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMouvementSystem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMouvementSystem/#function-mouvementsystem","title":"function MouvementSystem","text":"<pre><code>inline MouvementSystem::MouvementSystem () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMouvementSystem/#function-enemy_move","title":"function enemy_move","text":"<p>Moves enemy entities and returns the new position. <pre><code>Vector2D MouvementSystem::enemy_move (\n    Registry &amp; registry\n) \n</code></pre></p> <p>This method handles logic for enemy movement, potentially including AI behavior.</p> <p>Parameters:</p> <ul> <li><code>registry</code> Reference to the Registry containing all entities. </li> </ul> <p>Returns:</p> <p>The new position of the enemy as a Vector2D. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMouvementSystem/#function-handleinput","title":"function handleInput","text":"<p>Processes player input to trigger movement in a specific direction. <pre><code>void MouvementSystem::handleInput (\n    Registry &amp; registry,\n    std::string move_direction,\n    std::string name\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>registry</code> Reference to the Registry containing all entities. </li> <li><code>move_direction</code> The direction of movement (\"up\", \"down\", \"left\", or \"right\"). </li> <li><code>name</code> The name of the player whose movement is being handled. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMouvementSystem/#function-move_player","title":"function move_player","text":"<p>Moves a player based on their input and updates their position. <pre><code>Vector2D MouvementSystem::move_player (\n    Registry &amp; registry,\n    std::string name\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>registry</code> Reference to the Registry containing all entities. </li> <li><code>name</code> The name of the player to move. </li> </ul> <p>Returns:</p> <p>The updated position of the player as a Vector2D. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMouvementSystem/#function-system_movement","title":"function system_movement","text":"<p>Applies movement logic to a vector of entities. <pre><code>void MouvementSystem::system_movement (\n    EntityVector &amp; entities\n) \n</code></pre></p> <p>This method iterates through a list of entities, updating their positions based on their velocity and other factors.</p> <p>Parameters:</p> <ul> <li><code>entities</code> A reference to the vector of entities to process. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classMouvementSystem/#function-mouvementsystem_1","title":"function ~MouvementSystem","text":"<pre><code>inline MouvementSystem::~MouvementSystem () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Server/Mouvement_system.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/className/","title":"Class Name","text":"<p>ClassList &gt; Name</p> <p>Component to store the name of an entity. More...</p> <ul> <li><code>#include &lt;Entity.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/className/#public-attributes","title":"Public Attributes","text":"Type Name std::string name Name of the entity."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/className/#public-functions","title":"Public Functions","text":"Type Name Name () Default constructor initializes the name to an empty string. Name (std::string n) Constructor to set the name of the entity."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/className/#detailed-description","title":"Detailed Description","text":"<p>This component is useful for distinguishing players, enemies, or specific in-game objects based on their names. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/className/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/className/#variable-name","title":"variable name","text":"<pre><code>std::string Name::name;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/className/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/className/#function-name-12","title":"function Name [1/2]","text":"<pre><code>inline Name::Name () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/className/#function-name-22","title":"function Name [2/2]","text":"<p>Constructor to set the name of the entity. <pre><code>inline Name::Name (\n    std::string n\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>n</code> The name of the entity. </li> </ul> <p>The documentation for this class was generated from the following file <code>include/Server/Entity.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classParallax/","title":"Class Parallax","text":"<p>ClassList &gt; Parallax</p> <ul> <li><code>#include &lt;parallax.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classParallax/#public-functions","title":"Public Functions","text":"Type Name Parallax (const std::string &amp; file1, const std::string &amp; file2, float speed1, float speed2)  void draw (sf::RenderWindow &amp; window)  void update (float deltaTime)"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classParallax/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classParallax/#function-parallax","title":"function Parallax","text":"<pre><code>Parallax::Parallax (\n    const std::string &amp; file1,\n    const std::string &amp; file2,\n    float speed1,\n    float speed2\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classParallax/#function-draw","title":"function draw","text":"<pre><code>void Parallax::draw (\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classParallax/#function-update","title":"function update","text":"<pre><code>void Parallax::update (\n    float deltaTime\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Engine/Parallax/parallax.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classRegistry/","title":"Class Registry","text":"<p>ClassList &gt; Registry</p> <p>Manages all entities in the game and their lifecycle. More...</p> <ul> <li><code>#include &lt;Entity.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classRegistry/#public-functions","title":"Public Functions","text":"Type Name std::shared_ptr&lt; Entity &gt; add_entity (const std::string tag) Adds a new entity with the given tag. EntityVector &amp; get_entities (const std::string tag) Retrieves entities by tag. void remove_entity (const size_t id) Removes an entity from the registry by ID."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classRegistry/#detailed-description","title":"Detailed Description","text":"<p>The registry is responsible for creating, updating, and removing entities. It provides mechanisms to access entities by tag or ID and spawn new ones dynamically. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classRegistry/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classRegistry/#function-add_entity","title":"function add_entity","text":"<p>Adds a new entity with the given tag. <pre><code>std::shared_ptr&lt; Entity &gt; Registry::add_entity (\n    const std::string tag\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tag</code> The tag representing the entity type. </li> </ul> <p>Returns:</p> <p>A shared pointer to the newly created entity. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classRegistry/#function-get_entities","title":"function get_entities","text":"<p>Retrieves entities by tag. <pre><code>EntityVector &amp; Registry::get_entities (\n    const std::string tag\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>tag</code> The tag to filter entities. </li> </ul> <p>Returns:</p> <p>Reference to the vector of entities matching the tag. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classRegistry/#function-remove_entity","title":"function remove_entity","text":"<p>Removes an entity from the registry by ID. <pre><code>void Registry::remove_entity (\n    const size_t id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>id</code> The unique ID of the entity to remove. </li> </ul> <p>The documentation for this class was generated from the following file <code>include/Server/Entity.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classRoom__System/","title":"Class Room_System","text":"<p>ClassList &gt; Room_System</p> <p>Class responsible for managing game rooms. </p> <ul> <li><code>#include &lt;room_system.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classRoom__System/#public-functions","title":"Public Functions","text":"Type Name Room_System () Constructor for Room_System . int create_room (const std::string &amp; room_name, int max_players) Creates a new room. bool join_room (int room_id, const std::string &amp; player_name) Allows a player to join an existing room. void leave_room (int room_id, const std::string &amp; player_name) Allows a player to leave a room. std::vector&lt; std::string &gt; list_available_rooms () constLists all available rooms. void remove_room (int room_id) Removes a room. void start_game_in_room (int room_id) Starts a game in the specified room. ~Room_System () Destructor for Room_System ."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classRoom__System/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classRoom__System/#function-room_system","title":"function Room_System","text":"<pre><code>Room_System::Room_System () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classRoom__System/#function-create_room","title":"function create_room","text":"<p>Creates a new room. <pre><code>int Room_System::create_room (\n    const std::string &amp; room_name,\n    int max_players\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>room_name</code> The name of the room to create. </li> <li><code>max_players</code> The maximum number of players allowed in the room. </li> </ul> <p>Returns:</p> <p>An integer representing the room ID of the newly created room. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classRoom__System/#function-join_room","title":"function join_room","text":"<p>Allows a player to join an existing room. <pre><code>bool Room_System::join_room (\n    int room_id,\n    const std::string &amp; player_name\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>room_id</code> The ID of the room to join. </li> <li><code>player_name</code> The name of the player joining the room. </li> </ul> <p>Returns:</p> <p>true if the player successfully joined the room, false otherwise. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classRoom__System/#function-leave_room","title":"function leave_room","text":"<p>Allows a player to leave a room. <pre><code>void Room_System::leave_room (\n    int room_id,\n    const std::string &amp; player_name\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>room_id</code> The ID of the room to leave. </li> <li><code>player_name</code> The name of the player leaving the room. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classRoom__System/#function-list_available_rooms","title":"function list_available_rooms","text":"<p>Lists all available rooms. <pre><code>std::vector&lt; std::string &gt; Room_System::list_available_rooms () const\n</code></pre></p> <p>Returns:</p> <p>A vector of strings containing the names of available rooms. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classRoom__System/#function-remove_room","title":"function remove_room","text":"<p>Removes a room. <pre><code>void Room_System::remove_room (\n    int room_id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>room_id</code> The ID of the room to remove. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classRoom__System/#function-start_game_in_room","title":"function start_game_in_room","text":"<p>Starts a game in the specified room. <pre><code>void Room_System::start_game_in_room (\n    int room_id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>room_id</code> The ID of the room where the game should start. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classRoom__System/#function-room_system_1","title":"function ~Room_System","text":"<pre><code>Room_System::~Room_System () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Server/room_system.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classScore/","title":"Class Score","text":"<p>ClassList &gt; Score</p> <p>Component to manage an entity's score during gameplay. More...</p> <ul> <li><code>#include &lt;Entity.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classScore/#public-functions","title":"Public Functions","text":"Type Name Score () Default constructor initializes the score to 0. int getScore () constRetrieves the current score value. void set_score (int new_score) Adds points to the current score."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classScore/#detailed-description","title":"Detailed Description","text":"<p>The score component is used to track points earned by entities. It supports incrementing the score and retrieving the current value. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classScore/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classScore/#function-score","title":"function Score","text":"<pre><code>inline Score::Score () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classScore/#function-getscore","title":"function getScore","text":"<p>Retrieves the current score value. <pre><code>inline int Score::getScore () const\n</code></pre></p> <p>Returns:</p> <p>The current score of the entity. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classScore/#function-set_score","title":"function set_score","text":"<p>Adds points to the current score. <pre><code>inline void Score::set_score (\n    int new_score\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>new_score</code> The number of points to add. </li> </ul> <p>The documentation for this class was generated from the following file <code>include/Server/Entity.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/","title":"Class Server","text":"<p>ClassList &gt; Server</p> <p>A class representing the server managing TCP/UDP connections and game state. More...</p> <ul> <li><code>#include &lt;Server.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; udp::endpoint &gt; _connected_clients A list of connected clients. boost::asio::steady_timer _game_time_manager Timer to manage game-related events. std::string _name The name of the player. TimeManager coinTimer Timer to manage coin spawning. u_int16_t coin_count   = = 0Number of active coins. CollisionSystem collision System to handle collision detection. TimeManager enemyTimer Timer to manage enemy spawning and actions. u_int16_t enemy_count   = = 0Number of active enemies. bool game_run   = = falseFlag to track if the game is running. std::vector&lt; std::pair&lt; udp::endpoint, std::string &gt; &gt; id_name A vector of connected client IDs and their names. MouvementSystem movement System to handle player and object movement. u_int16_t players_count   = = 0Number of connected players. u_int16_t projectile_count   = = 0Number of active projectiles. Registry registry Registry to manage entities and components. ShootSystem shoot System to handle projectile shooting. TimeManager shootTimer Timer to manage shooting actions. TimeManager updateTimer Timer to manage game updates."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#public-functions","title":"Public Functions","text":"Type Name Server (boost::asio::io_context &amp; io_context, server_t server_me) Constructs a new Server object. void check_player_message (udp::socket &amp; socket, const std::vector&lt; uint8_t &gt; &amp; buffer, const udp::endpoint &amp; client_endpoint) Verifies and processes a player's incoming message. void check_player_position (udp::socket &amp; socket, const std::vector&lt; uint8_t &gt; &amp; buffer, const udp::endpoint &amp; client_endpoint) Checks and updates the player's position. Entity &amp; get_player_entity (const std::string &amp; player_name) Retrieves the entity representing the player based on their name. int get_player_id (const udp::endpoint &amp; client_endpoint) Retrieves the player's ID based on their endpoint. std::string get_player_name (const udp::endpoint &amp; client_endpoint) Retrieves the player's name based on their endpoint. void handle_client_ping (const udp::endpoint &amp; client_endpoint) Handles a ping message from a client to update the last communication time. void handle_list_rooms (udp::socket &amp; socket, const udp::endpoint &amp; client_endpoint) Handles a client's request to list all available rooms. void handle_room_creation (udp::socket &amp; socket, const std::string &amp; room_name, const udp::endpoint &amp; client_endpoint) Handles the creation of a new room. void handle_room_joining (udp::socket &amp; socket, int room_id, const udp::endpoint &amp; client_endpoint) Handles a client's request to join an existing room. void handle_tcp_connection (boost::asio::io_context &amp; io_context, tcp::socket socket) Handles a new TCP connection from a client. void notify_clients_of_disconnection (boost::asio::io_context &amp; io_context, const udp::endpoint &amp; disconnected_client) Notifies all connected clients about a client's disconnection. void process_message (udp::socket &amp; socket, const std::vector&lt; uint8_t &gt; &amp; buffer, const udp::endpoint &amp; client_endpoint) Processes an incoming UDP message from a client. void process_message_contain (udp::socket &amp; socket, const std::vector&lt; uint8_t &gt; &amp; buffer, const udp::endpoint &amp; client_endpoint) Processes messages containing specific game data from a client. void run_game () Runs the main game loop. void send_udp_with_ack (udp::socket &amp; socket, const std::vector&lt; uint8_t &gt; &amp; message, const udp::endpoint &amp; client_endpoint) Sends a UDP message to a client with acknowledgment support. void start_heartbeat_monitor (boost::asio::io_context &amp; io_context) Starts monitoring the heartbeat of connected clients. void start_tcp_server (boost::asio::io_context &amp; io_context, int port) Starts the TCP server on a given port. void start_udp_server (boost::asio::io_context &amp; io_context, int port) Starts the UDP server on a given port. ~Server () Destructor for the Server class."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#detailed-description","title":"Detailed Description","text":"<p>The Server class is responsible for managing all incoming and outgoing network communication, handling player actions, managing rooms, and maintaining game-related systems (movement, collision, shooting, etc.). </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#variable-_connected_clients","title":"variable _connected_clients","text":"<pre><code>std::vector&lt;udp::endpoint&gt; Server::_connected_clients;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#variable-_game_time_manager","title":"variable _game_time_manager","text":"<pre><code>boost::asio::steady_timer Server::_game_time_manager;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#variable-_name","title":"variable _name","text":"<pre><code>std::string Server::_name;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#variable-cointimer","title":"variable coinTimer","text":"<pre><code>TimeManager Server::coinTimer;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#variable-coin_count","title":"variable coin_count","text":"<pre><code>u_int16_t Server::coin_count;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#variable-collision","title":"variable collision","text":"<pre><code>CollisionSystem Server::collision;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#variable-enemytimer","title":"variable enemyTimer","text":"<pre><code>TimeManager Server::enemyTimer;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#variable-enemy_count","title":"variable enemy_count","text":"<pre><code>u_int16_t Server::enemy_count;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#variable-game_run","title":"variable game_run","text":"<pre><code>bool Server::game_run;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#variable-id_name","title":"variable id_name","text":"<pre><code>std::vector&lt;std::pair&lt;udp::endpoint, std::string&gt; &gt; Server::id_name;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#variable-movement","title":"variable movement","text":"<pre><code>MouvementSystem Server::movement;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#variable-players_count","title":"variable players_count","text":"<pre><code>u_int16_t Server::players_count;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#variable-projectile_count","title":"variable projectile_count","text":"<pre><code>u_int16_t Server::projectile_count;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#variable-registry","title":"variable registry","text":"<pre><code>Registry Server::registry;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#variable-shoot","title":"variable shoot","text":"<pre><code>ShootSystem Server::shoot;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#variable-shoottimer","title":"variable shootTimer","text":"<pre><code>TimeManager Server::shootTimer;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#variable-updatetimer","title":"variable updateTimer","text":"<pre><code>TimeManager Server::updateTimer;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-server","title":"function Server","text":"<p>Constructs a new Server object. <pre><code>Server::Server (\n    boost::asio::io_context &amp; io_context,\n    server_t server_me\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>io_context</code> The Boost ASIO IO context to manage asynchronous operations. </li> <li><code>server_me</code> A struct containing TCP and UDP port numbers. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-check_player_message","title":"function check_player_message","text":"<p>Verifies and processes a player's incoming message. <pre><code>void Server::check_player_message (\n    udp::socket &amp; socket,\n    const std::vector&lt; uint8_t &gt; &amp; buffer,\n    const udp::endpoint &amp; client_endpoint\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>socket</code> The UDP socket through which the message was received. </li> <li><code>buffer</code> The message data from the client. </li> <li><code>client_endpoint</code> The endpoint (IP address and port) of the client. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-check_player_position","title":"function check_player_position","text":"<p>Checks and updates the player's position. <pre><code>void Server::check_player_position (\n    udp::socket &amp; socket,\n    const std::vector&lt; uint8_t &gt; &amp; buffer,\n    const udp::endpoint &amp; client_endpoint\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>socket</code> The UDP socket through which the message was received. </li> <li><code>buffer</code> The message data containing the player's position. </li> <li><code>client_endpoint</code> The endpoint of the client. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-get_player_entity","title":"function get_player_entity","text":"<p>Retrieves the entity representing the player based on their name. <pre><code>Entity &amp; Server::get_player_entity (\n    const std::string &amp; player_name\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>player_name</code> The player's name. </li> </ul> <p>Returns:</p> <p>The Entity object representing the player. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-get_player_id","title":"function get_player_id","text":"<p>Retrieves the player's ID based on their endpoint. <pre><code>int Server::get_player_id (\n    const udp::endpoint &amp; client_endpoint\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>client_endpoint</code> The endpoint of the client. </li> </ul> <p>Returns:</p> <p>The player's ID. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-get_player_name","title":"function get_player_name","text":"<p>Retrieves the player's name based on their endpoint. <pre><code>std::string Server::get_player_name (\n    const udp::endpoint &amp; client_endpoint\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>client_endpoint</code> The endpoint of the client. </li> </ul> <p>Returns:</p> <p>The player's name. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-handle_client_ping","title":"function handle_client_ping","text":"<p>Handles a ping message from a client to update the last communication time. <pre><code>void Server::handle_client_ping (\n    const udp::endpoint &amp; client_endpoint\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>client_endpoint</code> The endpoint (IP address and port) of the client who sent the ping. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-handle_list_rooms","title":"function handle_list_rooms","text":"<p>Handles a client's request to list all available rooms. <pre><code>void Server::handle_list_rooms (\n    udp::socket &amp; socket,\n    const udp::endpoint &amp; client_endpoint\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>socket</code> The UDP socket through which the request was received. </li> <li><code>client_endpoint</code> The endpoint of the client requesting the list. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-handle_room_creation","title":"function handle_room_creation","text":"<p>Handles the creation of a new room. <pre><code>void Server::handle_room_creation (\n    udp::socket &amp; socket,\n    const std::string &amp; room_name,\n    const udp::endpoint &amp; client_endpoint\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>socket</code> The UDP socket through which the message was received. </li> <li><code>room_name</code> The name of the new room to create. </li> <li><code>client_endpoint</code> The endpoint (IP address and port) of the client creating the room. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-handle_room_joining","title":"function handle_room_joining","text":"<p>Handles a client's request to join an existing room. <pre><code>void Server::handle_room_joining (\n    udp::socket &amp; socket,\n    int room_id,\n    const udp::endpoint &amp; client_endpoint\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>socket</code> The UDP socket through which the request was received. </li> <li><code>room_id</code> The ID of the room the client wants to join. </li> <li><code>client_endpoint</code> The endpoint (IP address and port) of the client. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-handle_tcp_connection","title":"function handle_tcp_connection","text":"<p>Handles a new TCP connection from a client. <pre><code>void Server::handle_tcp_connection (\n    boost::asio::io_context &amp; io_context,\n    tcp::socket socket\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>io_context</code> The IO context to manage asynchronous operations. </li> <li><code>socket</code> The TCP socket representing the connection with the client. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-notify_clients_of_disconnection","title":"function notify_clients_of_disconnection","text":"<p>Notifies all connected clients about a client's disconnection. <pre><code>void Server::notify_clients_of_disconnection (\n    boost::asio::io_context &amp; io_context,\n    const udp::endpoint &amp; disconnected_client\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>io_context</code> The IO context to manage asynchronous operations. </li> <li><code>disconnected_client</code> The endpoint of the client who disconnected. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-process_message","title":"function process_message","text":"<p>Processes an incoming UDP message from a client. <pre><code>void Server::process_message (\n    udp::socket &amp; socket,\n    const std::vector&lt; uint8_t &gt; &amp; buffer,\n    const udp::endpoint &amp; client_endpoint\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>socket</code> The UDP socket through which the message was received. </li> <li><code>buffer</code> The message data received from the client. </li> <li><code>client_endpoint</code> The endpoint (IP address and port) of the client who sent the message. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-process_message_contain","title":"function process_message_contain","text":"<p>Processes messages containing specific game data from a client. <pre><code>void Server::process_message_contain (\n    udp::socket &amp; socket,\n    const std::vector&lt; uint8_t &gt; &amp; buffer,\n    const udp::endpoint &amp; client_endpoint\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>socket</code> The UDP socket through which the message was received. </li> <li><code>buffer</code> The message data containing game-related content. </li> <li><code>client_endpoint</code> The endpoint (IP address and port) of the client. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-run_game","title":"function run_game","text":"<pre><code>void Server::run_game () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-send_udp_with_ack","title":"function send_udp_with_ack","text":"<p>Sends a UDP message to a client with acknowledgment support. <pre><code>void Server::send_udp_with_ack (\n    udp::socket &amp; socket,\n    const std::vector&lt; uint8_t &gt; &amp; message,\n    const udp::endpoint &amp; client_endpoint\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>socket</code> The UDP socket through which to send the message. </li> <li><code>message</code> The message data to send. </li> <li><code>client_endpoint</code> The endpoint (IP address and port) of the client. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-start_heartbeat_monitor","title":"function start_heartbeat_monitor","text":"<p>Starts monitoring the heartbeat of connected clients. <pre><code>void Server::start_heartbeat_monitor (\n    boost::asio::io_context &amp; io_context\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>io_context</code> The IO context to manage asynchronous operations. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-start_tcp_server","title":"function start_tcp_server","text":"<p>Starts the TCP server on a given port. <pre><code>void Server::start_tcp_server (\n    boost::asio::io_context &amp; io_context,\n    int port\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>io_context</code> The IO context to manage asynchronous operations. </li> <li><code>port</code> The port number on which the TCP server listens. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-start_udp_server","title":"function start_udp_server","text":"<p>Starts the UDP server on a given port. <pre><code>void Server::start_udp_server (\n    boost::asio::io_context &amp; io_context,\n    int port\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>io_context</code> The IO context to manage asynchronous operations. </li> <li><code>port</code> The port number on which the UDP server listens. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classServer/#function-server_1","title":"function ~Server","text":"<pre><code>Server::~Server () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Server/Server.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classShapeManager/","title":"Class ShapeManager","text":"<p>ClassList &gt; ShapeManager</p> <p>Manages and renders geometric shapes using the SFML graphics library. More...</p> <ul> <li><code>#include &lt;ShapeManager.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classShapeManager/#public-functions","title":"Public Functions","text":"Type Name ShapeManager () Constructs the ShapeManager instance. void drawCircle (sf::RenderWindow &amp; window, float x, float y, float radius, const sf::Color &amp; color, float thickness) Renders a circle onto the provided SFML RenderWindow. sf::RectangleShape drawRectangle (sf::RenderWindow &amp; window, float x, float y, float width, float height, sf::Color color, float outlineThickness, bool drawState=false) Renders a rectangle onto the provided SFML RenderWindow. ~ShapeManager () Destroys the ShapeManager instance."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classShapeManager/#detailed-description","title":"Detailed Description","text":"<p>The ShapeManager class encapsulates the functionality for drawing various geometric shapes (rectangles, circles, etc.) onto a given SFML render window.</p> <p>This class is designed as a singleton, ensuring that only one instance manages all shape-rendering operations within the application. It provides an interface for creating and configuring shapes with specific properties such as position, dimensions, color, and border thickness.</p> <p>Note:</p> <p>This class is a non-copyable singleton, and it assumes that the SFML RenderWindow is properly initialized before invoking any shape drawing operations. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classShapeManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classShapeManager/#function-shapemanager","title":"function ShapeManager","text":"<p>Constructs the ShapeManager instance. <pre><code>ShapeManager::ShapeManager () \n</code></pre></p> <p>Initializes the ShapeManager responsible for handling the rendering of shapes. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classShapeManager/#function-drawcircle","title":"function drawCircle","text":"<p>Renders a circle onto the provided SFML RenderWindow. <pre><code>void ShapeManager::drawCircle (\n    sf::RenderWindow &amp; window,\n    float x,\n    float y,\n    float radius,\n    const sf::Color &amp; color,\n    float thickness\n) \n</code></pre></p> <p>This method draws a circle centered at the specified position (x, y) with the given radius, color, and border thickness.</p> <p>Parameters:</p> <ul> <li><code>window</code> Reference to the SFML RenderWindow where the shape will be drawn. </li> <li><code>x</code> Horizontal position of the circle's center. </li> <li><code>y</code> Vertical position of the circle's center. </li> <li><code>radius</code> Radius of the circle. </li> <li><code>color</code> Fill color of the circle. </li> <li><code>thickness</code> Thickness of the circle's border (outline).</li> </ul> <p>Note:</p> <p>The render window must be open and available before calling this function. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classShapeManager/#function-drawrectangle","title":"function drawRectangle","text":"<p>Renders a rectangle onto the provided SFML RenderWindow. <pre><code>sf::RectangleShape ShapeManager::drawRectangle (\n    sf::RenderWindow &amp; window,\n    float x,\n    float y,\n    float width,\n    float height,\n    sf::Color color,\n    float outlineThickness,\n    bool drawState=false\n) \n</code></pre></p> <p>This method draws a rectangle at the specified position (x, y) with given dimensions (width, height) and a specified color and border thickness.</p> <p>Parameters:</p> <ul> <li><code>window</code> Reference to the SFML RenderWindow where the shape will be drawn. </li> <li><code>x</code> Horizontal position of the rectangle's top-left corner. </li> <li><code>y</code> Vertical position of the rectangle's top-left corner. </li> <li><code>width</code> Width of the rectangle. </li> <li><code>height</code> Height of the rectangle. </li> <li><code>color</code> Fill color of the rectangle. </li> <li><code>thickness</code> Thickness of the rectangle's border (outline).</li> </ul> <p>Note:</p> <p>The render window must be open and available before calling this function. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classShapeManager/#function-shapemanager_1","title":"function ~ShapeManager","text":"<p>Destroys the ShapeManager instance. <pre><code>ShapeManager::~ShapeManager () \n</code></pre></p> <p>Cleans up any resources held by the ShapeManager before the instance is destroyed. </p> <p>The documentation for this class was generated from the following file <code>include/Engine/Shape/ShapeManager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classShootSystem/","title":"Class ShootSystem","text":"<p>ClassList &gt; ShootSystem</p> <p>&lt; Includes the Entity class for representing game entities.More...</p> <ul> <li><code>#include &lt;Shoot_system.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classShootSystem/#public-functions","title":"Public Functions","text":"Type Name Vector2D spawn_projectile (Registry &amp; registry, Entity &amp; player) Spawns a projectile based on the player's current position and direction."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classShootSystem/#detailed-description","title":"Detailed Description","text":"<p>A system responsible for handling the shooting mechanics of entities, particularly players.</p> <p>The ShootSystem class provides a function to spawn projectiles in the game. It takes in the game registry, which manages all entities and components, and the player entity that initiates the projectile. The system is designed to spawn projectiles at the player's current position, aiming or moving in the intended direction. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classShootSystem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classShootSystem/#function-spawn_projectile","title":"function spawn_projectile","text":"<p>Spawns a projectile based on the player's current position and direction. <pre><code>Vector2D ShootSystem::spawn_projectile (\n    Registry &amp; registry,\n    Entity &amp; player\n) \n</code></pre></p> <p>This function creates a projectile entity and sets its initial position, which is usually near or at the player's current position. The function interacts with the game's registry to store the newly created projectile entity and initialize it with relevant components (such as position, velocity, etc.).</p> <p>Parameters:</p> <ul> <li><code>registry</code> Reference to the game's entity-component-system (ECS) registry. The registry is used to manage the creation and components of entities. </li> <li><code>player</code> Reference to the player entity that is firing the projectile. The player's position and direction will be used to spawn the projectile.</li> </ul> <p>Returns:</p> <p>Vector2D The starting position of the newly spawned projectile.</p> <p>Note:</p> <p>The projectile may also include additional logic such as setting its velocity and direction based on the player's orientation or input.</p> <p>Example usage:  <pre><code>ShootSystem shootSystem;\nVector2D projectilePosition = shootSystem.spawn_projectile(registry,\nplayerEntity);\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>include/Server/Shoot_system.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTextManager/","title":"Class TextManager","text":"<p>ClassList &gt; TextManager</p> <ul> <li><code>#include &lt;InputManager.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTextManager/#public-functions","title":"Public Functions","text":"Type Name sf::RenderWindow &amp; GetWindow ()  TextManager ()  void drawText (const std::string &amp; text, float x, float y, sf::Color color, sf::RenderWindow &amp; window)  void drawTextTemporarily (const std::string &amp; text, float x, float y, sf::Color color, float duration, sf::RenderWindow &amp; window)  void handleEvent ()  void loadFont (const std::string &amp; fontPath)  void render ()"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTextManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTextManager/#function-getwindow","title":"function GetWindow","text":"<pre><code>sf::RenderWindow &amp; TextManager::GetWindow () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTextManager/#function-textmanager","title":"function TextManager","text":"<pre><code>inline TextManager::TextManager () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTextManager/#function-drawtext","title":"function drawText","text":"<pre><code>void TextManager::drawText (\n    const std::string &amp; text,\n    float x,\n    float y,\n    sf::Color color,\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTextManager/#function-drawtexttemporarily","title":"function drawTextTemporarily","text":"<pre><code>void TextManager::drawTextTemporarily (\n    const std::string &amp; text,\n    float x,\n    float y,\n    sf::Color color,\n    float duration,\n    sf::RenderWindow &amp; window\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTextManager/#function-handleevent","title":"function handleEvent","text":"<pre><code>void TextManager::handleEvent () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTextManager/#function-loadfont","title":"function loadFont","text":"<pre><code>void TextManager::loadFont (\n    const std::string &amp; fontPath\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTextManager/#function-render","title":"function render","text":"<pre><code>void TextManager::render () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Engine/Input/InputManager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classThreadPool/","title":"Class ThreadPool","text":"<p>ClassList &gt; ThreadPool</p> <p>A class representing a thread pool for managing asynchronous tasks. </p> <ul> <li><code>#include &lt;ThreadPool.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classThreadPool/#public-functions","title":"Public Functions","text":"Type Name ThreadPool (boost::asio::io_context &amp; io_context, std::size_t num_threads) Constructs a ThreadPool with a specified number of threads. void add_threads (std::size_t num_threads) Adds a specified number of threads to the pool. void release () Releases all threads in the pool and stops the IO context. void remove_threads (std::size_t num_threads) Removes a specified number of threads from the pool. ~ThreadPool () Destructor for ThreadPool . Cleans up and releases threads."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classThreadPool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classThreadPool/#function-threadpool","title":"function ThreadPool","text":"<p>Constructs a ThreadPool with a specified number of threads. <pre><code>inline ThreadPool::ThreadPool (\n    boost::asio::io_context &amp; io_context,\n    std::size_t num_threads\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>io_context</code> The IO context for managing asynchronous operations. </li> <li><code>num_threads</code> The number of threads to create in the pool. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classThreadPool/#function-add_threads","title":"function add_threads","text":"<p>Adds a specified number of threads to the pool. <pre><code>inline void ThreadPool::add_threads (\n    std::size_t num_threads\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>num_threads</code> The number of threads to add. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classThreadPool/#function-release","title":"function release","text":"<pre><code>inline void ThreadPool::release () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classThreadPool/#function-remove_threads","title":"function remove_threads","text":"<p>Removes a specified number of threads from the pool. <pre><code>inline void ThreadPool::remove_threads (\n    std::size_t num_threads\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>num_threads</code> The number of threads to remove. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classThreadPool/#function-threadpool_1","title":"function ~ThreadPool","text":"<pre><code>inline ThreadPool::~ThreadPool () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Server/ThreadPool.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTimeManager/","title":"Class TimeManager","text":"<p>ClassList &gt; TimeManager</p> <p>A class to manage time tracking for elapsed time measurements. </p> <ul> <li><code>#include &lt;Time_manager.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTimeManager/#public-functions","title":"Public Functions","text":"Type Name TimeManager () Constructs a TimeManager and initializes the start time. float getElapsedTimeInSeconds () constGets the elapsed time since the start time in seconds. void restart () Restarts the timer by resetting the start time to the current time."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTimeManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTimeManager/#function-timemanager","title":"function TimeManager","text":"<pre><code>inline TimeManager::TimeManager () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTimeManager/#function-getelapsedtimeinseconds","title":"function getElapsedTimeInSeconds","text":"<p>Gets the elapsed time since the start time in seconds. <pre><code>float TimeManager::getElapsedTimeInSeconds () const\n</code></pre></p> <p>Returns:</p> <p>The elapsed time in seconds as a float. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTimeManager/#function-restart","title":"function restart","text":"<pre><code>void TimeManager::restart () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Server/Time_manager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTransform/","title":"Class Transform","text":"<p>ClassList &gt; Transform</p> <p>Component representing an entity's position and velocity in 2D space. More...</p> <ul> <li><code>#include &lt;Entity.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTransform/#public-attributes","title":"Public Attributes","text":"Type Name Vector2D position Current position of the entity in 2D space. Vector2D velocity Current velocity of the entity in 2D space."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTransform/#public-functions","title":"Public Functions","text":"Type Name Transform () Default constructor initializes position and velocity to (0, 0). Transform (Vector2D pos, Vector2D vel) Constructor to initialize position and velocity."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTransform/#detailed-description","title":"Detailed Description","text":"<p>This component tracks the movement and spatial state of the entity. It is used for both static objects (e.g., obstacles) and dynamic entities (e.g., players).</p> <p>Note:</p> <p>The velocity can be used to determine how fast the entity moves over time. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTransform/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTransform/#variable-position","title":"variable position","text":"<pre><code>Vector2D Transform::position;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTransform/#variable-velocity","title":"variable velocity","text":"<pre><code>Vector2D Transform::velocity;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTransform/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTransform/#function-transform-12","title":"function Transform [1/2]","text":"<pre><code>inline Transform::Transform () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classTransform/#function-transform-22","title":"function Transform [2/2]","text":"<p>Constructor to initialize position and velocity. <pre><code>inline Transform::Transform (\n    Vector2D pos,\n    Vector2D vel\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pos</code> Initial position of the entity. </li> <li><code>vel</code> Initial velocity of the entity. </li> </ul> <p>The documentation for this class was generated from the following file <code>include/Server/Entity.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classVector2D/","title":"Class Vector2D","text":"<p>ClassList &gt; Vector2D</p> <p>A class to represent a 2D vector. </p> <ul> <li><code>#include &lt;Vector.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classVector2D/#public-attributes","title":"Public Attributes","text":"Type Name double x The x component of the vector. double y The y component of the vector."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classVector2D/#public-functions","title":"Public Functions","text":"Type Name Vector2D () Default constructor. Initializes the vector to (0,0,0). Vector2D (double x, double y) Constructor with parameters. Vector2D &amp; add (const Vector2D &amp; v)  double dot (const Vector2D &amp; other) constCalculates the dot product with another vector. double length () constCalculates the length of the vector. double length_squared () constCalculates the squared length of the vector. Vector2D normalize () Normalizes a vector. Vector2D operator/ (double scalar) constOverloads the / operator for scalar division. Vector2D &amp; operator/= (double scalar) Overloads the /= operator for scalar division. Vector2D &amp; rotate (double angle)  Vector2D &amp; scale (double scalar) scale the vector by a scalar Vector2D vector_unit () constCalculates the unit vector."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classVector2D/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classVector2D/#variable-x","title":"variable x","text":"<pre><code>double Vector2D::x;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classVector2D/#variable-y","title":"variable y","text":"<pre><code>double Vector2D::y;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classVector2D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classVector2D/#function-vector2d-12","title":"function Vector2D [1/2]","text":"<pre><code>inline Vector2D::Vector2D () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classVector2D/#function-vector2d-22","title":"function Vector2D [2/2]","text":"<p>Constructor with parameters. <pre><code>inline Vector2D::Vector2D (\n    double x,\n    double y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>x</code> The x component of the vector. </li> <li><code>y</code> The y component of the vector. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classVector2D/#function-add","title":"function add","text":"<pre><code>inline Vector2D &amp; Vector2D::add (\n    const Vector2D &amp; v\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classVector2D/#function-dot","title":"function dot","text":"<p>Calculates the dot product with another vector. <pre><code>inline double Vector2D::dot (\n    const Vector2D &amp; other\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>other</code> The other vector. </li> </ul> <p>Returns:</p> <p>The dot product. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classVector2D/#function-length","title":"function length","text":"<p>Calculates the length of the vector. <pre><code>inline double Vector2D::length () const\n</code></pre></p> <p>Returns:</p> <p>The length of the vector. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classVector2D/#function-length_squared","title":"function length_squared","text":"<p>Calculates the squared length of the vector. <pre><code>inline double Vector2D::length_squared () const\n</code></pre></p> <p>Returns:</p> <p>The squared length of the vector. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classVector2D/#function-normalize","title":"function normalize","text":"<p>Normalizes a vector. <pre><code>inline Vector2D Vector2D::normalize () \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>v</code> The vector to normalize. </li> </ul> <p>Returns:</p> <p>The normalized vector. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classVector2D/#function-operator","title":"function operator/","text":"<p>Overloads the / operator for scalar division. <pre><code>inline Vector2D Vector2D::operator/ (\n    double scalar\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>scalar</code> The scalar to divide the vector by. </li> </ul> <p>Returns:</p> <p>A new vector that is the result of the division. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classVector2D/#function-operator_1","title":"function operator/=","text":"<p>Overloads the /= operator for scalar division. <pre><code>inline Vector2D &amp; Vector2D::operator/= (\n    double scalar\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>scalar</code> The scalar to divide the vector by. </li> </ul> <p>Returns:</p> <p>The vector itself after division. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classVector2D/#function-rotate","title":"function rotate","text":"<pre><code>inline Vector2D &amp; Vector2D::rotate (\n    double angle\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classVector2D/#function-scale","title":"function scale","text":"<p>scale the vector by a scalar <pre><code>inline Vector2D &amp; Vector2D::scale (\n    double scalar\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>scalar</code> </li> </ul> <p>Returns:</p> <p>Vector2D&amp; </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classVector2D/#function-vector_unit","title":"function vector_unit","text":"<p>Calculates the unit vector. <pre><code>inline Vector2D Vector2D::vector_unit () const\n</code></pre></p> <p>Returns:</p> <p>The unit vector. </p> <p>The documentation for this class was generated from the following file <code>include/Server/Vector.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classWindowManager/","title":"Class WindowManager","text":"<p>ClassList &gt; WindowManager</p> <ul> <li><code>#include &lt;MenuWindowManager.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classWindowManager/#public-functions","title":"Public Functions","text":"Type Name sf::RenderWindow &amp; GetWindow ()  void SetWindowSize (const sf::Vector2u &amp; size)  WindowManager (int width, int height, const std::string &amp; windowName)  void drawText (const std::string &amp; text, float x, float y, sf::Color color)  void handleEvent ()  void keepOpen ()  void loadFont (const std::string &amp; fontPath)  void render ()"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classWindowManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classWindowManager/#function-getwindow","title":"function GetWindow","text":"<pre><code>sf::RenderWindow &amp; WindowManager::GetWindow () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classWindowManager/#function-setwindowsize","title":"function SetWindowSize","text":"<pre><code>void WindowManager::SetWindowSize (\n    const sf::Vector2u &amp; size\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classWindowManager/#function-windowmanager","title":"function WindowManager","text":"<pre><code>WindowManager::WindowManager (\n    int width,\n    int height,\n    const std::string &amp; windowName\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classWindowManager/#function-drawtext","title":"function drawText","text":"<pre><code>void WindowManager::drawText (\n    const std::string &amp; text,\n    float x,\n    float y,\n    sf::Color color\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classWindowManager/#function-handleevent","title":"function handleEvent","text":"<pre><code>void WindowManager::handleEvent () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classWindowManager/#function-keepopen","title":"function keepOpen","text":"<pre><code>void WindowManager::keepOpen () \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classWindowManager/#function-loadfont","title":"function loadFont","text":"<pre><code>void WindowManager::loadFont (\n    const std::string &amp; fontPath\n) \n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classWindowManager/#function-render","title":"function render","text":"<pre><code>void WindowManager::render () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Client/Save/MenuWindowManager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/","title":"Class Member Functions","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#a","title":"a","text":"<ul> <li>Animation (Animation)</li> <li>AudioManager (AudioManager)</li> <li>assign_enemy (Client)</li> <li>addScreen (GameUI::ScreenManager)</li> <li>applyChanges (Menu)</li> <li>add_entity (Registry)</li> <li>add_threads (ThreadPool)</li> <li>add (Vector2D)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#b","title":"b","text":"<ul> <li>BBox (BBox)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#c","title":"c","text":"<ul> <li>Client (Client)</li> <li>create_player_1 (Client)</li> <li>create_player_2 (Client)</li> <li>create_player_3 (Client)</li> <li>create_player_4 (Client)</li> <li>create_random_enemy (Client)</li> <li>checkCoins (CoinSystem)</li> <li>CollisionSystem (CollisionSystem)</li> <li>check_collision (CollisionSystem)</li> <li>collision_enemy_projectiles (CollisionSystem)</li> <li>collision_player_enemy (CollisionSystem)</li> <li>collison_player_coins (CollisionSystem)</li> <li>centerImage (GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, Menu)</li> <li>createEnamies5 (GameUI::GamePlay)</li> <li>createEnamies6 (GameUI::GamePlay)</li> <li>createEnamies7 (GameUI::GamePlay)</li> <li>createEnamies8 (GameUI::GamePlay)</li> <li>createEnamies9 (GameUI::GamePlay)</li> <li>createEnamiesBoss (GameUI::GamePlay)</li> <li>createEnemies (GameUI::GamePlay)</li> <li>createEnemies2 (GameUI::GamePlay)</li> <li>createEnemies3 (GameUI::GamePlay)</li> <li>createEnemies4 (GameUI::GamePlay)</li> <li>createPlayer1 (GameUI::GamePlay)</li> <li>createPlayer2 (GameUI::GamePlay)</li> <li>checkHealth (HealthSystem)</li> <li>createImage (ImageManager)</li> <li>create_room (Room_System)</li> <li>check_player_message (Server)</li> <li>check_player_position (Server)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#d","title":"d","text":"<ul> <li>destroy (Entity)</li> <li>drawAsteriodFour (GameUI::GameLobby)</li> <li>drawAsteriodOne (GameUI::GameLobby)</li> <li>drawAsteriodThree (GameUI::GameLobby)</li> <li>drawAsteriodTwo (GameUI::GameLobby)</li> <li>drawBackground (GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, Menu)</li> <li>drawGameLobby (GameUI::GameLobby, Menu)</li> <li>drawLifeBoard (GameUI::GamePlay)</li> <li>drawTeamScore (GameUI::GamePlay)</li> <li>drawGameSetting (GameUI::GameSetting)</li> <li>drawBackButton (GameUI::RoomLobby)</li> <li>drawRoomLobby (GameUI::RoomLobby)</li> <li>destroyImage (ImageManager)</li> <li>draw (ImageManager, Parallax)</li> <li>decreaseResolution (Menu)</li> <li>decreaseVolume (Menu)</li> <li>drawMainMenu (Menu)</li> <li>drawSettingsBackground (Menu)</li> <li>drawSettingsElements (Menu)</li> <li>drawSoundToggle (Menu)</li> <li>drawCircle (ShapeManager)</li> <li>drawRectangle (ShapeManager)</li> <li>drawText (TextManager, WindowManager)</li> <li>drawTextTemporarily (TextManager)</li> <li>dot (Vector2D)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#e","title":"e","text":"<ul> <li>Entity (Entity)</li> <li>enemy_move (MouvementSystem)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#f","title":"f","text":"<ul> <li>fitToScreen (ImageManager)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#g","title":"g","text":"<ul> <li>getPosition (Animation)</li> <li>getSprite (Animation, ImageManager)</li> <li>get_enemy_color (Client)</li> <li>get_name (Client)</li> <li>get_player_color (Client)</li> <li>GameCore (GameUI::GameCore)</li> <li>GameLobby (GameUI::GameLobby)</li> <li>getAsteriodFourSprite (GameUI::GameLobby)</li> <li>getAsteriodOneSprite (GameUI::GameLobby)</li> <li>getAsteriodThreeSprite (GameUI::GameLobby)</li> <li>getAsteriodTwoSprite (GameUI::GameLobby)</li> <li>getBackgroundSprite (GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, Menu)</li> <li>getButtonSound (GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby)</li> <li>getGameLobbySprite (GameUI::GameLobby, Menu)</li> <li>getMouse (GameUI::GameLobby, GameUI::RoomLobby)</li> <li>getRect1 (GameUI::GameLobby, GameUI::GameSetting, GameUI::RoomLobby, Menu)</li> <li>getRect2 (GameUI::GameLobby, GameUI::GameSetting, GameUI::RoomLobby, Menu)</li> <li>getRoomMusic (GameUI::GameLobby)</li> <li>GamePlay (GameUI::GamePlay)</li> <li>getLifeBoardSprite (GameUI::GamePlay)</li> <li>getTeamScoreSprite (GameUI::GamePlay)</li> <li>GameSetting (GameUI::GameSetting)</li> <li>getGameSettingSprite (GameUI::GameSetting)</li> <li>getBackButtonSprite (GameUI::RoomLobby)</li> <li>getRect3 (GameUI::RoomLobby)</li> <li>getRect4 (GameUI::RoomLobby)</li> <li>getRoomLobbySprite (GameUI::RoomLobby)</li> <li>getTextIp (GameUI::RoomLobby)</li> <li>getTextName (GameUI::RoomLobby)</li> <li>getTextPort (GameUI::RoomLobby)</li> <li>getGlobalBounds (ImageManager)</li> <li>getButton (InputManager)</li> <li>getPlayButtonSprite (Menu)</li> <li>getMouseX (MouseManager)</li> <li>getMouseY (MouseManager)</li> <li>get_entities (Registry)</li> <li>getScore (Score)</li> <li>get_player_entity (Server)</li> <li>get_player_id (Server)</li> <li>get_player_name (Server)</li> <li>GetWindow (TextManager, WindowManager)</li> <li>getElapsedTimeInSeconds (TimeManager)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#h","title":"h","text":"<ul> <li>handleEvent (GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, GameUI::ScreenManager, IScreen, TextManager, WindowManager)</li> <li>Health (Health)</li> <li>handleInput (InputManager, MouvementSystem)</li> <li>handleButtonClicks (Menu)</li> <li>handleEvents (Menu)</li> <li>handleMouseEvents (Menu)</li> <li>handleNavigationClicks (Menu)</li> <li>handleResolutionClicks (Menu)</li> <li>handleSettingsClicks (Menu)</li> <li>handleSettingsEvents (Menu)</li> <li>handleSoundToggleClicks (Menu)</li> <li>handleVolumeClicks (Menu)</li> <li>handleWindowEvents (Menu)</li> <li>handleMousePosition (MouseManager)</li> <li>handle_client_ping (Server)</li> <li>handle_list_rooms (Server)</li> <li>handle_room_creation (Server)</li> <li>handle_room_joining (Server)</li> <li>handle_tcp_connection (Server)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#i","title":"i","text":"<ul> <li>ImageManager (ImageManager)</li> <li>Input (Input)</li> <li>InputManager (InputManager)</li> <li>increaseResolution (Menu)</li> <li>increaseVolume (Menu)</li> <li>initializeMusic (Menu)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#j","title":"j","text":"<ul> <li>join_room (Room_System)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#k","title":"k","text":"<ul> <li>keepOpen (WindowManager)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#l","title":"l","text":"<ul> <li>loadAnimation (Animation)</li> <li>loadFont (GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, TextManager, WindowManager)</li> <li>loadAndSetupImage (Menu)</li> <li>loadImages (Menu)</li> <li>loadResolutionImages (Menu)</li> <li>loadVolumeImages (Menu)</li> <li>leave_room (Room_System)</li> <li>list_available_rooms (Room_System)</li> <li>length (Vector2D)</li> <li>length_squared (Vector2D)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#m","title":"m","text":"<ul> <li>moveXLeft (Animation)</li> <li>moveXRight (Animation)</li> <li>moveY (Animation)</li> <li>moveYUp (Animation)</li> <li>Menu (Menu)</li> <li>MouseManager (MouseManager)</li> <li>MouvementSystem (MouvementSystem)</li> <li>move_player (MouvementSystem)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#n","title":"n","text":"<ul> <li>Name (Name)</li> <li>notify_clients_of_disconnection (Server)</li> <li>normalize (Vector2D)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#o","title":"o","text":"<ul> <li>operator() (EndpointEqual, EndpointHash)</li> <li>openSettings (Menu)</li> <li>operator/ (Vector2D)</li> <li>operator/= (Vector2D)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#p","title":"p","text":"<ul> <li>pauseMusic (AudioManager)</li> <li>playMusic (AudioManager)</li> <li>playSound (AudioManager)</li> <li>Parallax (Parallax)</li> <li>process_message (Server)</li> <li>process_message_contain (Server)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#r","title":"r","text":"<ul> <li>render (Animation, GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, GameUI::ScreenManager, IScreen, Menu, TextManager, WindowManager)</li> <li>resumeMusic (AudioManager)</li> <li>run (GameUI::GameCore, Menu)</li> <li>RoomLobby (GameUI::RoomLobby)</li> <li>reset (Input)</li> <li>renderSettings (Menu)</li> <li>remove_entity (Registry)</li> <li>Room_System (Room_System)</li> <li>remove_room (Room_System)</li> <li>run_game (Server)</li> <li>release (ThreadPool)</li> <li>remove_threads (ThreadPool)</li> <li>restart (TimeManager)</li> <li>rotate (Vector2D)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#s","title":"s","text":"<ul> <li>setPosition (Animation, ImageManager)</li> <li>setScale (Animation, ImageManager)</li> <li>setMusicVolume (AudioManager)</li> <li>setPitch (AudioManager)</li> <li>setSoundVolume (AudioManager)</li> <li>send_tcp_message (Client)</li> <li>send_udp_message (Client)</li> <li>setAsteriodFour (GameUI::GameLobby)</li> <li>setAsteriodOne (GameUI::GameLobby)</li> <li>setAsteriodThree (GameUI::GameLobby)</li> <li>setAsteriodTwo (GameUI::GameLobby)</li> <li>setBackground (GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, Menu)</li> <li>setGameLobby (GameUI::GameLobby)</li> <li>shapebuilder (GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby)</li> <li>setLifeBoard (GameUI::GamePlay)</li> <li>setTeamScore (GameUI::GamePlay)</li> <li>spawnRandomEnemies (GameUI::GamePlay)</li> <li>setGameSetting (GameUI::GameSetting)</li> <li>setBackButton (GameUI::RoomLobby)</li> <li>setRoomLobby (GameUI::RoomLobby)</li> <li>ScreenManager (GameUI::ScreenManager)</li> <li>switchToScreen (GameUI::ScreenManager)</li> <li>system_movement (MouvementSystem)</li> <li>start_game_in_room (Room_System)</li> <li>Score (Score)</li> <li>set_score (Score)</li> <li>Server (Server)</li> <li>send_udp_with_ack (Server)</li> <li>start_heartbeat_monitor (Server)</li> <li>start_tcp_server (Server)</li> <li>start_udp_server (Server)</li> <li>ShapeManager (ShapeManager)</li> <li>spawn_projectile (ShootSystem)</li> <li>scale (Vector2D)</li> <li>SetWindowSize (WindowManager)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#t","title":"t","text":"<ul> <li>textfieldsetter (GameUI::RoomLobby)</li> <li>takeDamage (Health)</li> <li>TextManager (TextManager)</li> <li>ThreadPool (ThreadPool)</li> <li>TimeManager (TimeManager)</li> <li>Transform (Transform)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#u","title":"u","text":"<ul> <li>update (Animation, GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, GameUI::ScreenManager, IScreen, Menu, Parallax)</li> <li>updateElementPosition (Menu)</li> <li>updateElementPositions (Menu)</li> <li>updateResolutionImage (Menu)</li> <li>updateVolumeImage (Menu)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#v","title":"v","text":"<ul> <li>Vector2D (Vector2D)</li> <li>vector_unit (Vector2D)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#w","title":"w","text":"<ul> <li>WindowManager (WindowManager)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_functions/#_1","title":"~","text":"<ul> <li>~Animation (Animation)</li> <li>~AudioManager (AudioManager)</li> <li>~Client (Client)</li> <li>~CollisionSystem (CollisionSystem)</li> <li>~IScreen (IScreen)</li> <li>~ImageManager (ImageManager)</li> <li>~InputManager (InputManager)</li> <li>~MouseManager (MouseManager)</li> <li>~MouvementSystem (MouvementSystem)</li> <li>~Room_System (Room_System)</li> <li>~Server (Server)</li> <li>~ShapeManager (ShapeManager)</li> <li>~ThreadPool (ThreadPool)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/","title":"Class Member Variables","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#a","title":"a","text":"<ul> <li>animations (Animation)</li> <li>animationsData (Animation)</li> <li>Asteriod1 (GameUI::GameLobby)</li> <li>Asteriod2 (GameUI::GameLobby)</li> <li>Asteriod3 (GameUI::GameLobby)</li> <li>activeInput (GameUI::RoomLobby)</li> <li>attack (InputManager::Button)</li> <li>applyChangesButtonImage (Menu)</li> <li>asteroid_1 (Menu)</li> <li>asteroid_2 (Menu)</li> <li>asteroid_3 (Menu)</li> <li>asteroid_4 (Menu)</li> <li>audioManager (Menu)</li> <li>animation (WindowManager)</li> <li>add_new_param (parameter_t)</li> <li>argument (parameter_t)</li> <li>action_type (protocol::PlayerAction)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#b","title":"b","text":"<ul> <li>buffer (AudioManager)</li> <li>ButtonSound (Client, GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby)</li> <li>backgroundImage (Client, GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, Menu)</li> <li>bbox (Entity)</li> <li>backButtonImage (GameUI::RoomLobby)</li> <li>button (InputManager)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#c","title":"c","text":"<ul> <li>currentFrame (Animation, AnimationData)</li> <li>clock (AnimationData, TemporaryText)</li> <li>client (GameUI::ScreenManager)</li> <li>currentScreen (GameUI::ScreenManager)</li> <li>currentHealth (Health)</li> <li>currentResolutionIndex (Menu)</li> <li>clients (Server)</li> <li>clients_me (Server)</li> <li>coinTimer (Server)</li> <li>coin_count (Server)</li> <li>collision (Server)</li> <li>check_me (parameter_t)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#d","title":"d","text":"<ul> <li>down (Input, InputManager::Button)</li> <li>duration (TemporaryText)</li> <li>data (protocol::PlayerAction)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#e","title":"e","text":"<ul> <li>enemie1 (Client)</li> <li>enemie2 (Client)</li> <li>enemie3 (Client)</li> <li>enemie4 (Client)</li> <li>enemie5 (Client)</li> <li>enemie6 (Client)</li> <li>enemie7 (Client)</li> <li>enemie8 (Client)</li> <li>enemie9 (Client)</li> <li>enemieBoss (Client)</li> <li>enemies (Client)</li> <li>enemies_id (Client)</li> <li>event (Client, TextManager, WindowManager)</li> <li>enemies1 (GameUI::GamePlay)</li> <li>enemies2 (GameUI::GamePlay)</li> <li>enemies3 (GameUI::GamePlay)</li> <li>enemies4 (GameUI::GamePlay)</li> <li>enemies5 (GameUI::GamePlay)</li> <li>enemies6 (GameUI::GamePlay)</li> <li>enemies7 (GameUI::GamePlay)</li> <li>enemies8 (GameUI::GamePlay)</li> <li>enemies9 (GameUI::GamePlay)</li> <li>enemiesBoss (GameUI::GamePlay)</li> <li>escape (InputManager::Button)</li> <li>enemyTimer (Server)</li> <li>enemy_count (Server)</li> <li>event_data (protocol::EventNotification)</li> <li>event_type (protocol::EventNotification)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#f","title":"f","text":"<ul> <li>frameTime (Animation)</li> <li>font (Client, GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, TextManager, WindowManager)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#g","title":"g","text":"<ul> <li>GamePlayImage (Client, GameUI::GamePlay)</li> <li>game_over (Client)</li> <li>GameLobbyImage (GameUI::GameLobby, Menu)</li> <li>GameSettingImage (GameUI::GameSetting)</li> <li>goBackButtonImage (Menu)</li> <li>game_run (Server)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#h","title":"h","text":"<ul> <li>health (Entity)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#i","title":"i","text":"<ul> <li>input (Client, Entity, GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, TextManager, WindowManager)</li> <li>inputIp (GameUI::RoomLobby)</li> <li>inputName (GameUI::RoomLobby)</li> <li>inputPort (GameUI::RoomLobby)</li> <li>infButton (Menu)</li> <li>inputManager (Menu)</li> <li>isSoundOn (Menu)</li> <li>in_game (Room_System::Room)</li> <li>id_name (Server)</li> <li>io_context (ThreadPool)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#l","title":"l","text":"<ul> <li>LifeBoardImage (Client, GameUI::GamePlay)</li> <li>left (Input, InputManager::Button)</li> <li>last_ping (Server::ClientInfo)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#m","title":"m","text":"<ul> <li>music (AudioManager, Menu)</li> <li>mouse (GameUI::GameLobby, GameUI::GameSetting, GameUI::RoomLobby, WindowManager)</li> <li>maxHealth (Health)</li> <li>moinsButton (Menu)</li> <li>mouseManager (Menu)</li> <li>max_players (Room_System::Room)</li> <li>movement (Server)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#n","title":"n","text":"<ul> <li>name (Entity, Name, Room_System::Room, parameter_t)</li> <li>next_room_id (Room_System)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#o","title":"o","text":"<ul> <li>offImage (Menu)</li> <li>onImage (Menu)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#p","title":"p","text":"<ul> <li>player1 (Client, GameUI::GamePlay)</li> <li>player2 (Client, GameUI::GamePlay)</li> <li>players (Client, Room_System::Room)</li> <li>players_id (Client)</li> <li>projectiles (Client)</li> <li>projectiles_id (Client)</li> <li>playIsDown (GameUI::GamePlay)</li> <li>playIsLeft (GameUI::GamePlay)</li> <li>playIsRight (GameUI::GamePlay)</li> <li>playIsUp (GameUI::GamePlay)</li> <li>plusButton (Menu)</li> <li>players_count (Server)</li> <li>projectile_count (Server)</li> <li>position (Transform)</li> <li>player_id (protocol::PlayerAction)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#r","title":"r","text":"<ul> <li>RoomMusic (GameUI::GameCore, GameUI::GameLobby)</li> <li>roomLobby (GameUI::GameCore)</li> <li>rect1 (GameUI::GameLobby, GameUI::GameSetting, GameUI::RoomLobby, Menu)</li> <li>rect2 (GameUI::GameLobby, GameUI::GameSetting, GameUI::RoomLobby, Menu)</li> <li>RoomLobbyImage (GameUI::RoomLobby)</li> <li>rect3 (GameUI::RoomLobby)</li> <li>rect4 (GameUI::RoomLobby)</li> <li>right (Input, InputManager::Button)</li> <li>resolutionSprite (Menu)</li> <li>resolutionTextures (Menu)</li> <li>resolutions (Menu)</li> <li>rooms (Room_System)</li> <li>registry (Server)</li> <li>room_system (Server)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#s","title":"s","text":"<ul> <li>sprite (Animation, AnimationData, ImageManager)</li> <li>sound (AudioManager)</li> <li>size (BBox)</li> <li>server_tcp_ip (Client)</li> <li>server_udp_ip (Client)</li> <li>shapeManager1 (Client, GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby)</li> <li>shapeManager2 (Client, GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby)</li> <li>score (Entity)</li> <li>screenManager (GameUI::GameCore, GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby)</li> <li>shapeManager3 (GameUI::RoomLobby)</li> <li>shapeManager4 (GameUI::RoomLobby)</li> <li>screens (GameUI::ScreenManager)</li> <li>shoot (Input, Server)</li> <li>screenResolutionImage (Menu)</li> <li>screen_infButton (Menu)</li> <li>screen_supButton (Menu)</li> <li>setVolumeImage (Menu)</li> <li>settingsButtonImage (Menu)</li> <li>settingsOpen (Menu)</li> <li>soundImage (Menu)</li> <li>startButtonImage (Menu)</li> <li>supButton (Menu)</li> <li>speed1 (Parallax)</li> <li>speed2 (Parallax)</li> <li>sprite1 (Parallax)</li> <li>sprite2 (Parallax)</li> <li>scoreValue (Score)</li> <li>shootTimer (Server)</li> <li>start (TimeManager)</li> <li>state_data (protocol::GameStateUpdate)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#t","title":"t","text":"<ul> <li>texture (Animation, ImageManager)</li> <li>totalFrames (AnimationData)</li> <li>TeamScoreImage (Client, GameUI::GamePlay)</li> <li>transform (Entity)</li> <li>textip (GameUI::GameLobby, GameUI::GameSetting, GameUI::RoomLobby)</li> <li>textname (GameUI::GameLobby, GameUI::GameSetting, GameUI::RoomLobby)</li> <li>textport (GameUI::RoomLobby)</li> <li>texture1 (Parallax)</li> <li>texture2 (Parallax)</li> <li>text (TemporaryText)</li> <li>tempTexts (TextManager, WindowManager)</li> <li>thread_pool (ThreadPool)</li> <li>tcp_port (server_me_t)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#u","title":"u","text":"<ul> <li>up (Input, InputManager::Button)</li> <li>updateTimer (Server)</li> <li>usage (parameter_t)</li> <li>udp_port (server_me_t)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#v","title":"v","text":"<ul> <li>volumeLevel (Menu)</li> <li>volumeSprite (Menu)</li> <li>volumeTextures (Menu)</li> <li>velocity (Transform)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#w","title":"w","text":"<ul> <li>window (Client, GameUI::GameCore, GameUI::ScreenManager, Menu, WindowManager)</li> <li>window_manager (Client)</li> <li>windowManager (Menu)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#x","title":"x","text":"<ul> <li>x (MouseManager, Vector2D)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#y","title":"y","text":"<ul> <li>y (MouseManager, Vector2D)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_member_variables/#_","title":"_","text":"<ul> <li>_health (Client)</li> <li>_io_context (Client)</li> <li>_receiver_endpoint (Client)</li> <li>_score (Client)</li> <li>_soc (Client)</li> <li>_alive (Entity)</li> <li>_id (Entity)</li> <li>_tag (Entity)</li> <li>_entities_count (Registry)</li> <li>_entities_map (Registry)</li> <li>_entities_vector (Registry)</li> <li>_new_entities (Registry)</li> <li>_connected_clients (Server)</li> <li>_game_time_manager (Server)</li> <li>_name (Server)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/","title":"Class Members","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#a","title":"a","text":"<ul> <li>Animation (Animation)</li> <li>animations (Animation)</li> <li>animationsData (Animation)</li> <li>AudioManager (AudioManager)</li> <li>assign_enemy (Client)</li> <li>Asteriod1 (GameUI::GameLobby)</li> <li>Asteriod2 (GameUI::GameLobby)</li> <li>Asteriod3 (GameUI::GameLobby)</li> <li>activeInput (GameUI::RoomLobby)</li> <li>addScreen (GameUI::ScreenManager)</li> <li>attack (InputManager::Button)</li> <li>applyChanges (Menu)</li> <li>applyChangesButtonImage (Menu)</li> <li>asteroid_1 (Menu)</li> <li>asteroid_2 (Menu)</li> <li>asteroid_3 (Menu)</li> <li>asteroid_4 (Menu)</li> <li>audioManager (Menu)</li> <li>add_entity (Registry)</li> <li>add_threads (ThreadPool)</li> <li>add (Vector2D)</li> <li>animation (WindowManager)</li> <li>add_new_param (parameter_t)</li> <li>argument (parameter_t)</li> <li>action_type (protocol::PlayerAction)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#b","title":"b","text":"<ul> <li>buffer (AudioManager)</li> <li>BBox (BBox)</li> <li>ButtonSound (Client, GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby)</li> <li>backgroundImage (Client, GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, Menu)</li> <li>bbox (Entity)</li> <li>backButtonImage (GameUI::RoomLobby)</li> <li>button (InputManager)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#c","title":"c","text":"<ul> <li>currentFrame (Animation, AnimationData)</li> <li>clock (AnimationData, TemporaryText)</li> <li>Client (Client)</li> <li>create_player_1 (Client)</li> <li>create_player_2 (Client)</li> <li>create_player_3 (Client)</li> <li>create_player_4 (Client)</li> <li>create_random_enemy (Client)</li> <li>checkCoins (CoinSystem)</li> <li>CollisionSystem (CollisionSystem)</li> <li>check_collision (CollisionSystem)</li> <li>collision_enemy_projectiles (CollisionSystem)</li> <li>collision_player_enemy (CollisionSystem)</li> <li>collison_player_coins (CollisionSystem)</li> <li>centerImage (GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, Menu)</li> <li>createEnamies5 (GameUI::GamePlay)</li> <li>createEnamies6 (GameUI::GamePlay)</li> <li>createEnamies7 (GameUI::GamePlay)</li> <li>createEnamies8 (GameUI::GamePlay)</li> <li>createEnamies9 (GameUI::GamePlay)</li> <li>createEnamiesBoss (GameUI::GamePlay)</li> <li>createEnemies (GameUI::GamePlay)</li> <li>createEnemies2 (GameUI::GamePlay)</li> <li>createEnemies3 (GameUI::GamePlay)</li> <li>createEnemies4 (GameUI::GamePlay)</li> <li>createPlayer1 (GameUI::GamePlay)</li> <li>createPlayer2 (GameUI::GamePlay)</li> <li>client (GameUI::ScreenManager)</li> <li>currentScreen (GameUI::ScreenManager)</li> <li>currentHealth (Health)</li> <li>checkHealth (HealthSystem)</li> <li>createImage (ImageManager)</li> <li>currentResolutionIndex (Menu)</li> <li>create_room (Room_System)</li> <li>check_player_message (Server)</li> <li>check_player_position (Server)</li> <li>clients (Server)</li> <li>clients_me (Server)</li> <li>coinTimer (Server)</li> <li>coin_count (Server)</li> <li>collision (Server)</li> <li>check_me (parameter_t)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#d","title":"d","text":"<ul> <li>destroy (Entity)</li> <li>drawAsteriodFour (GameUI::GameLobby)</li> <li>drawAsteriodOne (GameUI::GameLobby)</li> <li>drawAsteriodThree (GameUI::GameLobby)</li> <li>drawAsteriodTwo (GameUI::GameLobby)</li> <li>drawBackground (GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, Menu)</li> <li>drawGameLobby (GameUI::GameLobby, Menu)</li> <li>drawLifeBoard (GameUI::GamePlay)</li> <li>drawTeamScore (GameUI::GamePlay)</li> <li>drawGameSetting (GameUI::GameSetting)</li> <li>drawBackButton (GameUI::RoomLobby)</li> <li>drawRoomLobby (GameUI::RoomLobby)</li> <li>destroyImage (ImageManager)</li> <li>draw (ImageManager, Parallax)</li> <li>down (Input, InputManager::Button)</li> <li>decreaseResolution (Menu)</li> <li>decreaseVolume (Menu)</li> <li>drawMainMenu (Menu)</li> <li>drawSettingsBackground (Menu)</li> <li>drawSettingsElements (Menu)</li> <li>drawSoundToggle (Menu)</li> <li>drawCircle (ShapeManager)</li> <li>drawRectangle (ShapeManager)</li> <li>duration (TemporaryText)</li> <li>drawText (TextManager, WindowManager)</li> <li>drawTextTemporarily (TextManager)</li> <li>dot (Vector2D)</li> <li>data (protocol::PlayerAction)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#e","title":"e","text":"<ul> <li>enemie1 (Client)</li> <li>enemie2 (Client)</li> <li>enemie3 (Client)</li> <li>enemie4 (Client)</li> <li>enemie5 (Client)</li> <li>enemie6 (Client)</li> <li>enemie7 (Client)</li> <li>enemie8 (Client)</li> <li>enemie9 (Client)</li> <li>enemieBoss (Client)</li> <li>enemies (Client)</li> <li>enemies_id (Client)</li> <li>event (Client, TextManager, WindowManager)</li> <li>Entity (Entity)</li> <li>enemies1 (GameUI::GamePlay)</li> <li>enemies2 (GameUI::GamePlay)</li> <li>enemies3 (GameUI::GamePlay)</li> <li>enemies4 (GameUI::GamePlay)</li> <li>enemies5 (GameUI::GamePlay)</li> <li>enemies6 (GameUI::GamePlay)</li> <li>enemies7 (GameUI::GamePlay)</li> <li>enemies8 (GameUI::GamePlay)</li> <li>enemies9 (GameUI::GamePlay)</li> <li>enemiesBoss (GameUI::GamePlay)</li> <li>escape (InputManager::Button)</li> <li>enemy_move (MouvementSystem)</li> <li>enemyTimer (Server)</li> <li>enemy_count (Server)</li> <li>event_data (protocol::EventNotification)</li> <li>event_type (protocol::EventNotification)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#f","title":"f","text":"<ul> <li>frameTime (Animation)</li> <li>font (Client, GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, TextManager, WindowManager)</li> <li>fitToScreen (ImageManager)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#g","title":"g","text":"<ul> <li>getPosition (Animation)</li> <li>getSprite (Animation, ImageManager)</li> <li>GamePlayImage (Client, GameUI::GamePlay)</li> <li>game_over (Client)</li> <li>get_enemy_color (Client)</li> <li>get_name (Client)</li> <li>get_player_color (Client)</li> <li>GameCore (GameUI::GameCore)</li> <li>GameLobby (GameUI::GameLobby)</li> <li>GameLobbyImage (GameUI::GameLobby, Menu)</li> <li>getAsteriodFourSprite (GameUI::GameLobby)</li> <li>getAsteriodOneSprite (GameUI::GameLobby)</li> <li>getAsteriodThreeSprite (GameUI::GameLobby)</li> <li>getAsteriodTwoSprite (GameUI::GameLobby)</li> <li>getBackgroundSprite (GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, Menu)</li> <li>getButtonSound (GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby)</li> <li>getGameLobbySprite (GameUI::GameLobby, Menu)</li> <li>getMouse (GameUI::GameLobby, GameUI::RoomLobby)</li> <li>getRect1 (GameUI::GameLobby, GameUI::GameSetting, GameUI::RoomLobby, Menu)</li> <li>getRect2 (GameUI::GameLobby, GameUI::GameSetting, GameUI::RoomLobby, Menu)</li> <li>getRoomMusic (GameUI::GameLobby)</li> <li>GamePlay (GameUI::GamePlay)</li> <li>getLifeBoardSprite (GameUI::GamePlay)</li> <li>getTeamScoreSprite (GameUI::GamePlay)</li> <li>GameSetting (GameUI::GameSetting)</li> <li>GameSettingImage (GameUI::GameSetting)</li> <li>getGameSettingSprite (GameUI::GameSetting)</li> <li>getBackButtonSprite (GameUI::RoomLobby)</li> <li>getRect3 (GameUI::RoomLobby)</li> <li>getRect4 (GameUI::RoomLobby)</li> <li>getRoomLobbySprite (GameUI::RoomLobby)</li> <li>getTextIp (GameUI::RoomLobby)</li> <li>getTextName (GameUI::RoomLobby)</li> <li>getTextPort (GameUI::RoomLobby)</li> <li>getGlobalBounds (ImageManager)</li> <li>getButton (InputManager)</li> <li>getPlayButtonSprite (Menu)</li> <li>goBackButtonImage (Menu)</li> <li>getMouseX (MouseManager)</li> <li>getMouseY (MouseManager)</li> <li>get_entities (Registry)</li> <li>getScore (Score)</li> <li>game_run (Server)</li> <li>get_player_entity (Server)</li> <li>get_player_id (Server)</li> <li>get_player_name (Server)</li> <li>GetWindow (TextManager, WindowManager)</li> <li>getElapsedTimeInSeconds (TimeManager)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#h","title":"h","text":"<ul> <li>health (Entity)</li> <li>handleEvent (GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, GameUI::ScreenManager, IScreen, TextManager, WindowManager)</li> <li>Health (Health)</li> <li>handleInput (InputManager, MouvementSystem)</li> <li>handleButtonClicks (Menu)</li> <li>handleEvents (Menu)</li> <li>handleMouseEvents (Menu)</li> <li>handleNavigationClicks (Menu)</li> <li>handleResolutionClicks (Menu)</li> <li>handleSettingsClicks (Menu)</li> <li>handleSettingsEvents (Menu)</li> <li>handleSoundToggleClicks (Menu)</li> <li>handleVolumeClicks (Menu)</li> <li>handleWindowEvents (Menu)</li> <li>handleMousePosition (MouseManager)</li> <li>handle_client_ping (Server)</li> <li>handle_list_rooms (Server)</li> <li>handle_room_creation (Server)</li> <li>handle_room_joining (Server)</li> <li>handle_tcp_connection (Server)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#i","title":"i","text":"<ul> <li>input (Client, Entity, GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, TextManager, WindowManager)</li> <li>inputIp (GameUI::RoomLobby)</li> <li>inputName (GameUI::RoomLobby)</li> <li>inputPort (GameUI::RoomLobby)</li> <li>ImageManager (ImageManager)</li> <li>Input (Input)</li> <li>InputManager (InputManager)</li> <li>increaseResolution (Menu)</li> <li>increaseVolume (Menu)</li> <li>infButton (Menu)</li> <li>initializeMusic (Menu)</li> <li>inputManager (Menu)</li> <li>isSoundOn (Menu)</li> <li>in_game (Room_System::Room)</li> <li>id_name (Server)</li> <li>io_context (ThreadPool)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#j","title":"j","text":"<ul> <li>join_room (Room_System)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#k","title":"k","text":"<ul> <li>keepOpen (WindowManager)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#l","title":"l","text":"<ul> <li>loadAnimation (Animation)</li> <li>LifeBoardImage (Client, GameUI::GamePlay)</li> <li>loadFont (GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, TextManager, WindowManager)</li> <li>left (Input, InputManager::Button)</li> <li>loadAndSetupImage (Menu)</li> <li>loadImages (Menu)</li> <li>loadResolutionImages (Menu)</li> <li>loadVolumeImages (Menu)</li> <li>leave_room (Room_System)</li> <li>list_available_rooms (Room_System)</li> <li>last_ping (Server::ClientInfo)</li> <li>length (Vector2D)</li> <li>length_squared (Vector2D)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#m","title":"m","text":"<ul> <li>moveXLeft (Animation)</li> <li>moveXRight (Animation)</li> <li>moveY (Animation)</li> <li>moveYUp (Animation)</li> <li>music (AudioManager, Menu)</li> <li>mouse (GameUI::GameLobby, GameUI::GameSetting, GameUI::RoomLobby, WindowManager)</li> <li>maxHealth (Health)</li> <li>Menu (Menu)</li> <li>moinsButton (Menu)</li> <li>mouseManager (Menu)</li> <li>MouseManager (MouseManager)</li> <li>MouvementSystem (MouvementSystem)</li> <li>move_player (MouvementSystem)</li> <li>max_players (Room_System::Room)</li> <li>movement (Server)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#n","title":"n","text":"<ul> <li>name (Entity, Name, Room_System::Room, parameter_t)</li> <li>Name (Name)</li> <li>next_room_id (Room_System)</li> <li>notify_clients_of_disconnection (Server)</li> <li>normalize (Vector2D)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#o","title":"o","text":"<ul> <li>operator() (EndpointEqual, EndpointHash)</li> <li>offImage (Menu)</li> <li>onImage (Menu)</li> <li>openSettings (Menu)</li> <li>operator/ (Vector2D)</li> <li>operator/= (Vector2D)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#p","title":"p","text":"<ul> <li>pauseMusic (AudioManager)</li> <li>playMusic (AudioManager)</li> <li>playSound (AudioManager)</li> <li>player1 (Client, GameUI::GamePlay)</li> <li>player2 (Client, GameUI::GamePlay)</li> <li>players (Client, Room_System::Room)</li> <li>players_id (Client)</li> <li>projectiles (Client)</li> <li>projectiles_id (Client)</li> <li>playIsDown (GameUI::GamePlay)</li> <li>playIsLeft (GameUI::GamePlay)</li> <li>playIsRight (GameUI::GamePlay)</li> <li>playIsUp (GameUI::GamePlay)</li> <li>plusButton (Menu)</li> <li>Parallax (Parallax)</li> <li>players_count (Server)</li> <li>process_message (Server)</li> <li>process_message_contain (Server)</li> <li>projectile_count (Server)</li> <li>position (Transform)</li> <li>player_id (protocol::PlayerAction)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#r","title":"r","text":"<ul> <li>render (Animation, GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, GameUI::ScreenManager, IScreen, Menu, TextManager, WindowManager)</li> <li>resumeMusic (AudioManager)</li> <li>RoomMusic (GameUI::GameCore, GameUI::GameLobby)</li> <li>roomLobby (GameUI::GameCore)</li> <li>run (GameUI::GameCore, Menu)</li> <li>rect1 (GameUI::GameLobby, GameUI::GameSetting, GameUI::RoomLobby, Menu)</li> <li>rect2 (GameUI::GameLobby, GameUI::GameSetting, GameUI::RoomLobby, Menu)</li> <li>RoomLobby (GameUI::RoomLobby)</li> <li>RoomLobbyImage (GameUI::RoomLobby)</li> <li>rect3 (GameUI::RoomLobby)</li> <li>rect4 (GameUI::RoomLobby)</li> <li>reset (Input)</li> <li>right (Input, InputManager::Button)</li> <li>renderSettings (Menu)</li> <li>resolutionSprite (Menu)</li> <li>resolutionTextures (Menu)</li> <li>resolutions (Menu)</li> <li>remove_entity (Registry)</li> <li>Room_System (Room_System)</li> <li>remove_room (Room_System)</li> <li>rooms (Room_System)</li> <li>registry (Server)</li> <li>room_system (Server)</li> <li>run_game (Server)</li> <li>release (ThreadPool)</li> <li>remove_threads (ThreadPool)</li> <li>restart (TimeManager)</li> <li>rotate (Vector2D)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#s","title":"s","text":"<ul> <li>setPosition (Animation, ImageManager)</li> <li>setScale (Animation, ImageManager)</li> <li>sprite (Animation, AnimationData, ImageManager)</li> <li>setMusicVolume (AudioManager)</li> <li>setPitch (AudioManager)</li> <li>setSoundVolume (AudioManager)</li> <li>sound (AudioManager)</li> <li>size (BBox)</li> <li>send_tcp_message (Client)</li> <li>send_udp_message (Client)</li> <li>server_tcp_ip (Client)</li> <li>server_udp_ip (Client)</li> <li>shapeManager1 (Client, GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby)</li> <li>shapeManager2 (Client, GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby)</li> <li>score (Entity)</li> <li>screenManager (GameUI::GameCore, GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby)</li> <li>setAsteriodFour (GameUI::GameLobby)</li> <li>setAsteriodOne (GameUI::GameLobby)</li> <li>setAsteriodThree (GameUI::GameLobby)</li> <li>setAsteriodTwo (GameUI::GameLobby)</li> <li>setBackground (GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, Menu)</li> <li>setGameLobby (GameUI::GameLobby)</li> <li>shapebuilder (GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby)</li> <li>setLifeBoard (GameUI::GamePlay)</li> <li>setTeamScore (GameUI::GamePlay)</li> <li>spawnRandomEnemies (GameUI::GamePlay)</li> <li>setGameSetting (GameUI::GameSetting)</li> <li>setBackButton (GameUI::RoomLobby)</li> <li>setRoomLobby (GameUI::RoomLobby)</li> <li>shapeManager3 (GameUI::RoomLobby)</li> <li>shapeManager4 (GameUI::RoomLobby)</li> <li>ScreenManager (GameUI::ScreenManager)</li> <li>screens (GameUI::ScreenManager)</li> <li>switchToScreen (GameUI::ScreenManager)</li> <li>shoot (Input, Server)</li> <li>screenResolutionImage (Menu)</li> <li>screen_infButton (Menu)</li> <li>screen_supButton (Menu)</li> <li>setVolumeImage (Menu)</li> <li>settingsButtonImage (Menu)</li> <li>settingsOpen (Menu)</li> <li>soundImage (Menu)</li> <li>startButtonImage (Menu)</li> <li>supButton (Menu)</li> <li>system_movement (MouvementSystem)</li> <li>speed1 (Parallax)</li> <li>speed2 (Parallax)</li> <li>sprite1 (Parallax)</li> <li>sprite2 (Parallax)</li> <li>start_game_in_room (Room_System)</li> <li>Score (Score)</li> <li>scoreValue (Score)</li> <li>set_score (Score)</li> <li>Server (Server)</li> <li>send_udp_with_ack (Server)</li> <li>shootTimer (Server)</li> <li>start_heartbeat_monitor (Server)</li> <li>start_tcp_server (Server)</li> <li>start_udp_server (Server)</li> <li>ShapeManager (ShapeManager)</li> <li>spawn_projectile (ShootSystem)</li> <li>start (TimeManager)</li> <li>scale (Vector2D)</li> <li>SetWindowSize (WindowManager)</li> <li>state_data (protocol::GameStateUpdate)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#t","title":"t","text":"<ul> <li>texture (Animation, ImageManager)</li> <li>totalFrames (AnimationData)</li> <li>TeamScoreImage (Client, GameUI::GamePlay)</li> <li>transform (Entity)</li> <li>textip (GameUI::GameLobby, GameUI::GameSetting, GameUI::RoomLobby)</li> <li>textname (GameUI::GameLobby, GameUI::GameSetting, GameUI::RoomLobby)</li> <li>textfieldsetter (GameUI::RoomLobby)</li> <li>textport (GameUI::RoomLobby)</li> <li>takeDamage (Health)</li> <li>texture1 (Parallax)</li> <li>texture2 (Parallax)</li> <li>text (TemporaryText)</li> <li>TextManager (TextManager)</li> <li>tempTexts (TextManager, WindowManager)</li> <li>ThreadPool (ThreadPool)</li> <li>thread_pool (ThreadPool)</li> <li>TimeManager (TimeManager)</li> <li>Transform (Transform)</li> <li>tcp_port (server_me_t)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#u","title":"u","text":"<ul> <li>update (Animation, GameUI::GameLobby, GameUI::GamePlay, GameUI::GameSetting, GameUI::RoomLobby, GameUI::ScreenManager, IScreen, Menu, Parallax)</li> <li>up (Input, InputManager::Button)</li> <li>updateElementPosition (Menu)</li> <li>updateElementPositions (Menu)</li> <li>updateResolutionImage (Menu)</li> <li>updateVolumeImage (Menu)</li> <li>updateTimer (Server)</li> <li>usage (parameter_t)</li> <li>udp_port (server_me_t)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#v","title":"v","text":"<ul> <li>volumeLevel (Menu)</li> <li>volumeSprite (Menu)</li> <li>volumeTextures (Menu)</li> <li>velocity (Transform)</li> <li>Vector2D (Vector2D)</li> <li>vector_unit (Vector2D)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#w","title":"w","text":"<ul> <li>window (Client, GameUI::GameCore, GameUI::ScreenManager, Menu, WindowManager)</li> <li>window_manager (Client)</li> <li>windowManager (Menu)</li> <li>WindowManager (WindowManager)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#x","title":"x","text":"<ul> <li>x (MouseManager, Vector2D)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#y","title":"y","text":"<ul> <li>y (MouseManager, Vector2D)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#_1","title":"~","text":"<ul> <li>~Animation (Animation)</li> <li>~AudioManager (AudioManager)</li> <li>~Client (Client)</li> <li>~CollisionSystem (CollisionSystem)</li> <li>~IScreen (IScreen)</li> <li>~ImageManager (ImageManager)</li> <li>~InputManager (InputManager)</li> <li>~MouseManager (MouseManager)</li> <li>~MouvementSystem (MouvementSystem)</li> <li>~Room_System (Room_System)</li> <li>~Server (Server)</li> <li>~ShapeManager (ShapeManager)</li> <li>~ThreadPool (ThreadPool)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/class_members/#_","title":"_","text":"<ul> <li>_health (Client)</li> <li>_io_context (Client)</li> <li>_receiver_endpoint (Client)</li> <li>_score (Client)</li> <li>_soc (Client)</li> <li>_alive (Entity)</li> <li>_id (Entity)</li> <li>_tag (Entity)</li> <li>_entities_count (Registry)</li> <li>_entities_map (Registry)</li> <li>_entities_vector (Registry)</li> <li>_new_entities (Registry)</li> <li>_connected_clients (Server)</li> <li>_game_time_manager (Server)</li> <li>_name (Server)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classes/","title":"Class Index","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classes/#a","title":"a","text":"<ul> <li>Animation</li> <li>AnimationData</li> <li>AudioManager</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classes/#b","title":"b","text":"<ul> <li>BBox</li> <li>Button</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classes/#c","title":"c","text":"<ul> <li>Client</li> <li>ClientInfo</li> <li>CoinSystem</li> <li>CollisionSystem</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classes/#e","title":"e","text":"<ul> <li>EndpointEqual</li> <li>EndpointHash</li> <li>Entity</li> <li>EventNotification (protocol)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classes/#g","title":"g","text":"<ul> <li>GameCore (GameUI)</li> <li>GameLobby (GameUI)</li> <li>GamePlay (GameUI)</li> <li>GameSetting (GameUI)</li> <li>GameStateUpdate (protocol)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classes/#h","title":"h","text":"<ul> <li>Health</li> <li>HealthSystem</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classes/#i","title":"i","text":"<ul> <li>ImageManager</li> <li>Input</li> <li>InputManager</li> <li>IScreen</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classes/#m","title":"m","text":"<ul> <li>Menu</li> <li>MouseManager</li> <li>MouvementSystem</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classes/#n","title":"n","text":"<ul> <li>Name</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classes/#p","title":"p","text":"<ul> <li>Parallax</li> <li>parameter_t</li> <li>PlayerAction (protocol)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classes/#r","title":"r","text":"<ul> <li>Registry</li> <li>Room</li> <li>Room_System</li> <li>RoomLobby (GameUI)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classes/#s","title":"s","text":"<ul> <li>Score</li> <li>ScreenManager (GameUI)</li> <li>Server</li> <li>server_me_t</li> <li>ShapeManager</li> <li>ShootSystem</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classes/#t","title":"t","text":"<ul> <li>TemporaryText</li> <li>TextManager</li> <li>ThreadPool</li> <li>TimeManager</li> <li>Transform</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classes/#v","title":"v","text":"<ul> <li>Vector2D</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/classes/#w","title":"w","text":"<ul> <li>WindowManager</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_011a5bb273ab46acf9be02ac4bf7f0a3/","title":"Dir include/Engine/Input","text":"<p>FileList &gt; Engine &gt; Input</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_011a5bb273ab46acf9be02ac4bf7f0a3/#files","title":"Files","text":"Type Name file InputManager.hpp <p>The documentation for this class was generated from the following file <code>include/Engine/Input/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_127bf1d17e553df95a92f785db2d2430/","title":"Dir include/Engine/Parallax","text":"<p>FileList &gt; Engine &gt; Parallax</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_127bf1d17e553df95a92f785db2d2430/#files","title":"Files","text":"Type Name file parallax.hpp <p>The documentation for this class was generated from the following file <code>include/Engine/Parallax/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_133b3cdd880ca9e91a51b18f00995eeb/","title":"Dir src/Client","text":"<p>FileList &gt; Client</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_133b3cdd880ca9e91a51b18f00995eeb/#files","title":"Files","text":"Type Name file GameCore.cpp file GameCore.hpp file GameLobby.cpp file GameLobby.hpp file GamePlay.cpp file GamePlay.hpp file GameSetting.cpp file GameSetting.hpp file RoomLobby.cpp file RoomLobby.hpp file ScreenManager.cpp file ScreenManager.hpp file main.cpp"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_133b3cdd880ca9e91a51b18f00995eeb/#directories","title":"Directories","text":"Type Name dir Save <p>The documentation for this class was generated from the following file <code>src/Client/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_17f455aea618a06e8886390757d4c564/","title":"Dir include/Server","text":"<p>FileList &gt; include &gt; Server</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_17f455aea618a06e8886390757d4c564/#files","title":"Files","text":"Type Name file Client.hpp file Coin_system.hpp file Collision_system.hpp file Entity.hpp file Health_system.hpp file Mouvement_system.hpp file Server.hpp file Shoot_system.hpp file ThreadPool.hpp file Time_manager.hpp file Vector.hpp file protocol.hpp file room_system.hpp <p>The documentation for this class was generated from the following file <code>include/Server/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_19cd604a8f0e57207fc6eb0bc4ed780e/","title":"Dir src/Engine/Parallax","text":"<p>FileList &gt; Engine &gt; Parallax</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_19cd604a8f0e57207fc6eb0bc4ed780e/#files","title":"Files","text":"Type Name file parallax.cpp <p>The documentation for this class was generated from the following file <code>src/Engine/Parallax/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_306a0e6e66590168765549196d987f73/","title":"Dir src/Engine/Animation","text":"<p>FileList &gt; Animation</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_306a0e6e66590168765549196d987f73/#files","title":"Files","text":"Type Name file Animation.cpp <p>The documentation for this class was generated from the following file <code>src/Engine/Animation/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_3072bc1f55ed1280fe4fbe6b21c78379/","title":"Dir src/Engine","text":"<p>FileList &gt; Engine</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_3072bc1f55ed1280fe4fbe6b21c78379/#directories","title":"Directories","text":"Type Name dir Animation dir Audio dir Image dir Input dir Mouse dir Parallax dir Shape <p>The documentation for this class was generated from the following file <code>src/Engine/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_430e7e5a0f7cd3d6a7efc744827f42b5/","title":"Dir src/Engine/Shape","text":"<p>FileList &gt; Engine &gt; Shape</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_430e7e5a0f7cd3d6a7efc744827f42b5/#files","title":"Files","text":"Type Name file ShapeManager.cpp <p>The documentation for this class was generated from the following file <code>src/Engine/Shape/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_68267d1309a1af8e8297ef4c3efbcdba/","title":"Dir src","text":"<p>FileList &gt; src</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","title":"Directories","text":"Type Name dir Client dir Engine dir Server <p>The documentation for this class was generated from the following file <code>src/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_6b283f0e52bc253c2977cc1de7c30b9b/","title":"Dir src/Engine/Mouse","text":"<p>FileList &gt; Engine &gt; Mouse</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_6b283f0e52bc253c2977cc1de7c30b9b/#files","title":"Files","text":"Type Name file MouseManager.cpp <p>The documentation for this class was generated from the following file <code>src/Engine/Mouse/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_7dd3fffce23fd825de4eb623b113c1bd/","title":"Dir include/Engine","text":"<p>FileList &gt; Engine</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_7dd3fffce23fd825de4eb623b113c1bd/#directories","title":"Directories","text":"Type Name dir Animation dir Audio dir Image dir Input dir Mouse dir Parallax dir Shape <p>The documentation for this class was generated from the following file <code>include/Engine/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_7f2caee7a039a4df72b6a79e2fa54694/","title":"Dir src/Client/Save","text":"<p>FileList &gt; Client &gt; Save</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_7f2caee7a039a4df72b6a79e2fa54694/#files","title":"Files","text":"Type Name file Menu.cpp file Menu.hpp file MenuWindowManager.cpp file MenuWindowManager.hpp file SettingGame.cpp <p>The documentation for this class was generated from the following file <code>src/Client/Save/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_9d4cae504f03fb905f759f63b05c069d/","title":"Dir include/Engine/Image","text":"<p>FileList &gt; Engine &gt; Image</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_9d4cae504f03fb905f759f63b05c069d/#files","title":"Files","text":"Type Name file ImageManager.hpp <p>The documentation for this class was generated from the following file <code>include/Engine/Image/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_c82188eaffb96b2487ed13b79df10c60/","title":"Dir include/Engine/Audio","text":"<p>FileList &gt; Audio</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_c82188eaffb96b2487ed13b79df10c60/#files","title":"Files","text":"Type Name file AudioManager.hpp <p>The documentation for this class was generated from the following file <code>include/Engine/Audio/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_cc001759347ed62121aae3ac8586610a/","title":"Dir src/Engine/Input","text":"<p>FileList &gt; Engine &gt; Input</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_cc001759347ed62121aae3ac8586610a/#files","title":"Files","text":"Type Name file InputManager.cpp <p>The documentation for this class was generated from the following file <code>src/Engine/Input/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_d16831a22b1176c437f87c2d0440ff32/","title":"Dir include/Engine/Animation","text":"<p>FileList &gt; Animation</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_d16831a22b1176c437f87c2d0440ff32/#files","title":"Files","text":"Type Name file Animation.hpp <p>The documentation for this class was generated from the following file <code>include/Engine/Animation/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_d430bb2cf01387b823ae007b3e5a1c3c/","title":"Dir include/Engine/Shape","text":"<p>FileList &gt; Engine &gt; Shape</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_d430bb2cf01387b823ae007b3e5a1c3c/#files","title":"Files","text":"Type Name file ShapeManager.hpp <p>The documentation for this class was generated from the following file <code>include/Engine/Shape/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_d44c64559bbebec7f509842c48db8b23/","title":"Dir include","text":"<p>FileList &gt; include</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_d44c64559bbebec7f509842c48db8b23/#directories","title":"Directories","text":"Type Name dir Engine dir Server <p>The documentation for this class was generated from the following file <code>include/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_f193d769e7e735a6067828aa983bf770/","title":"Dir include/Engine/Mouse","text":"<p>FileList &gt; Engine &gt; Mouse</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_f193d769e7e735a6067828aa983bf770/#files","title":"Files","text":"Type Name file MouseManager.hpp <p>The documentation for this class was generated from the following file <code>include/Engine/Mouse/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_f379be214ac3ab501d342456492bfadc/","title":"Dir src/Engine/Audio","text":"<p>FileList &gt; Audio</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_f379be214ac3ab501d342456492bfadc/#files","title":"Files","text":"Type Name file AudioManager.cpp <p>The documentation for this class was generated from the following file <code>src/Engine/Audio/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_f6675a7e1cd1d6d7f6e5e9669ead62e8/","title":"Dir src/Server","text":"<p>FileList &gt; Server</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_f6675a7e1cd1d6d7f6e5e9669ead62e8/#files","title":"Files","text":"Type Name file Client.cpp file Coin_system.cpp file Collision_system.cpp file Entity.cpp file Health_system.cpp file Mouvement_system.cpp file Server.cpp file Shoot_system.cpp file Time_manager.cpp file Vector3D.cpp file check_message.cpp file check_params.cpp file protocol.cpp file robustness.cpp file room_system.cpp file server_room.cpp <p>The documentation for this class was generated from the following file <code>src/Server/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_fe84c1fa4d9371df2d37e162ea73f06d/","title":"Dir src/Engine/Image","text":"<p>FileList &gt; Engine &gt; Image</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/dir_fe84c1fa4d9371df2d37e162ea73f06d/#files","title":"Files","text":"Type Name file ImageManager.cpp <p>The documentation for this class was generated from the following file <code>src/Engine/Image/</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir include <ul> <li>dir Engine <ul> <li>dir Animation <ul> <li>file Animation.hpp </li> </ul> </li> <li>dir Audio <ul> <li>file AudioManager.hpp </li> </ul> </li> <li>dir Image <ul> <li>file ImageManager.hpp </li> </ul> </li> <li>dir Input <ul> <li>file InputManager.hpp </li> </ul> </li> <li>dir Mouse <ul> <li>file MouseManager.hpp </li> </ul> </li> <li>dir Parallax <ul> <li>file parallax.hpp </li> </ul> </li> <li>dir Shape <ul> <li>file ShapeManager.hpp </li> </ul> </li> </ul> </li> <li>dir Server <ul> <li>file Client.hpp </li> <li>file Coin_system.hpp </li> <li>file Collision_system.hpp </li> <li>file Entity.hpp </li> <li>file Health_system.hpp </li> <li>file Mouvement_system.hpp </li> <li>file Server.hpp </li> <li>file Shoot_system.hpp </li> <li>file ThreadPool.hpp </li> <li>file Time_manager.hpp </li> <li>file Vector.hpp </li> <li>file protocol.hpp </li> <li>file room_system.hpp </li> </ul> </li> </ul> </li> <li>dir src <ul> <li>dir Client <ul> <li>file GameCore.cpp </li> <li>file GameCore.hpp </li> <li>file GameLobby.cpp </li> <li>file GameLobby.hpp </li> <li>file GamePlay.cpp </li> <li>file GamePlay.hpp </li> <li>file GameSetting.cpp </li> <li>file GameSetting.hpp </li> <li>file RoomLobby.cpp </li> <li>file RoomLobby.hpp </li> <li>file ScreenManager.cpp </li> <li>file ScreenManager.hpp </li> <li>file main.cpp </li> <li>dir Save <ul> <li>file Menu.cpp </li> <li>file Menu.hpp </li> <li>file MenuWindowManager.cpp </li> <li>file MenuWindowManager.hpp </li> <li>file SettingGame.cpp </li> </ul> </li> </ul> </li> <li>dir Engine <ul> <li>dir Animation <ul> <li>file Animation.cpp </li> </ul> </li> <li>dir Audio <ul> <li>file AudioManager.cpp </li> </ul> </li> <li>dir Image <ul> <li>file ImageManager.cpp </li> </ul> </li> <li>dir Input <ul> <li>file InputManager.cpp </li> </ul> </li> <li>dir Mouse <ul> <li>file MouseManager.cpp </li> </ul> </li> <li>dir Parallax <ul> <li>file parallax.cpp </li> </ul> </li> <li>dir Shape <ul> <li>file ShapeManager.cpp </li> </ul> </li> </ul> </li> <li>dir Server <ul> <li>file Client.cpp </li> <li>file Coin_system.cpp </li> <li>file Collision_system.cpp </li> <li>file Entity.cpp </li> <li>file Health_system.cpp </li> <li>file Mouvement_system.cpp </li> <li>file Server.cpp </li> <li>file Shoot_system.cpp </li> <li>file Time_manager.cpp </li> <li>file Vector3D.cpp </li> <li>file check_message.cpp </li> <li>file check_params.cpp </li> <li>file protocol.cpp </li> <li>file robustness.cpp </li> <li>file room_system.cpp </li> <li>file server_room.cpp </li> </ul> </li> </ul> </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/functions/","title":"Functions","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/functions/#a","title":"a","text":"<ul> <li>add_to_server_struct (check_params.cpp)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/functions/#i","title":"i","text":"<ul> <li>initialize_parameters (check_params.cpp)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/functions/#m","title":"m","text":"<ul> <li>main (main.cpp, Menu.cpp, Server.cpp)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/functions/#o","title":"o","text":"<ul> <li>operator* (Vector.hpp, Vector3D.cpp)</li> <li>operator+ (Vector.hpp, Vector3D.cpp)</li> <li>operator- (Vector.hpp, Vector3D.cpp)</li> <li>operator*= (Vector3D.cpp)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/functions/#r","title":"r","text":"<ul> <li>recup_args (Server.hpp, check_params.cpp)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/functions/#s","title":"s","text":"<ul> <li>sup_int_spec (check_params.cpp)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/functions/#u","title":"u","text":"<ul> <li>usage (check_params.cpp)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class Animation </li> <li>class AudioManager Handles sound and music playback using the SFML audio library. </li> <li>class BBox Component representing the size of an entity's bounding box. </li> <li>class Client Manages the client's interaction with the server and handles rendering, networking, and gameplay logic. </li> <li>class CoinSystem Manages the logic related to coins within the ECS ( Entity Component System).</li> <li>class CollisionSystem Handles collision detection and responses in the ECS ( Entity Component System).</li> <li>class Entity Represents a game object composed of multiple components. </li> <li>class GameUI::GameCore </li> <li>class IScreen <ul> <li>class GameUI::GameLobby </li> <li>class GameUI::GamePlay </li> <li>class GameUI::GameSetting </li> <li>class GameUI::RoomLobby </li> </ul> </li> <li>class GameUI::ScreenManager </li> <li>class Health Component to manage an entity's health state. </li> <li>class HealthSystem Forward declaration of the Registry class.</li> <li>class ImageManager Handles image loading, manipulation, and rendering using the SFML graphics library. </li> <li>class Input Component to track player input actions (e.g., movement or shooting). </li> <li>class InputManager Manages keyboard and window input events using the SFML library. </li> <li>class Menu </li> <li>class MouseManager Manages mouse input and tracks the mouse position within a window. </li> <li>class MouvementSystem Forward declaration of the Registry class.</li> <li>class Name Component to store the name of an entity. </li> <li>class Parallax </li> <li>class Registry Manages all entities in the game and their lifecycle. </li> <li>class Room_System Class responsible for managing game rooms. </li> <li>class Score Component to manage an entity's score during gameplay. </li> <li>class Server A class representing the server managing TCP/UDP connections and game state. </li> <li>class ShapeManager Manages and renders geometric shapes using the SFML graphics library. </li> <li>class ShootSystem &lt; Includes the Entity class for representing game entities.</li> <li>class TextManager </li> <li>class ThreadPool A class representing a thread pool for managing asynchronous tasks. </li> <li>class TimeManager A class to manage time tracking for elapsed time measurements. </li> <li>class Transform Component representing an entity's position and velocity in 2D space. </li> <li>class Vector2D A class to represent a 2D vector. </li> <li>class WindowManager </li> <li>struct AnimationData </li> <li>struct EndpointEqual Comparator for UDP endpoints. </li> <li>struct EndpointHash Hash function for UDP endpoints. </li> <li>struct InputManager::Button Tracks the state of specific control buttons. </li> <li>struct Room_System::Room Struct representing a game room. </li> <li>struct Server::ClientInfo Structure containing information about connected clients. </li> <li>struct TemporaryText </li> <li>struct parameter_t Structure representing a command-line parameter. </li> <li>struct protocol::EventNotification Structure representing a notification about a game event. </li> <li>struct protocol::GameStateUpdate Structure representing an update to the game state. </li> <li>struct protocol::PlayerAction Structure representing a player's action. </li> <li>struct server_me_t Struct representing the server configuration. </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/macros/","title":"Macros","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/macros/#b","title":"b","text":"<ul> <li>BASE_HEIGHT (GameCore.hpp, Menu.hpp)</li> <li>BASE_WIDTH (GameCore.hpp, Menu.hpp)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/macros/#p","title":"p","text":"<ul> <li>PLAY_BUTTON_X (GameLobby.hpp)</li> <li>PLAY_BUTTON_Y (GameLobby.hpp)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/macros/#s","title":"s","text":"<ul> <li>SETTING_BUTTON_X (GameLobby.hpp)</li> <li>SETTING_BUTTON_Y (GameLobby.hpp)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/main_8cpp/","title":"File main.cpp","text":"<p>FileList &gt; Client &gt; main.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"GameCore.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/main_8cpp/#public-functions","title":"Public Functions","text":"Type Name int main ()"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/main_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/main_8cpp/#function-main","title":"function main","text":"<pre><code>int main () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/Client/main.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/main_8cpp_source/","title":"File main.cpp","text":"<p>File List &gt; Client &gt; main.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"GameCore.hpp\"\n\nint main()\n{\n    GameUI::GameCore game;\n    game.run();\n    return 0;\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespaceGameUI/","title":"Namespace GameUI","text":"<p>Namespace List &gt; GameUI</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespaceGameUI/#classes","title":"Classes","text":"Type Name class GameCore class GameLobby class GamePlay class GameSetting class RoomLobby class ScreenManager <p>The documentation for this class was generated from the following file <code>src/Client/GameCore.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespace_member_enums/#m","title":"m","text":"<ul> <li>MessageType (protocol)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespace_member_functions/#d","title":"d","text":"<ul> <li>deserialize (protocol)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespace_member_functions/#s","title":"s","text":"<ul> <li>serialize (protocol)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespace_members/","title":"Namespace Members","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespace_members/#d","title":"d","text":"<ul> <li>deserialize (protocol)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespace_members/#m","title":"m","text":"<ul> <li>MessageType (protocol)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespace_members/#s","title":"s","text":"<ul> <li>serialize (protocol)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespaceprotocol/","title":"Namespace protocol","text":"<p>Namespace List &gt; protocol</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespaceprotocol/#classes","title":"Classes","text":"Type Name struct EventNotification Structure representing a notification about a game event. struct GameStateUpdate Structure representing an update to the game state. struct PlayerAction Structure representing a player's action."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespaceprotocol/#public-types","title":"Public Types","text":"Type Name enum uint8_t MessageType Enum class representing different types of messages exchanged between the client and server."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespaceprotocol/#public-functions","title":"Public Functions","text":"Type Name bool deserialize (const std::vector&lt; uint8_t &gt; &amp; buffer, PlayerAction &amp; msg) Deserializes a byte buffer into a PlayerAction message. bool deserialize (const std::vector&lt; uint8_t &gt; &amp; buffer, GameStateUpdate &amp; msg) Deserializes a byte buffer into a GameStateUpdate message. bool deserialize (const std::vector&lt; uint8_t &gt; &amp; buffer, EventNotification &amp; msg) Deserializes a byte buffer into an EventNotification message. std::vector&lt; uint8_t &gt; serialize (const PlayerAction &amp; msg) Serializes a PlayerAction message into a byte vector. std::vector&lt; uint8_t &gt; serialize (const GameStateUpdate &amp; msg) Serializes a GameStateUpdate message into a byte vector. std::vector&lt; uint8_t &gt; serialize (const EventNotification &amp; msg) Serializes an EventNotification message into a byte vector."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespaceprotocol/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespaceprotocol/#enum-messagetype","title":"enum MessageType","text":"<pre><code>enum protocol::MessageType {\n    PLAYER_ACTION = 1,\n    GAME_STATE_UPDATE = 2,\n    EVENT_NOTIFICATION = 3\n};\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespaceprotocol/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespaceprotocol/#function-deserialize","title":"function deserialize","text":"<p>Deserializes a byte buffer into a PlayerAction message. <pre><code>bool protocol::deserialize (\n    const std::vector&lt; uint8_t &gt; &amp; buffer,\n    PlayerAction &amp; msg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buffer</code> The byte vector containing the serialized data. </li> <li><code>msg</code> The PlayerAction message to populate with deserialized data. </li> </ul> <p>Returns:</p> <p>true if deserialization was successful, false otherwise. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespaceprotocol/#function-deserialize_1","title":"function deserialize","text":"<p>Deserializes a byte buffer into a GameStateUpdate message. <pre><code>bool protocol::deserialize (\n    const std::vector&lt; uint8_t &gt; &amp; buffer,\n    GameStateUpdate &amp; msg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buffer</code> The byte vector containing the serialized data. </li> <li><code>msg</code> The GameStateUpdate message to populate with deserialized data. </li> </ul> <p>Returns:</p> <p>true if deserialization was successful, false otherwise. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespaceprotocol/#function-deserialize_2","title":"function deserialize","text":"<p>Deserializes a byte buffer into an EventNotification message. <pre><code>bool protocol::deserialize (\n    const std::vector&lt; uint8_t &gt; &amp; buffer,\n    EventNotification &amp; msg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buffer</code> The byte vector containing the serialized data. </li> <li><code>msg</code> The EventNotification message to populate with deserialized data. </li> </ul> <p>Returns:</p> <p>true if deserialization was successful, false otherwise. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespaceprotocol/#function-serialize","title":"function serialize","text":"<p>Serializes a PlayerAction message into a byte vector. <pre><code>std::vector&lt; uint8_t &gt; protocol::serialize (\n    const PlayerAction &amp; msg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>msg</code> The PlayerAction message to serialize. </li> </ul> <p>Returns:</p> <p>A vector of bytes representing the serialized message. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespaceprotocol/#function-serialize_1","title":"function serialize","text":"<p>Serializes a GameStateUpdate message into a byte vector. <pre><code>std::vector&lt; uint8_t &gt; protocol::serialize (\n    const GameStateUpdate &amp; msg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>msg</code> The GameStateUpdate message to serialize. </li> </ul> <p>Returns:</p> <p>A vector of bytes representing the serialized message. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespaceprotocol/#function-serialize_2","title":"function serialize","text":"<p>Serializes an EventNotification message into a byte vector. <pre><code>std::vector&lt; uint8_t &gt; protocol::serialize (\n    const EventNotification &amp; msg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>msg</code> The EventNotification message to serialize. </li> </ul> <p>Returns:</p> <p>A vector of bytes representing the serialized message. </p> <p>The documentation for this class was generated from the following file <code>include/Server/protocol.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace GameUI </li> <li>namespace protocol </li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/parallax_8cpp/","title":"File parallax.cpp","text":"<p>FileList &gt; Engine &gt; Parallax &gt; parallax.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../../include/Engine/Parallax/parallax.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Engine/Parallax/parallax.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/parallax_8cpp_source/","title":"File parallax.cpp","text":"<p>File List &gt; Engine &gt; Parallax &gt; parallax.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"../../../include/Engine/Parallax/parallax.hpp\"\n\nParallax::Parallax(const std::string &amp;file1, const std::string &amp;file2, float speed1, float speed2)\n{\n    if (!texture1.loadFromFile(file1) || !texture2.loadFromFile(file2))\n    {\n        throw std::runtime_error(\"Impossible de charger les fichiers d'image.\");\n    }\n\n    sprite1.setTexture(texture1);\n    sprite2.setTexture(texture2);\n\n    this-&gt;speed1 = speed1;\n    this-&gt;speed2 = speed2;\n\n    sprite1.setPosition(0.f, 0.f);\n    sprite2.setPosition(1920.f, 0.f);\n}\n\nvoid Parallax::update(float deltaTime)\n{\n    sprite1.move(-speed1 * deltaTime, 0.f);\n    sprite2.move(-speed2 * deltaTime, 0.f);\n\n    if (sprite1.getPosition().x + texture1.getSize().x &lt; 0)\n    {\n        std::cout &lt;&lt; sprite1.getPosition().x + texture1.getSize().x &lt;&lt; std::endl;\n        sprite1.setPosition(1880.f, 0.f);\n    }\n    if (sprite2.getPosition().x + texture2.getSize().x &lt; 0)\n    {\n        std::cout &lt;&lt; sprite2.getPosition().x + texture2.getSize().x &lt;&lt; std::endl;\n        sprite2.setPosition(1880.f, 0.f);\n    }\n}\n\nvoid Parallax::draw(sf::RenderWindow &amp;window)\n{\n    window.draw(sprite2);\n    window.draw(sprite1);\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/parallax_8hpp/","title":"File parallax.hpp","text":"<p>FileList &gt; Engine &gt; Parallax &gt; parallax.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;SFML/Graphics.hpp&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/parallax_8hpp/#classes","title":"Classes","text":"Type Name class Parallax <p>The documentation for this class was generated from the following file <code>include/Engine/Parallax/parallax.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/parallax_8hpp_source/","title":"File parallax.hpp","text":"<p>File List &gt; Engine &gt; Parallax &gt; parallax.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;SFML/Graphics.hpp&gt;\n#include &lt;iostream&gt;\n\nclass Parallax\n{\npublic:\n    Parallax(const std::string &amp;file1, const std::string &amp;file2, float speed1, float speed2);\n    void update(float deltaTime);\n    void draw(sf::RenderWindow &amp;window);\n\nprivate:\n    sf::Texture texture1, texture2;\n    sf::Sprite sprite1, sprite2;\n    float speed1, speed2;\n};\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/protocol_8cpp/","title":"File protocol.cpp","text":"<p>FileList &gt; Server &gt; protocol.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../include/Server/protocol.hpp\"</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/protocol_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace protocol <p>The documentation for this class was generated from the following file <code>src/Server/protocol.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/protocol_8cpp_source/","title":"File protocol.cpp","text":"<p>File List &gt; Server &gt; protocol.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** protocol\n** File description:\n** protocol\n*/\n\n#include \"../../include/Server/protocol.hpp\"\n\nnamespace protocol\n{\n\n    std::vector&lt;uint8_t&gt; serialize(const PlayerAction &amp;msg)\n    {\n        std::vector&lt;uint8_t&gt; buffer;\n        buffer.push_back(static_cast&lt;uint8_t&gt;(MessageType::PLAYER_ACTION));\n        buffer.insert(buffer.end(), reinterpret_cast&lt;const uint8_t *&gt;(&amp;msg.player_id),\n                      reinterpret_cast&lt;const uint8_t *&gt;(&amp;msg.player_id) + sizeof(msg.player_id));\n        buffer.push_back(msg.action_type);\n        buffer.insert(buffer.end(), msg.data.begin(), msg.data.end());\n        return buffer;\n    }\n\n    std::vector&lt;uint8_t&gt; serialize(const GameStateUpdate &amp;msg)\n    {\n        std::vector&lt;uint8_t&gt; buffer;\n        buffer.push_back(static_cast&lt;uint8_t&gt;(MessageType::GAME_STATE_UPDATE));\n        buffer.insert(buffer.end(), msg.state_data.begin(), msg.state_data.end());\n        return buffer;\n    }\n\n    std::vector&lt;uint8_t&gt; serialize(const EventNotification &amp;msg)\n    {\n        std::vector&lt;uint8_t&gt; buffer;\n        buffer.push_back(static_cast&lt;uint8_t&gt;(MessageType::EVENT_NOTIFICATION));\n        buffer.push_back(msg.event_type);\n        buffer.insert(buffer.end(), msg.event_data.begin(), msg.event_data.end());\n        return buffer;\n    }\n\n    bool deserialize(const std::vector&lt;uint8_t&gt; &amp;buffer, PlayerAction &amp;msg)\n    {\n        if (buffer.empty() || buffer[0] != static_cast&lt;uint8_t&gt;(MessageType::PLAYER_ACTION))\n            return false;\n\n        size_t offset = 1;\n        msg.player_id = *reinterpret_cast&lt;const uint32_t *&gt;(&amp;buffer[offset]);\n        offset += sizeof(msg.player_id);\n        msg.action_type = buffer[offset++];\n        msg.data.assign(buffer.begin() + offset, buffer.end());\n        return true;\n    }\n\n    bool deserialize(const std::vector&lt;uint8_t&gt; &amp;buffer, GameStateUpdate &amp;msg)\n    {\n        if (buffer.empty() || buffer[0] != static_cast&lt;uint8_t&gt;(MessageType::GAME_STATE_UPDATE))\n            return false;\n\n        msg.state_data.assign(buffer.begin() + 1, buffer.end());\n        return true;\n    }\n\n    bool deserialize(const std::vector&lt;uint8_t&gt; &amp;buffer, EventNotification &amp;msg)\n    {\n        if (buffer.empty() || buffer[0] != static_cast&lt;uint8_t&gt;(MessageType::EVENT_NOTIFICATION))\n            return false;\n\n        size_t offset = 1;\n        msg.event_type = buffer[offset++];\n        msg.event_data.assign(buffer.begin() + offset, buffer.end());\n        return true;\n    }\n} // namespace protocol\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/protocol_8hpp/","title":"File protocol.hpp","text":"<p>FileList &gt; include &gt; Server &gt; protocol.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/protocol_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace protocol"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/protocol_8hpp/#classes","title":"Classes","text":"Type Name struct EventNotification Structure representing a notification about a game event. struct GameStateUpdate Structure representing an update to the game state. struct PlayerAction Structure representing a player's action. <p>The documentation for this class was generated from the following file <code>include/Server/protocol.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/protocol_8hpp_source/","title":"File protocol.hpp","text":"<p>File List &gt; include &gt; Server &gt; protocol.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** protocol\n** File description:\n** protocol\n*/\n\n#ifndef PROTOCOL_HPP_\n#define PROTOCOL_HPP_\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nnamespace protocol\n{\n\n    enum class MessageType : uint8_t\n    {\n        PLAYER_ACTION = 1,     \n        GAME_STATE_UPDATE = 2, \n        EVENT_NOTIFICATION = 3 \n    };\n\n    struct PlayerAction\n    {\n        uint32_t player_id;        \n        uint8_t action_type;       \n        std::vector&lt;uint8_t&gt; data; \n    };\n\n    struct GameStateUpdate\n    {\n        std::vector&lt;uint8_t&gt; state_data; \n    };\n\n    struct EventNotification\n    {\n        uint8_t event_type;              \n        std::vector&lt;uint8_t&gt; event_data; \n    };\n\n    std::vector&lt;uint8_t&gt; serialize(const PlayerAction &amp;msg);\n\n    std::vector&lt;uint8_t&gt; serialize(const GameStateUpdate &amp;msg);\n\n    std::vector&lt;uint8_t&gt; serialize(const EventNotification &amp;msg);\n\n    bool deserialize(const std::vector&lt;uint8_t&gt; &amp;buffer, PlayerAction &amp;msg);\n\n    bool deserialize(const std::vector&lt;uint8_t&gt; &amp;buffer, GameStateUpdate &amp;msg);\n\n    bool deserialize(const std::vector&lt;uint8_t&gt; &amp;buffer, EventNotification &amp;msg);\n\n} // namespace protocol\n\n#endif /* !PROTOCOL_HPP_ */\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/robustness_8cpp/","title":"File robustness.cpp","text":"<p>FileList &gt; Server &gt; robustness.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../include/Server/Server.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Server/robustness.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/robustness_8cpp_source/","title":"File robustness.cpp","text":"<p>File List &gt; Server &gt; robustness.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** B-CPP-500-COT-5-1-bsrtype-ilham.adios\n** File description:\n** robustness\n*/\n\n#include \"../../include/Server/Server.hpp\"\n\nvoid Server::start_heartbeat_monitor(boost::asio::io_context &amp;io_context)\n{\n    std::thread(\n        [this, &amp;io_context]()\n        {\n            while (true)\n            {\n                auto now = std::chrono::steady_clock::now();\n                for (auto it = clients_me.begin(); it != clients_me.end();)\n                {\n                    auto time_since_last_ping = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(\n                        now - it-&gt;second.last_ping);\n                    if (time_since_last_ping.count() &gt; 10)\n                    {\n                        notify_clients_of_disconnection(io_context, it-&gt;first);\n                        it = clients_me.erase(it);\n                    }\n                    else\n                    {\n                        ++it;\n                    }\n                }\n                std::this_thread::sleep_for(std::chrono::seconds(1));\n            }\n        })\n        .detach();\n}\n\nvoid Server::handle_client_ping(const udp::endpoint &amp;client_endpoint)\n{\n    auto now = std::chrono::steady_clock::now();\n    if (clients_me.find(client_endpoint) != clients_me.end())\n    {\n        clients_me[client_endpoint].last_ping = now;\n    }\n    else\n    {\n        clients_me[client_endpoint] = {now};\n    }\n    std::cout &lt;&lt; \"Updated ping for client: \" &lt;&lt; client_endpoint.address().to_string() &lt;&lt; std::endl;\n}\n\nvoid Server::send_udp_with_ack(udp::socket &amp;socket, const std::vector&lt;uint8_t&gt; &amp;message,\n                               const udp::endpoint &amp;client_endpoint)\n{\n    int retry_count = 0;\n    bool ack_received = false;\n\n    while (retry_count &lt; 3 &amp;&amp; !ack_received)\n    {\n        socket.send_to(boost::asio::buffer(message), client_endpoint);\n        std::cout &lt;&lt; \"Sent UDP message to client: \" &lt;&lt; client_endpoint.address().to_string()\n                  &lt;&lt; std::endl;\n\n        std::array&lt;uint8_t, 128&gt; recv_buffer;\n        udp::endpoint remote_endpoint;\n        boost::system::error_code error;\n        socket.receive_from(boost::asio::buffer(recv_buffer), remote_endpoint, 0, error);\n\n        if (!error &amp;&amp; recv_buffer[0] == 'A' &amp;&amp; recv_buffer[1] == 'C' &amp;&amp; recv_buffer[2] == 'K')\n        {\n            ack_received = true;\n            std::cout &lt;&lt; \"Received ACK from client: \" &lt;&lt; client_endpoint.address().to_string()\n                      &lt;&lt; std::endl;\n        }\n        else\n        {\n            retry_count++;\n            std::cout &lt;&lt; \"Retrying... Attempt: \" &lt;&lt; retry_count &lt;&lt; std::endl;\n        }\n    }\n    if (!ack_received)\n    {\n        std::cerr &lt;&lt; \"Failed to receive ACK after 3 attempts.\" &lt;&lt; std::endl;\n    }\n}\n\nvoid Server::notify_clients_of_disconnection(boost::asio::io_context &amp;io_context,\n                                             const udp::endpoint &amp;disconnected_client)\n{\n    for (const auto &amp;client : clients_me)\n    {\n        if (client.first != disconnected_client)\n        {\n            try\n            {\n                udp::socket socket(io_context, client.first.address().is_v6()\n                                                   ? boost::asio::ip::udp::v6()\n                                                   : boost::asio::ip::udp::v4());\n                int socketfd = static_cast&lt;int&gt;(socket.native_handle());\n                std::string message = \"Client \" + std::to_string(socketfd) + \" has disconnected.\";\n                std::cout &lt;&lt; message &lt;&lt; std::endl;\n                std::vector&lt;uint8_t&gt; message_data(message.begin(), message.end());\n                socket.send_to(boost::asio::buffer(message_data), client.first);\n                std::cout &lt;&lt; \"Notified clients: \" &lt;&lt; \"About the disconnection of client \"\n                          &lt;&lt; socketfd &lt;&lt; std::endl;\n            }\n            catch (const std::exception &amp;e)\n            {\n                std::cerr &lt;&lt; \"Error notifying client: \" &lt;&lt; client.first.address().to_string()\n                          &lt;&lt; \" - \" &lt;&lt; e.what() &lt;&lt; std::endl;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/room__system_8cpp/","title":"File room_system.cpp","text":"<p>FileList &gt; Server &gt; room_system.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../include/Server/room_system.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Server/room_system.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/room__system_8cpp_source/","title":"File room_system.cpp","text":"<p>File List &gt; Server &gt; room_system.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** B-CPP-500-COT-5-1-rtype-kafui.hounkpatin\n** File description:\n** room_system\n*/\n\n#include \"../../include/Server/room_system.hpp\"\n\nRoom_System::Room_System() : next_room_id(1)\n{\n}\n\nRoom_System::~Room_System()\n{\n}\n\nint Room_System::create_room(const std::string &amp;room_name, int max_players)\n{\n    int room_id = next_room_id++;\n    rooms[room_id] = {room_name, max_players, {}, false};\n    std::cout &lt;&lt; \"Room created: \" &lt;&lt; room_name &lt;&lt; \" with ID \" &lt;&lt; room_id &lt;&lt; std::endl;\n    return room_id;\n}\n\nbool Room_System::join_room(int room_id, const std::string &amp;player_name)\n{\n    if (rooms.find(room_id) != rooms.end() &amp;&amp; !rooms[room_id].in_game)\n    {\n        Room &amp;room = rooms[room_id];\n        if (room.players.size() &lt; room.max_players)\n        {\n            room.players.push_back(player_name);\n            std::cout &lt;&lt; player_name &lt;&lt; \" joined room \" &lt;&lt; room.name &lt;&lt; std::endl;\n\n            if (room.players.size() == room.max_players)\n            {\n                start_game_in_room(room_id);\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid Room_System::leave_room(int room_id, const std::string &amp;player_name)\n{\n    if (rooms.find(room_id) != rooms.end())\n    {\n        Room &amp;room = rooms[room_id];\n        auto it = std::find(room.players.begin(), room.players.end(), player_name);\n        if (it != room.players.end())\n        {\n            room.players.erase(it);\n            std::cout &lt;&lt; player_name &lt;&lt; \" left room \" &lt;&lt; room.name &lt;&lt; std::endl;\n\n            if (room.players.empty())\n            {\n                remove_room(room_id);\n            }\n        }\n    }\n}\n\nstd::vector&lt;std::string&gt; Room_System::list_available_rooms() const\n{\n    std::vector&lt;std::string&gt; available_rooms;\n    for (const auto &amp;pair : rooms)\n    {\n        const Room &amp;room = pair.second;\n        if (!room.in_game)\n        {\n            available_rooms.push_back(room.name + \" (ID: \" + std::to_string(pair.first) + \")\");\n        }\n    }\n    return available_rooms;\n}\n\nvoid Room_System::start_game_in_room(int room_id)\n{\n    if (rooms.find(room_id) != rooms.end())\n    {\n        rooms[room_id].in_game = true;\n        std::cout &lt;&lt; \"Game started in room: \" &lt;&lt; rooms[room_id].name &lt;&lt; std::endl;\n    }\n}\n\nvoid Room_System::remove_room(int room_id)\n{\n    if (rooms.find(room_id) != rooms.end())\n    {\n        std::cout &lt;&lt; \"Removing room: \" &lt;&lt; rooms[room_id].name &lt;&lt; std::endl;\n        rooms.erase(room_id);\n    }\n}\n\n// int main() {\n//     Room_System room_system;\n\n//     int room1 = room_system.create_room(\"Alpha Room\", 4);\n//     int room2 = room_system.create_room(\"Beta Room\", 3);\n\n//     auto rooms = room_system.list_available_rooms();\n//     for (const auto&amp; room : rooms) {\n//         std::cout &lt;&lt; \"Available room: \" &lt;&lt; room &lt;&lt; std::endl;\n//     }\n\n//     room_system.join_room(room1, \"Player1\");\n//     room_system.join_room(room1, \"Player2\");\n//     room_system.join_room(room2, \"Player3\");\n\n//     room_system.leave_room(room1, \"Player1\");\n\n//     rooms = room_system.list_available_rooms();\n//     for (const auto&amp; room : rooms) {\n//         std::cout &lt;&lt; \"Available room: \" &lt;&lt; room &lt;&lt; std::endl;\n//     }\n\n//     return 0;\n// }\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/room__system_8hpp/","title":"File room_system.hpp","text":"<p>FileList &gt; include &gt; Server &gt; room_system.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/room__system_8hpp/#classes","title":"Classes","text":"Type Name class Room_System Class responsible for managing game rooms. <p>The documentation for this class was generated from the following file <code>include/Server/room_system.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/room__system_8hpp_source/","title":"File room_system.hpp","text":"<p>File List &gt; include &gt; Server &gt; room_system.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** B-CPP-500-COT-5-1-rtype-kafui.hounkpatin\n** File description:\n** room_system\n*/\n\n#ifndef ROOM_SYSTEM_HPP_\n#define ROOM_SYSTEM_HPP_\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nclass Room_System\n{\npublic:\n    Room_System();\n\n    ~Room_System();\n\n    int create_room(const std::string &amp;room_name, int max_players);\n\n    bool join_room(int room_id, const std::string &amp;player_name);\n\n    void leave_room(int room_id, const std::string &amp;player_name);\n\n    std::vector&lt;std::string&gt; list_available_rooms() const;\n\n    void start_game_in_room(int room_id);\n\n    void remove_room(int room_id);\n\nprotected:\nprivate:\n    struct Room\n    {\n        std::string name;                 \n        int max_players;                  \n        std::vector&lt;std::string&gt; players; \n        bool in_game; \n    };\n\n    std::unordered_map&lt;int, Room&gt; rooms; \n    int next_room_id;                    \n};\n\n#endif /* !ROOM_SYSTEM_HPP_ */\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/server__room_8cpp/","title":"File server_room.cpp","text":"<p>FileList &gt; Server &gt; server_room.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../../include/Server/Server.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>src/Server/server_room.cpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/server__room_8cpp_source/","title":"File server_room.cpp","text":"<p>File List &gt; Server &gt; server_room.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n** EPITECH PROJECT, 2024\n** B-CPP-500-COT-5-1-rtype-kafui.hounkpatin\n** File description:\n** server_room\n*/\n\n#include \"../../include/Server/Server.hpp\"\n\nvoid Server::process_message_contain(udp::socket &amp;socket, const std::vector&lt;uint8_t&gt; &amp;buffer,\n                                     const udp::endpoint &amp;client_endpoint)\n{\n    std::string command(buffer.begin(), buffer.end());\n    std::cout &lt;&lt; command &lt;&lt; std::endl;\n    if (command.starts_with(\"CREATE_ROOM\"))\n    {\n        std::cout &lt;&lt; \"received 1\" &lt;&lt; std::endl;\n        std::string room_name = command.substr(12);\n        handle_room_creation(socket, room_name, client_endpoint);\n    }\n    else if (command.starts_with(\"JOIN_ROOM\"))\n    {\n        std::cout &lt;&lt; \"received 2\" &lt;&lt; std::endl;\n        int room_id = std::stoi(command.substr(10));\n        handle_room_joining(socket, room_id, client_endpoint);\n    }\n    else if (command == \"LIST_ROOMS\")\n    {\n        std::cout &lt;&lt; \"received 3\" &lt;&lt; std::endl;\n        handle_list_rooms(socket, client_endpoint);\n    }\n}\n\nvoid Server::handle_room_creation(udp::socket &amp;socket, const std::string &amp;room_name,\n                                  const udp::endpoint &amp;client_endpoint)\n{\n    int room_id = room_system.create_room(room_name, 4);\n    clients[client_endpoint] = room_name;\n\n    std::string response = \"Room created: \" + room_name + \" (ID: \" + std::to_string(room_id) + \")\";\n    std::cout &lt;&lt; response &lt;&lt; std::endl;\n    socket.send_to(boost::asio::buffer(response), client_endpoint);\n}\n\nvoid Server::handle_room_joining(udp::socket &amp;socket, int room_id,\n                                 const udp::endpoint &amp;client_endpoint)\n{\n    std::string player_name = client_endpoint.address().to_string();\n\n    bool joined = room_system.join_room(room_id, player_name);\n    std::string response =\n        joined ? \"Joined room \" + std::to_string(room_id) : \"Failed to join room\";\n    std::cout &lt;&lt; response &lt;&lt; std::endl;\n    socket.send_to(boost::asio::buffer(response), client_endpoint);\n}\n\nvoid Server::handle_list_rooms(udp::socket &amp;socket, const udp::endpoint &amp;client_endpoint)\n{\n    std::vector&lt;std::string&gt; rooms = room_system.list_available_rooms();\n    std::string response = \"Available rooms:\\n\";\n\n    for (const std::string &amp;room : rooms)\n    {\n        response += room + \"\\n\";\n    }\n    std::cout &lt;&lt; response &lt;&lt; std::endl;\n    socket.send_to(boost::asio::buffer(response), client_endpoint);\n}\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structAnimationData/","title":"Struct AnimationData","text":"<p>ClassList &gt; AnimationData</p> <ul> <li><code>#include &lt;Animation.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structAnimationData/#public-attributes","title":"Public Attributes","text":"Type Name sf::Clock clock int currentFrame sf::Sprite sprite int totalFrames"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structAnimationData/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structAnimationData/#variable-clock","title":"variable clock","text":"<pre><code>sf::Clock AnimationData::clock;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structAnimationData/#variable-currentframe","title":"variable currentFrame","text":"<pre><code>int AnimationData::currentFrame;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structAnimationData/#variable-sprite","title":"variable sprite","text":"<pre><code>sf::Sprite AnimationData::sprite;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structAnimationData/#variable-totalframes","title":"variable totalFrames","text":"<pre><code>int AnimationData::totalFrames;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Engine/Animation/Animation.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structEndpointEqual/","title":"Struct EndpointEqual","text":"<p>ClassList &gt; EndpointEqual</p> <p>Comparator for UDP endpoints. More...</p> <ul> <li><code>#include &lt;Server.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structEndpointEqual/#public-functions","title":"Public Functions","text":"Type Name bool operator() (const boost::asio::ip::udp::endpoint &amp; lhs, const boost::asio::ip::udp::endpoint &amp; rhs) constCompares two UDP endpoints."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structEndpointEqual/#detailed-description","title":"Detailed Description","text":"<p>This structure provides a custom comparison function to compare two UDP endpoints. It is used to check if two endpoints (IP address and port) are equal. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structEndpointEqual/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structEndpointEqual/#function-operator","title":"function operator()","text":"<p>Compares two UDP endpoints. <pre><code>inline bool EndpointEqual::operator() (\n    const boost::asio::ip::udp::endpoint &amp; lhs,\n    const boost::asio::ip::udp::endpoint &amp; rhs\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lhs</code> The first UDP endpoint. </li> <li><code>rhs</code> The second UDP endpoint. </li> </ul> <p>Returns:</p> <p>true If both endpoints have the same IP address and port. </p> <p>Returns:</p> <p>false If the IP address or port of the endpoints differs. </p> <p>The documentation for this class was generated from the following file <code>include/Server/Server.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structEndpointHash/","title":"Struct EndpointHash","text":"<p>ClassList &gt; EndpointHash</p> <p>Hash function for UDP endpoints. More...</p> <ul> <li><code>#include &lt;Server.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structEndpointHash/#public-functions","title":"Public Functions","text":"Type Name std::size_t operator() (const boost::asio::ip::udp::endpoint &amp; endpoint) constGenerates a hash for a UDP endpoint."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structEndpointHash/#detailed-description","title":"Detailed Description","text":"<p>This structure provides a custom hash function used for hashing UDP endpoints (which include IP address and port). It is primarily used in unordered containers like <code>std::unordered_map</code> to efficiently store and retrieve client connections. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structEndpointHash/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structEndpointHash/#function-operator","title":"function operator()","text":"<p>Generates a hash for a UDP endpoint. <pre><code>inline std::size_t EndpointHash::operator() (\n    const boost::asio::ip::udp::endpoint &amp; endpoint\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>endpoint</code> The UDP endpoint (IP address and port). </li> </ul> <p>Returns:</p> <p>A hashed value representing the endpoint.</p> <p>This function concatenates the IP address and port of the UDP endpoint into a single string and then hashes that string to produce a unique identifier. </p> <p>The documentation for this class was generated from the following file <code>include/Server/Server.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structInputManager_1_1Button/","title":"Struct InputManager::Button","text":"<p>ClassList &gt; Button</p> <p>Tracks the state of specific control buttons. More...</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structInputManager_1_1Button/#public-attributes","title":"Public Attributes","text":"Type Name bool attack Indicates whether the \"attack\" key is pressed. bool down Indicates whether the \"down\" key is pressed. bool escape Indicates whether the \"escape\" key is pressed. bool left Indicates whether the \"left\" key is pressed. bool right Indicates whether the \"right\" key is pressed. bool up Indicates whether the \"up\" key is pressed."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structInputManager_1_1Button/#detailed-description","title":"Detailed Description","text":"<p>This structure holds boolean flags for various buttons like movement keys (left, right, up, down), attack, and escape. Each flag is set to true when the corresponding key is pressed and false when released. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structInputManager_1_1Button/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structInputManager_1_1Button/#variable-attack","title":"variable attack","text":"<pre><code>bool InputManager::Button::attack;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structInputManager_1_1Button/#variable-down","title":"variable down","text":"<pre><code>bool InputManager::Button::down;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structInputManager_1_1Button/#variable-escape","title":"variable escape","text":"<pre><code>bool InputManager::Button::escape;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structInputManager_1_1Button/#variable-left","title":"variable left","text":"<pre><code>bool InputManager::Button::left;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structInputManager_1_1Button/#variable-right","title":"variable right","text":"<pre><code>bool InputManager::Button::right;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structInputManager_1_1Button/#variable-up","title":"variable up","text":"<pre><code>bool InputManager::Button::up;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Engine/Input/InputManager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structRoom__System_1_1Room/","title":"Struct Room_System::Room","text":"<p>ClassList &gt; Room</p> <p>Struct representing a game room. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structRoom__System_1_1Room/#public-attributes","title":"Public Attributes","text":"Type Name bool in_game int max_players Maximum number of players allowed in the room. std::string name The name of the room. std::vector&lt; std::string &gt; players List of players currently in the room."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structRoom__System_1_1Room/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structRoom__System_1_1Room/#variable-in_game","title":"variable in_game","text":"<pre><code>bool Room_System::Room::in_game;\n</code></pre> <p>Indicates if the game is currently being played in the room. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structRoom__System_1_1Room/#variable-max_players","title":"variable max_players","text":"<pre><code>int Room_System::Room::max_players;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structRoom__System_1_1Room/#variable-name","title":"variable name","text":"<pre><code>std::string Room_System::Room::name;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structRoom__System_1_1Room/#variable-players","title":"variable players","text":"<pre><code>std::vector&lt;std::string&gt; Room_System::Room::players;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Server/room_system.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structServer_1_1ClientInfo/","title":"Struct Server::ClientInfo","text":"<p>ClassList &gt; ClientInfo</p> <p>Structure containing information about connected clients. More...</p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structServer_1_1ClientInfo/#public-attributes","title":"Public Attributes","text":"Type Name std::chrono::steady_clock::time_point last_ping Timestamp of the client's last ping."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structServer_1_1ClientInfo/#detailed-description","title":"Detailed Description","text":"<p>This structure tracks the last ping time of connected clients for managing connection status and timeouts. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structServer_1_1ClientInfo/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structServer_1_1ClientInfo/#variable-last_ping","title":"variable last_ping","text":"<pre><code>std::chrono::steady_clock::time_point Server::ClientInfo::last_ping;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Server/Server.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structTemporaryText/","title":"Struct TemporaryText","text":"<p>ClassList &gt; TemporaryText</p> <ul> <li><code>#include &lt;InputManager.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structTemporaryText/#public-attributes","title":"Public Attributes","text":"Type Name sf::Clock clock float duration sf::Text text"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structTemporaryText/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structTemporaryText/#variable-clock","title":"variable clock","text":"<pre><code>sf::Clock TemporaryText::clock;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structTemporaryText/#variable-duration","title":"variable duration","text":"<pre><code>float TemporaryText::duration;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structTemporaryText/#variable-text","title":"variable text","text":"<pre><code>sf::Text TemporaryText::text;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Engine/Input/InputManager.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structparameter__t/","title":"Struct parameter_t","text":"<p>ClassList &gt; parameter_t</p> <p>Structure representing a command-line parameter. More...</p> <ul> <li><code>#include &lt;Server.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structparameter__t/#public-attributes","title":"Public Attributes","text":"Type Name std::function&lt; bool(int *, char **)&gt; add_new_param std::string argument int check_me Flag or variable for validation or tracking purposes. std::string name The name of the parameter (e.g., \"port\"). std::string usage"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structparameter__t/#detailed-description","title":"Detailed Description","text":"<p>This structure holds the necessary information for parsing and processing command-line arguments when starting the server. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structparameter__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structparameter__t/#variable-add_new_param","title":"variable add_new_param","text":"<pre><code>std::function&lt;bool(int *, char **)&gt; parameter_t::add_new_param;\n</code></pre> <p>Function pointer to process the argument and store it. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structparameter__t/#variable-argument","title":"variable argument","text":"<pre><code>std::string parameter_t::argument;\n</code></pre> <p>The argument passed via the command-line (e.g., \"-p\" for port). </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structparameter__t/#variable-check_me","title":"variable check_me","text":"<pre><code>int parameter_t::check_me;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structparameter__t/#variable-name","title":"variable name","text":"<pre><code>std::string parameter_t::name;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structparameter__t/#variable-usage","title":"variable usage","text":"<pre><code>std::string parameter_t::usage;\n</code></pre> <p>Usage instructions for this parameter (e.g., \"--port &lt;value&gt;\"). </p> <p>The documentation for this class was generated from the following file <code>include/Server/Server.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structprotocol_1_1EventNotification/","title":"Struct protocol::EventNotification","text":"<p>ClassList &gt; protocol &gt; EventNotification</p> <p>Structure representing a notification about a game event. </p> <ul> <li><code>#include &lt;protocol.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structprotocol_1_1EventNotification/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; uint8_t &gt; event_data Additional data related to the event. uint8_t event_type Type of the event being notified."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structprotocol_1_1EventNotification/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structprotocol_1_1EventNotification/#variable-event_data","title":"variable event_data","text":"<pre><code>std::vector&lt;uint8_t&gt; protocol::EventNotification::event_data;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structprotocol_1_1EventNotification/#variable-event_type","title":"variable event_type","text":"<pre><code>uint8_t protocol::EventNotification::event_type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Server/protocol.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structprotocol_1_1GameStateUpdate/","title":"Struct protocol::GameStateUpdate","text":"<p>ClassList &gt; protocol &gt; GameStateUpdate</p> <p>Structure representing an update to the game state. </p> <ul> <li><code>#include &lt;protocol.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structprotocol_1_1GameStateUpdate/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; uint8_t &gt; state_data Serialized data representing the current game state."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structprotocol_1_1GameStateUpdate/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structprotocol_1_1GameStateUpdate/#variable-state_data","title":"variable state_data","text":"<pre><code>std::vector&lt;uint8_t&gt; protocol::GameStateUpdate::state_data;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Server/protocol.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structprotocol_1_1PlayerAction/","title":"Struct protocol::PlayerAction","text":"<p>ClassList &gt; protocol &gt; PlayerAction</p> <p>Structure representing a player's action. </p> <ul> <li><code>#include &lt;protocol.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structprotocol_1_1PlayerAction/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t action_type Type of action performed by the player. std::vector&lt; uint8_t &gt; data Additional data related to the action. uint32_t player_id Unique ID of the player performing the action."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structprotocol_1_1PlayerAction/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structprotocol_1_1PlayerAction/#variable-action_type","title":"variable action_type","text":"<pre><code>uint8_t protocol::PlayerAction::action_type;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structprotocol_1_1PlayerAction/#variable-data","title":"variable data","text":"<pre><code>std::vector&lt;uint8_t&gt; protocol::PlayerAction::data;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structprotocol_1_1PlayerAction/#variable-player_id","title":"variable player_id","text":"<pre><code>uint32_t protocol::PlayerAction::player_id;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Server/protocol.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structserver__me__t/","title":"Struct server_me_t","text":"<p>ClassList &gt; server_me_t</p> <p>Struct representing the server configuration. More...</p> <ul> <li><code>#include &lt;Server.hpp&gt;</code></li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structserver__me__t/#public-attributes","title":"Public Attributes","text":"Type Name int tcp_port The TCP port number on which the server listens. int udp_port The UDP port number on which the server listens."},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structserver__me__t/#detailed-description","title":"Detailed Description","text":"<p>This structure holds the port numbers for both TCP and UDP communication. </p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structserver__me__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structserver__me__t/#variable-tcp_port","title":"variable tcp_port","text":"<pre><code>int server_me_t::tcp_port;\n</code></pre>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/structserver__me__t/#variable-udp_port","title":"variable udp_port","text":"<pre><code>int server_me_t::udp_port;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/Server/Server.hpp</code></p>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/variables/","title":"Variables","text":""},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/variables/#c","title":"c","text":"<ul> <li>CHECK_SERVER (check_params.cpp)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/variables/#s","title":"s","text":"<ul> <li>server_t (Server.hpp)</li> </ul>"},{"location":"B-CPP-500-COT-5-1-rtype-kafui.hounkpatin/variables/#z","title":"z","text":"<ul> <li>ZAPPY_SERVER_PARAMS (check_params.cpp)</li> </ul>"},{"location":"appendix/change_log/","title":"Change Log","text":""},{"location":"appendix/glossary/","title":"Glossary","text":""},{"location":"appendix/license/","title":"License Information","text":"<p>Copyright (c) 2011-2024 GitHub Inc.</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"architecture/comparative_study/","title":"Comparative study","text":""},{"location":"architecture/comparative_study/#comparative-study-of-multiplayer-game-architecture-udp-with-entity-component-system-ecs-vs-other-approaches","title":"Comparative Study of Multiplayer Game Architecture: UDP with Entity-Component-System (ECS) vs. Other Approaches","text":"<p>In this section, we will compare the UDP with ECS-based game architecture implemented in this project with other common multiplayer game architectures. The comparison will focus on several key factors, including performance, scalability, development complexity, reliability, and the trade-offs between different approaches.</p>"},{"location":"architecture/comparative_study/#1-comparison-criteria","title":"1. Comparison Criteria","text":"<p>To evaluate the different architectures, we will use the following key criteria:</p> <ul> <li> <p>Performance (Latency and Throughput): Measures how quickly and efficiently the game system responds to player inputs and game state updates, crucial for real-time multiplayer games.</p> </li> <li> <p>Scalability: Evaluates how well the architecture handles increasing numbers of players or entities without degrading performance.</p> </li> <li> <p>Development Complexity: Assesses how difficult it is to develop and maintain the architecture, including coding complexity and ease of debugging.</p> </li> <li> <p>Reliability: Looks at how robust the architecture is, particularly with respect to packet loss, disconnection, and synchronization in real-time games.</p> </li> <li> <p>Memory and CPU Efficiency: Examines how well the architecture utilizes memory and processing resources, especially on servers with many players.</p> </li> </ul>"},{"location":"architecture/comparative_study/#2-architectures-considered","title":"2. Architectures Considered","text":"<ol> <li>UDP with Entity-Component-System (ECS): </li> <li> <p>This is the architecture implemented in our project. The ECS pattern organizes entities, components, and systems in a way that decouples game logic from data representation, and UDP facilitates fast communication.</p> </li> <li> <p>TCP with Object-Oriented Programming (OOP):</p> </li> <li> <p>In this approach, a traditional client-server model is used with TCP (Transmission Control Protocol) for reliable data transfer, while the game logic is organized using inheritance-based OOP. TCP ensures message order and reliability.</p> </li> <li> <p>Peer-to-Peer (P2P) Architecture:</p> </li> <li> <p>Rather than using a central server, all clients communicate directly with each other. This model often uses UDP or custom protocols, and peers share the responsibility for updating the game state.</p> </li> <li> <p>Lockstep Networking with Deterministic Simulation:</p> </li> <li>A common approach in real-time strategy (RTS) games, where the game simulation is deterministic, and all clients must send and receive inputs in a strict order to maintain synchronization.</li> </ol>"},{"location":"architecture/comparative_study/#3-detailed-comparison","title":"3. Detailed Comparison","text":"Criteria UDP + ECS TCP + OOP Peer-to-Peer (P2P) Lockstep Networking Performance High: UDP is fast with low latency; ECS optimizes cache and memory usage for real-time performance. Medium: TCP guarantees delivery but introduces higher latency due to packet reordering and acknowledgments. Medium-High: P2P can have good performance, but suffers from inconsistent latency between peers. Low: Lockstep is slow due to the need for strict synchronization and waiting for all clients. Scalability High: The server can efficiently manage many entities, and UDP\u2019s minimal overhead allows many clients to connect. Medium: TCP requires more resources to manage connections and maintain reliability, which can limit scalability. Low-Medium: Each peer increases the network complexity; hard to scale beyond small games. Medium: Can scale well for small numbers of players but struggles with high player counts due to synchronization constraints. Development Complexity Medium-High: ECS is a flexible pattern but requires thoughtful design. Handling UDP requires custom packet loss handling and message ordering. Low-Medium: OOP is widely understood, and TCP simplifies connection management with built-in reliability. However, it can introduce latency and bloat the code. High: Implementing peer-to-peer networking, especially for real-time games, is complex and error-prone. Very High: Requires deterministic simulation, precise synchronization, and custom protocols for consistency. Reliability Medium: UDP does not guarantee delivery, so packet loss must be managed manually, increasing complexity. High: TCP guarantees message delivery and order, so the game is more reliable but can introduce delays in case of packet loss. Low: P2P suffers from connectivity issues, NAT traversal problems, and inconsistent reliability between peers. High: Lockstep ensures all players are synchronized, but even minor desynchronization can crash the game. Memory and CPU Efficiency High: ECS design is cache-friendly, and UDP minimizes overhead, leading to efficient use of CPU and memory. Low-Medium: OOP can lead to bloated memory usage, especially with deep inheritance hierarchies; TCP\u2019s overhead also impacts efficiency. Low-Medium: P2P can become CPU and memory-intensive as each client must manage synchronization and state for all peers. Medium: Lockstep is deterministic but can cause CPU spikes due to synchronization checks, especially for large simulations."},{"location":"architecture/comparative_study/#4-in-depth-analysis-of-each-architecture","title":"4. In-Depth Analysis of Each Architecture","text":""},{"location":"architecture/comparative_study/#41-udp-with-ecs","title":"4.1 UDP with ECS","text":"<ul> <li>Pros:</li> <li>Low Latency: UDP\u2019s connectionless nature ensures messages are sent quickly, making it ideal for real-time games.</li> <li>High Performance: The ECS pattern is designed for performance, optimizing memory use and improving CPU cache hit rates.</li> <li>Scalability: UDP\u2019s minimal overhead and ECS\u2019s lightweight structure allow the architecture to scale effectively.</li> <li> <p>Flexible Logic: ECS decouples data and logic, making the system highly flexible and modular for adding new gameplay features.</p> </li> <li> <p>Cons:</p> </li> <li>Packet Loss Handling: UDP does not guarantee message delivery, so the developer must implement their own mechanisms for handling packet loss or dropped connections.</li> <li>Complexity: The ECS pattern can add a layer of abstraction that might be challenging to manage in large, complex systems. Synchronization across multiple clients also requires careful handling.</li> </ul>"},{"location":"architecture/comparative_study/#42-tcp-with-object-oriented-programming","title":"4.2 TCP with Object-Oriented Programming","text":"<ul> <li>Pros:</li> <li>Reliability: TCP guarantees that all messages arrive in order and without loss, simplifying the development of a multiplayer game.</li> <li> <p>Familiarity: OOP is a well-understood design pattern, which can speed up development and reduce the learning curve.</p> </li> <li> <p>Cons:</p> </li> <li>Higher Latency: TCP introduces higher latency due to its acknowledgment and retransmission mechanisms. This can negatively impact real-time performance in fast-paced games.</li> <li>Less Scalable: TCP\u2019s connection-oriented nature makes it less suitable for handling a large number of clients.</li> <li>Less Efficient: Deep inheritance trees in OOP can lead to bloated memory and CPU usage, and TCP's overhead adds additional load.</li> </ul>"},{"location":"architecture/comparative_study/#43-peer-to-peer-p2p-networking","title":"4.3 Peer-to-Peer (P2P) Networking","text":"<ul> <li>Pros:</li> <li>Cost Efficiency: No central server means there are no hosting or maintenance costs, which can be ideal for small-scale multiplayer games.</li> <li> <p>Low Latency Between Close Peers: If peers are geographically close, P2P can provide fast communication.</p> </li> <li> <p>Cons:</p> </li> <li>Synchronization Issues: Maintaining a consistent game state between all peers is difficult, especially with fluctuating network conditions.</li> <li>Scalability: As more players join, the P2P network becomes more difficult to manage and synchronize. It\u2019s also prone to NAT traversal issues.</li> <li>Security: Without a central server, P2P networks can be more vulnerable to cheating or attacks from malicious players.</li> </ul>"},{"location":"architecture/comparative_study/#44-lockstep-networking-with-deterministic-simulation","title":"4.4 Lockstep Networking with Deterministic Simulation","text":"<ul> <li>Pros:</li> <li>Exact Synchronization: Every client is perfectly synchronized, as all inputs are sent and received at the same time. This method is often used in RTS games like \"Starcraft.\"</li> <li> <p>Predictable Behavior: The simulation behaves the same on every client, making it easier to detect and avoid desynchronization.</p> </li> <li> <p>Cons:</p> </li> <li>High Latency: Lockstep requires each client to wait for all other clients' inputs before proceeding, which introduces latency, especially in games with many players.</li> <li>Limited Real-Time Interaction: This model struggles with fast-paced games that require immediate input feedback, like first-person shooters (FPS) or fighting games.</li> <li>Development Complexity: Implementing deterministic simulations is very complex, as it requires ensuring that the game behaves exactly the same on every client for every frame.</li> </ul>"},{"location":"architecture/comparative_study/#5-conclusion","title":"5. Conclusion","text":""},{"location":"architecture/comparative_study/#best-use-cases","title":"Best Use Cases","text":"<ul> <li> <p>UDP with ECS: Best suited for real-time multiplayer games, such as action games, first-person shooters, or fast-paced arcade games, where low-latency and high performance are essential. The flexibility of the ECS architecture also allows for easier implementation of complex game mechanics and entities.</p> </li> <li> <p>TCP with OOP: Better suited for turn-based games or games that do not require real-time synchronization. TCP\u2019s reliability and OOP\u2019s simplicity can reduce development complexity but come at the cost of increased latency.</p> </li> <li> <p>Peer-to-Peer: Ideal for small, casual multiplayer games where cost savings and simplicity are more important than performance or scalability. Suitable for games with 2-8 players that don\u2019t require a dedicated server.</p> </li> <li> <p>Lockstep Networking: Typically used for RTS games or games with deterministic logic. Ideal for games that require precise synchronization but can tolerate higher latency between player actions.</p> </li> </ul>"},{"location":"architecture/comparative_study/#final-recommendation","title":"Final Recommendation:","text":"<p>For real-time multiplayer games, the UDP with ECS architecture offers the best trade-offs between performance, scalability, and development flexibility. While UDP requires extra care in handling packet loss, its low</p> <p>latency and high performance make it ideal for the fast-paced, real-time nature of many modern multiplayer games.</p>"},{"location":"architecture/ecs/","title":"ECS Design Pattern","text":"<p>ECS Design Pattern for Multiplayer Game Server What is an ECS? An Entity-Component-System (ECS) is a design pattern tailored for efficient handling of game entities, particularly in multiplayer environments like the one in this project. The ECS pattern emphasizes the separation of concerns, where game objects (entities) are composed dynamically from smaller reusable components, and the logic to manage them is encapsulated in systems.</p> <p>In the context of our multiplayer game server, this separation becomes crucial for efficient management of different types of in-game entities such as players, enemies, missiles, and coins. Components are lightweight data containers that describe the attributes of these entities, such as position, health, or velocity. They do not contain behavior. The behavior is handled by systems like the MovementSystem, CollisionSystem, or ShootSystem, which process multiple entities based on the components they possess.</p> <p>Entities in this setup are simply unique identifiers (IDs) that the server uses to track and update the game state. These IDs are associated with various components, depending on the entity's role in the game (e.g., players have position and health components, enemies have AI components, etc.).</p> <p>Advantages of ECS in Our UDP-Based Game Separation of Data and Logic: The ECS model decouples entity data from the systems that manipulate them, making it easier to scale and manage the game server. The server can efficiently manage thousands of entities, updating only the relevant components for each frame.</p> <p>Optimized for Networked Environments: With UDP protocol, minimizing data sent between the server and clients is crucial. The ECS design enables efficient synchronization by updating only the necessary components, reducing redundant information. For instance, only position, velocity, and entity state changes are transmitted, cutting down on unnecessary network traffic.</p> <p>Dynamic Composition: The game allows for dynamic interactions such as creating rooms, joining sessions, and tracking the state of entities like players, enemies, and missiles. ECS provides the flexibility to dynamically add or remove components from entities as the game progresses, enabling features like entity spawning, destruction, or state changes (e.g., player death, missile firing). </p> <p>Ressources : COMP4300 - Game Programming by Dave Churchill --&gt; https://www.youtube.com/@DaveChurchill</p>"},{"location":"architecture/ecs/#cpu-cache-optimization-for-real-time-multiplayer","title":"CPU Cache Optimization for Real-Time Multiplayer","text":"<p>Given the real-time nature of the game and the need to handle multiple clients via UDP, optimizing memory access is key. The ECS pattern is highly cache-friendly. By organizing components of the same type in contiguous memory, we ensure that the CPU can access and update multiple components without frequent cache misses. This significantly improves the server's ability to process multiple entities (players, enemies, etc.) within the constraints of the frame rate, ensuring smooth gameplay.</p> <p>The server fetches components into cache lines in bulk, which is particularly important when handling entity positions, velocities, or network packets. This reduces the latency between receiving input from clients and broadcasting updated game states back to them.</p> <p>In this game server, systems like movement, collision detection, and shooting benefit from cache-efficient designs, improving the overall responsiveness and minimizing lag during gameplay.</p>"},{"location":"architecture/engine/","title":"R-Type Game Engine Documentation","text":""},{"location":"architecture/engine/#overview","title":"Overview","text":"<p>The R-Type Game Engine is a comprehensive C++ framework built on top of SFML (Simple and Fast Multimedia Library). It provides a set of modular components to facilitate game development, including animation handling, audio management, image rendering, input processing, mouse interaction, parallax scrolling, and shape drawing.</p>"},{"location":"architecture/engine/#engine-structure","title":"Engine Structure","text":"<p>The engine is organized into the following modules:</p>"},{"location":"architecture/engine/#modules","title":"Modules","text":""},{"location":"architecture/engine/#1-animation","title":"1. Animation","text":"<p>The Animation module handles sprite animations.</p> <p>Key Features: - Load and manage multiple animations - Update and render animations - Control animation scale and position - Move animations in different directions</p> <p>Usage Example: <pre><code>Animation anim;\nanim.loadAnimation(\"player_run\", 8);\nanim.update(\"player_run\");\nanim.render(window, \"player_run\");\n</code></pre></p>"},{"location":"architecture/engine/#2-audio","title":"2. Audio","text":"<p>The AudioManager handles sound effects and music playback.</p> <p>Key Features: - Play sound effects and music - Pause and resume music - Adjust volume for music and sound effects - Control sound pitch</p> <p>Usage Example: <pre><code>AudioManager audio;\naudio.playSound(\"explosion.wav\");\naudio.playMusic(\"background_music.ogg\");\naudio.setMusicVolume(75);\n</code></pre></p>"},{"location":"architecture/engine/#3-image","title":"3. Image","text":"<p>The ImageManager handles loading, manipulating, and rendering images.</p> <p>Key Features: - Load images from files - Set image position and scale - Draw images to the render window - Get image boundaries for collision detection</p> <p>Usage Example: <pre><code>ImageManager image;\nimage.createImage(\"sprite.png\");\nimage.setPosition(100, 100);\nimage.draw(window);\n</code></pre></p>"},{"location":"architecture/engine/#4-input","title":"4. Input","text":"<p>The InputManager processes keyboard input and window events.</p> <p>Key Features: - Handle key presses and releases - Track states of specific control buttons - Process window-related events</p> <p>Usage Example: <pre><code>InputManager input;\ninput.handleInput(event, window);\nif (input.getButton().left) {\n    // Move player left\n}\n</code></pre></p>"},{"location":"architecture/engine/#5-mouse","title":"5. Mouse","text":"<p>The MouseManager tracks mouse position and interactions.</p> <p>Key Features: - Update mouse position relative to the window - Retrieve current mouse coordinates</p> <p>Usage Example: <pre><code>MouseManager mouse;\nmouse.handleMousePosition(window);\nfloat mouseX = mouse.getMouseX();\nfloat mouseY = mouse.getMouseY();\n</code></pre></p>"},{"location":"architecture/engine/#6-parallax","title":"6. Parallax","text":"<p>The Parallax module creates scrolling background effects.</p> <p>Key Features: - Create parallax scrolling with two layers - Update parallax based on time - Draw parallax backgrounds</p> <p>Usage Example: <pre><code>Parallax bg(\"far_bg.png\", \"near_bg.png\", 50, 100);\nbg.update(deltaTime);\nbg.draw(window);\n</code></pre></p>"},{"location":"architecture/engine/#7-shape","title":"7. Shape","text":"<p>The ShapeManager provides utilities for drawing geometric shapes.</p> <p>Key Features: - Draw rectangles with customizable properties - Draw circles with customizable properties</p> <p>Usage Example: <pre><code>ShapeManager shapes;\nshapes.drawRectangle(window, 50, 50, 100, 100, sf::Color::Red, 2);\nshapes.drawCircle(window, 200, 200, 50, sf::Color::Blue, 1);\n</code></pre></p>"},{"location":"architecture/engine/#getting-started","title":"Getting Started","text":"<ol> <li>Include the necessary headers in your project.</li> <li>Initialize SFML and create a render window.</li> <li>Create instances of the required managers (AudioManager, InputManager, etc.).</li> <li>In your game loop:</li> <li>Handle events using InputManager</li> <li>Update game logic</li> <li>Update animations and parallax effects</li> <li>Clear the window</li> <li>Draw your game objects using the various managers</li> <li>Display the window</li> </ol>"},{"location":"architecture/engine/#best-practices","title":"Best Practices","text":"<ol> <li>Use const references for SFML objects passed to functions to avoid unnecessary copying.</li> <li>Implement error handling for resource loading (images, sounds, etc.).</li> <li>Use the singleton pattern for managers that should have only one instance (e.g., AudioManager).</li> <li>Optimize your draw calls by batching similar draw operations.</li> </ol>"},{"location":"architecture/engine/#code-example-and-result","title":"Code Example and Result","text":""},{"location":"architecture/engine/#code","title":"Code","text":"<p>Certainly! Here's a comprehensive example that demonstrates the usage of all the classes within an SFML window. This example creates a simple scene with a moving character, background music, a parallax background, and some interactive elements.</p> <pre><code>#include &lt;SFML/Graphics.hpp&gt;\n#include \"include/Engine/Animation/Animation.hpp\"\n#include \"include/Engine/Audio/AudioManager.hpp\"\n#include \"include/Engine/Image/ImageManager.hpp\"\n#include \"include/Engine/Input/InputManager.hpp\"\n#include \"include/Engine/Mouse/MouseManager.hpp\"\n#include \"include/Engine/Parallax/parallax.hpp\"\n#include \"include/Engine/Shape/ShapeManager.hpp\"\n\nint main()\n{\n    // Create the main window\n    sf::RenderWindow window(sf::VideoMode(800, 600), \"R-Type Game Engine Demo\");\n    window.setFramerateLimit(60);\n\n    // Initialize managers\n    Animation animation;\n    AudioManager audio;\n    ImageManager backgroundImage;\n    InputManager input;\n    MouseManager mouse;\n    Parallax parallax(\"assets/image/Background/background1.png\", \"assets/image/Background/background2.png\", 30, 60);\n    ShapeManager shapes;\n\n    // Load character animation\n    animation.loadAnimation(\"red\", 8);  // Assuming 8 frames for running animation\n    animation.setScale(2.0f, 2.0f);\n    animation.setPosition(\"red\", 400, 300);\n\n    // Load background image\n    backgroundImage.createImage(\"assets/background.png\");\n    backgroundImage.fitToScreen(800, 600);\n\n    // Load and play background music\n    audio.playMusic(\"assets/audio/Effect/boom.ogg\");\n    audio.setMusicVolume(50);\n\n    // Main game loop\n    while (window.isOpen())\n    {\n        sf::Event event;\n        while (window.pollEvent(event))\n        {\n            input.handleInput(event, window);\n            if (event.type == sf::Event::Closed)\n                window.close();\n        }\n\n        // Update mouse position\n        mouse.handleMousePosition(window);\n\n        // Handle character movement\n        if (input.getButton().left)\n            animation.moveXLeft(\"red\", 5.0f);\n        if (input.getButton().right)\n            animation.moveXRight(\"red\", 5.0f);\n        if (input.getButton().up)\n            animation.moveYUp(\"red\", 5.0f);\n        if (input.getButton().down)\n            animation.moveY(\"red\", 5.0f);\n\n        // Play a sound effect when attacking\n        if (input.getButton().attack)\n            audio.playSound(\"assets/attack_sound.wav\");\n\n        // Update parallax and animation\n        parallax.update(0.016f);  // Assuming 60 FPS, so delta time is approximately 1/60\n        animation.update(\"red\");\n\n        // Clear the window\n        window.clear();\n\n        // Draw the background\n        backgroundImage.draw(window);\n\n        // Draw parallax background\n        parallax.draw(window);\n\n        // Draw character animation\n        animation.render(window, \"red\");\n\n        // Draw a shape at the mouse position\n        shapes.drawCircle(window, mouse.getMouseX(), mouse.getMouseY(), 10, sf::Color::Red, 2);\n\n        // Draw a rectangle\n        shapes.drawRectangle(window, 50, 50, 100, 100, sf::Color::Green, 2);\n\n        // Display everything on screen\n        window.display();\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"architecture/engine/#demo","title":"Demo","text":"<p>This example demonstrates:</p> <ol> <li>Creating an SFML window</li> <li>Initializing all the manager classes</li> <li>Loading and displaying a character animation</li> <li>Playing background music</li> <li>Handling user input for character movement</li> <li>Updating and rendering a parallax background</li> <li>Using the mouse position to draw a shape</li> <li>Drawing additional shapes on the screen</li> </ol> <p>To run this example, you'll need to:</p> <ol> <li>Have all the necessary header files in their respective directories</li> <li>Have the SFML library properly linked to your project</li> <li>Provide the necessary asset files (images, music, sound effects) in an \"assets\" directory</li> </ol> <p>This code provides a starting point that you can expand upon to create more complex games using the R-Type Game Engine components. You can add game-specific logic, more complex animations, additional audio cues, and more sophisticated input handling as needed for your game.</p>"},{"location":"architecture/engine/#conclusion","title":"Conclusion","text":"<p>The R-Type Game Engine provides a solid foundation for building 2D games with SFML. By utilizing these modules, developers can focus on game-specific logic while leveraging the engine's capabilities for common game development tasks.</p>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>The R-Type multiplayer architecture is designed to allow players to connect and interact in real-time with a server using UDP-based communication. The server handles all game logic, player synchronization, and disconnections while ensuring smooth gameplay. </p> <p>This architecture emphasizes low-latency UDP communication for faster updates and reliable disconnection handling, using a heartbeat mechanism to detect and notify other players of dropped connections.</p>"},{"location":"architecture/overview/#system-architecture","title":"System Architecture","text":"<pre><code>+--------------------+               +----------------------+\n|      Client 1      |               |      Client 2        |\n| [Sends Player Input]               | [Sends Player Input] |\n+--------------------+               +----------------------+\n            \\                            /\n             \\                          /\n              \\                        /\n            +------------------------------+\n            |         R-Type Server        |\n            |  - Processes Player Inputs   |\n            |  - Syncs Game State          |\n            |  - Manages Rooms &amp; Players   |\n            |  - Handles Disconnections    |\n            +------------------------------+\n</code></pre>"},{"location":"architecture/overview/#key-components","title":"Key Components","text":"<ol> <li> <p>Server: </p> <ul> <li>Central authority managing the game state and synchronizing clients.</li> <li>Processes player input, updates game states, and manages rooms.</li> <li>Uses UDP communication to ensure low-latency updates.  </li> </ul> </li> <li> <p>Clients: </p> <ul> <li>Send player actions and input updates to the server.</li> <li>Render the game state based on server updates.</li> <li>Monitor and maintain connection with the server via heartbeat pings.</li> </ul> </li> </ol>"},{"location":"architecture/overview/#communication-flow","title":"Communication Flow","text":"<p>Since the architecture relies solely on UDP, all communication (including player input, game state updates, and room management) is done using UDP datagrams.</p>"},{"location":"architecture/overview/#udp-communication-flow","title":"UDP Communication Flow","text":"<pre><code>[Client 1] ---&gt; (Move Up) ---&gt; [Server]\n                          ---&gt; Updates Position\n                          ---&gt; Broadcasts New State to All Clients\n[Client 2] &lt;--- (Position Update) &lt;--- [Server]\n</code></pre> <ol> <li>Player Input: </li> <li>Clients send input actions (e.g., movement, shooting) to the server using UDP.  </li> <li> <p>Example: Protocol Command: <code>0x03</code> + <code>Direction</code> (0x01 = Up, 0x02 = Down, etc.).</p> </li> <li> <p>Game State Updates: </p> </li> <li>The server processes input and sends back the updated player positions and game state to all connected clients.</li> </ol>"},{"location":"architecture/overview/#player-lifecycle-overview","title":"Player Lifecycle Overview","text":""},{"location":"architecture/overview/#1-connecting-to-the-server","title":"1. Connecting to the Server","text":"<ul> <li>Each client initiates a connection by sending a UDP \"connect\" message.  </li> <li>The server responds with an acknowledgment and assigns the client to a room or the game world.</li> </ul>"},{"location":"architecture/overview/#2-heartbeat-monitoring-disconnection-handling","title":"2. Heartbeat Monitoring &amp; Disconnection Handling","text":"<p>To ensure the server remains operational even if a client disconnects unexpectedly, the server implements a heartbeat mechanism.</p> <pre><code>+------------+          +--------------+\n|  Client 1  |  -----&gt;  |   Server     |\n+------------+   Ping   +--------------+\n           If no ping received in 10s:\n            [Server]: \"Client 1 Disconnected\"\n</code></pre> <p>Code Snippet: Heartbeat Monitoring</p> <pre><code>void Server::start_heartbeat_monitor(boost::asio::io_context &amp;io_context) {\n    std::thread([this]() {\n        while (true) {\n            auto now = std::chrono::steady_clock::now();\n            for (auto it = clients_me.begin(); it != clients_me.end();) {\n                auto time_since_last_ping = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(\n                    now - it-&gt;second.last_ping);\n\n                if (time_since_last_ping.count() &gt; 10) {\n                    notify_clients_of_disconnection(io_context, it-&gt;first);\n                    it = clients_me.erase(it);\n                } else {\n                    ++it;\n                }\n            }\n            std::this_thread::sleep_for(std::chrono::seconds(1));\n        }\n    }).detach();\n}\n</code></pre> <ul> <li>Disconnection Detection:   If a client\u2019s ping is not received within 10 seconds, the server marks the client as disconnected and notifies other players.</li> </ul>"},{"location":"architecture/overview/#room-system-for-matchmaking","title":"Room System for Matchmaking","text":"<p>The Room System allows players to create, join, or leave rooms. Each room maintains its own player list, and the server tracks player movements and game state updates within each room.</p>"},{"location":"architecture/overview/#room-management-commands","title":"Room Management Commands","text":"<pre><code>[Client] ---&gt; CREATE_ROOM \"Room1\" ---&gt; [Server]\n[Client] ---&gt; JOIN_ROOM \"Room1\" ---&gt; [Server]\n[Client] ---&gt; LIST_ROOMS ---&gt; [Server]\n</code></pre> <ol> <li> <p>Create a Room: </p> <ul> <li>Players can create rooms to host matches.</li> <li>Example Command: <code>CREATE_ROOM &lt;room_name&gt;</code> </li> <li>The server creates the room and waits for other players to join.</li> </ul> </li> <li> <p>Join a Room: </p> <ul> <li>Players can join existing rooms by sending the room ID.</li> <li>Example Command: <code>JOIN_ROOM &lt;room_id&gt;</code> </li> </ul> </li> <li> <p>List Rooms: </p> <ul> <li>Players can query available rooms.</li> <li>Example Command: <code>LIST_ROOMS</code></li> </ul> </li> </ol>"},{"location":"architecture/overview/#example-gameplay-sequence","title":"Example Gameplay Sequence","text":"<ol> <li>Client 1 sends <code>0x01</code> to connect to the server and gets assigned to a room.</li> <li>Client 2 joins the same room by sending <code>JOIN_ROOM Room1</code>.</li> <li>Both clients start sending player inputs (<code>0x03 + Direction</code>).</li> <li>The server updates player positions and broadcasts them back to all clients.</li> <li>Client 1 disconnects unexpectedly; the server detects it and notifies Client 2.</li> </ol>"},{"location":"architecture/server_client/","title":"Server & Client","text":""},{"location":"architecture/server_client/#detailed-documentation-for-multiplayer-game-server-and-client","title":"Detailed Documentation for Multiplayer Game Server and Client","text":""},{"location":"architecture/server_client/#1-overview","title":"1. Overview","text":"<p>This project involves the development of a multiplayer game using the Entity-Component-System (ECS) pattern, facilitated by the UDP protocol for real-time communication between the server and clients. The server manages player states, enemy entities, game logic, and real-time synchronization with multiple clients. The client handles player input, rendering, and interaction with the game environment.</p> <p>This documentation will describe the server and client functionality, focusing on the UDP-based communication protocol, ECS architecture, and how the server and client interact to ensure a responsive, real-time multiplayer experience.</p>"},{"location":"architecture/server_client/#2-protocol-design-udp","title":"2. Protocol Design (UDP)","text":"<p>Communication between the server and client is conducted using UDP, which is well-suited for fast-paced games due to its low-latency characteristics. However, because UDP does not guarantee message delivery, custom handling for dropped packets and acknowledgment (ACK) has been implemented.</p>"},{"location":"architecture/server_client/#message-structure","title":"Message Structure:","text":"<p>Messages exchanged between the server and the client are byte-encoded and follow a structured format for different types of game actions and events. </p> Code Direction Description <code>0x01</code> Client \u2192 Server Player creation <code>0x02</code> Server \u2192 Client Client connection acknowledged <code>0x03</code> Client \u2192 Server Player input (up, down, left, right) <code>0x04</code> Server \u2192 Client Update all player positions <code>0x05</code> Server \u2192 Client Update enemy positions <code>0x07</code> Server \u2192 Client Send player health and score <code>0x08</code> Server \u2192 Client Notify about destroyed entities (dead players, enemies, missiles) <code>0x09</code> Server \u2192 Client Spawn new enemies <code>0x10</code> Server \u2192 Client Missile positions <code>0x11</code> Server \u2192 Client Coin positions <p>This structure ensures clear communication and synchronization between the server and clients.</p>"},{"location":"architecture/server_client/#3-server-architecture","title":"3. Server Architecture","text":""},{"location":"architecture/server_client/#31-server-overview","title":"3.1 Server Overview","text":"<p>The server is responsible for handling multiple clients, managing the game state, and ensuring that each player receives timely updates about the game environment. The game server employs an ECS pattern to efficiently manage entities like players, enemies, missiles, and coins. It also uses Boost.Asio for asynchronous networking to handle both TCP (initial connections) and UDP (real-time game updates).</p>"},{"location":"architecture/server_client/#32-key-components","title":"3.2 Key Components","text":"<ul> <li>Registry: Stores all entities in the game, including components like position, velocity, health, etc.</li> <li>Systems: Handles the game logic for movement, collision detection, shooting, and other mechanics.</li> <li>UDP Communication: Sends and receives game state updates, player inputs, and entity changes.</li> <li>Heartbeat Monitoring: Tracks client activity and handles disconnection if a client stops responding.</li> </ul>"},{"location":"architecture/server_client/#33-server-functionality","title":"3.3 Server Functionality","text":"<ul> <li> <p>Handling Client Connections:</p> <ul> <li>The server listens on a UDP socket for new connections. Once a connection request is received (<code>0x01</code> from the client), the server acknowledges the connection (<code>0x02</code>).</li> </ul> </li> <li> <p>Game State Management:</p> <ul> <li>The server manages the state of the game world, including player positions, health, scores, and the position of entities (enemies, missiles, coins).</li> <li>Player inputs (<code>0x03</code>) are received from the client, and based on these inputs, the server updates the player\u2019s position and sends back the updated state of the world (<code>0x04</code> to <code>0x11</code>).</li> </ul> </li> <li> <p>Real-Time Updates:</p> <ul> <li>The server processes updates in a game loop. It handles inputs, updates entity positions, detects collisions, and broadcasts changes back to all connected clients.</li> </ul> </li> <li> <p>Room and Session Management:</p> <ul> <li>The server can manage different game rooms, allowing players to join, leave, or create rooms dynamically.</li> </ul> </li> </ul>"},{"location":"architecture/server_client/#34-important-classes","title":"3.4 Important Classes","text":"<ul> <li> <p><code>Server</code>: Manages the main game loop, handles UDP communication, processes messages, and updates the ECS registry.</p> <ul> <li>Methods:<ul> <li><code>process_message</code>: Handles incoming UDP messages from clients.</li> <li><code>start_udp_server</code>: Initializes the UDP server to listen for client messages.</li> <li><code>notify_clients_of_disconnection</code>: Sends a notification when a client disconnects.</li> <li><code>handle_room_creation</code>: Manages room creation by players.</li> <li><code>run_game</code>: Main loop that runs the game logic.</li> </ul> </li> </ul> </li> <li> <p><code>MovementSystem</code>, <code>ShootSystem</code>, <code>CollisionSystem</code>: Handle movement, shooting, and collision detection logic, respectively.</p> </li> <li> <p><code>TimeManager</code>: Manages time-based events, such as enemy spawning or shooting intervals.</p> </li> </ul>"},{"location":"architecture/server_client/#4-client-architecture","title":"4. Client Architecture","text":""},{"location":"architecture/server_client/#41-client-overview","title":"4.1 Client Overview","text":"<p>The client is responsible for sending player inputs to the server and receiving game state updates from the server. It also manages the local game state for rendering and interacts with the ECS to update entities on the client side. The client uses Boost.Asio for UDP communication with the server.</p>"},{"location":"architecture/server_client/#42-key-components","title":"4.2 Key Components","text":"<ul> <li>Input Handling: Captures player input (up, down, left, right) and sends it to the server in real-time.</li> <li>UDP Communication: Receives updates from the server (positions of players, enemies, missiles) and sends inputs for player actions.</li> <li>Game State Rendering: Uses the ECS system to render the updated game state on the client screen.</li> </ul>"},{"location":"architecture/server_client/#43-client-functionality","title":"4.3 Client Functionality","text":"<ul> <li> <p>Player Creation:</p> <ul> <li>When a player joins, the client sends a <code>0x01</code> message to the server requesting player creation. The server acknowledges with <code>0x02</code>.</li> </ul> </li> <li> <p>Input Handling:</p> <ul> <li>The client captures player input (movement, shooting, etc.) and sends it to the server using message <code>0x03</code>. The inputs are byte-encoded, allowing the server to process player actions quickly.</li> </ul> </li> <li> <p>Receiving Game Updates:</p> <ul> <li>The client receives frequent updates from the server, including new positions of players (<code>0x04</code>), enemies (<code>0x05</code>), and other entities like coins and missiles (<code>0x09</code>, <code>0x10</code>). The client then updates its local ECS and re-renders the game world accordingly.</li> </ul> </li> <li> <p>Error Handling and Acknowledgment:</p> <ul> <li>Since UDP does not guarantee message delivery, the client handles packet loss by re-sending critical information if acknowledgment isn't received in a timely manner.</li> </ul> </li> </ul>"},{"location":"architecture/server_client/#44-important-classes","title":"4.4 Important Classes","text":"<ul> <li> <p><code>Client</code>: Manages communication with the server, sends inputs, and updates the game state based on server responses.</p> <ul> <li>Methods:<ul> <li><code>send_player_input</code>: Sends player input (e.g., movement direction) to the server.</li> <li><code>receive_game_state</code>: Receives and processes game state updates from the server.</li> <li><code>process_server_message</code>: Decodes the server's message and updates the local ECS accordingly.</li> </ul> </li> </ul> </li> <li> <p>Entity-Component System (ECS): Manages entities on the client side, allowing for efficient updates and rendering based on server messages.</p> </li> </ul>"},{"location":"architecture/server_client/#5-communication-workflow","title":"5. Communication Workflow","text":""},{"location":"architecture/server_client/#server-client-interaction-flow","title":"Server-Client Interaction Flow","text":"<ol> <li> <p>Player Connection: </p> <ul> <li>Client sends a connection request (<code>0x01</code>) to the server.</li> <li>Server acknowledges the connection and sends back <code>0x02</code>.</li> </ul> </li> <li> <p>Player Input Handling:</p> <ul> <li>Client sends player inputs (<code>0x03</code>) to the server, indicating movement directions.</li> <li>Server processes the input, updates the game state, and broadcasts the updated player and entity positions to all clients.</li> </ul> </li> <li> <p>Entity State Update:</p> <ul> <li>Server sends updates about player positions, enemy positions, and missile/coin positions to the clients using messages (<code>0x04</code> to <code>0x11</code>).</li> </ul> </li> <li> <p>Disconnection:</p> <ul> <li>If a client disconnects, the server notifies all other clients using a disconnection message, updating the game state accordingly.</li> </ul> </li> </ol>"},{"location":"developer_guide/api_documentation/","title":"API Documentation","text":""},{"location":"developer_guide/code_structure/","title":"Code Structure","text":""},{"location":"developer_guide/contributing/","title":"Contributing","text":""},{"location":"developer_guide/contributing/#contributing-to-r-type","title":"Contributing to R-Type","text":"<p>First off, thanks for taking the time to contribute! \u2764\ufe0f</p> <p>All types of contributions are encouraged and valued. See the Table of Contents for different ways to help and details about how this project handles them. Please make sure to read the relevant section before making your contribution. It will make it a lot easier for us maintainers and smooth out the experience for all involved. The community looks forward to your contributions. \ud83c\udf89</p> <p>And if you like the project, but just don't have time to contribute, that's fine. There are other easy ways to support the project and show your appreciation, which we would also be very happy about: - Star the project - Tweet about it - Refer this project in your project's readme - Mention the project at local meetups and tell your friends/colleagues</p>"},{"location":"developer_guide/contributing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Code of Conduct</li> <li>I Have a Question</li> <li>I Want To Contribute</li> <li>Reporting Bugs</li> <li>Suggesting Enhancements</li> <li>Your First Code Contribution</li> <li>Improving The Documentation</li> <li>Styleguides</li> <li>Commit Messages</li> <li>Join The Project Team</li> </ul>"},{"location":"developer_guide/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>This project and everyone participating in it is governed by the R-Type Code of Conduct. By participating, you are expected to uphold this code. Please report unacceptable behavior to &lt;&gt;.</p>"},{"location":"developer_guide/contributing/#i-have-a-question","title":"I Have a Question","text":"<p>If you want to ask a question, we assume that you have read the available Documentation.</p> <p>Before you ask a question, it is best to search for existing Issues that might help you. In case you have found a suitable issue and still need clarification, you can write your question in this issue. It is also advisable to search the internet for answers first.</p> <p>If you then still feel the need to ask a question and need clarification, we recommend the following:</p> <ul> <li>Open an Issue.</li> <li>Provide as much context as you can about what you're running into.</li> <li>Provide project and platform versions (nodejs, npm, etc), depending on what seems relevant.</li> </ul> <p>We will then take care of the issue as soon as possible.</p>"},{"location":"developer_guide/contributing/#i-want-to-contribute","title":"I Want To Contribute","text":""},{"location":"developer_guide/contributing/#legal-notice","title":"Legal Notice","text":"<p>When contributing to this project, you must agree that you have authored 100% of the content, that you have the necessary rights to the content and that the content you contribute may be provided under the project license.</p>"},{"location":"developer_guide/contributing/#reporting-bugs","title":"Reporting Bugs","text":""},{"location":"developer_guide/contributing/#before-submitting-a-bug-report","title":"Before Submitting a Bug Report","text":"<p>A good bug report shouldn't leave others needing to chase you up for more information. Therefore, we ask you to investigate carefully, collect information and describe the issue in detail in your report. Please complete the following steps in advance to help us fix any potential bug as fast as possible.</p> <ul> <li>Make sure that you are using the latest version.</li> <li>Determine if your bug is really a bug and not an error on your side e.g. using incompatible environment components/versions (Make sure that you have read the documentation. If you are looking for support, you might want to check this section).</li> <li>To see if other users have experienced (and potentially already solved) the same issue you are having, check if there is not already a bug report existing for your bug or error in the bug tracker.</li> <li>Also make sure to search the internet (including Stack Overflow) to see if users outside of the GitHub community have discussed the issue.</li> <li>Collect information about the bug:</li> <li>Stack trace (Traceback)</li> <li>OS, Platform and Version (Windows, Linux, macOS, x86, ARM)</li> <li>Version of the interpreter, compiler, SDK, runtime environment, package manager, depending on what seems relevant.</li> <li>Possibly your input and the output</li> <li>Can you reliably reproduce the issue? And can you also reproduce it with older versions?</li> </ul>"},{"location":"developer_guide/contributing/#how-do-i-submit-a-good-bug-report","title":"How Do I Submit a Good Bug Report?","text":"<p>You must never report security related issues, vulnerabilities or bugs including sensitive information to the issue tracker, or elsewhere in public. Instead sensitive bugs must be sent by email to &lt;&gt;.</p> <p>We use GitHub issues to track bugs and errors. If you run into an issue with the project:</p> <ul> <li>Open an Issue. (Since we can't be sure at this point whether it is a bug or not, we ask you not to talk about a bug yet and not to label the issue.)</li> <li>Explain the behavior you would expect and the actual behavior.</li> <li>Please provide as much context as possible and describe the reproduction steps that someone else can follow to recreate the issue on their own. This usually includes your code. For good bug reports you should isolate the problem and create a reduced test case.</li> <li>Provide the information you collected in the previous section.</li> </ul> <p>Once it's filed:</p> <ul> <li>The project team will label the issue accordingly.</li> <li>A team member will try to reproduce the issue with your provided steps. If there are no reproduction steps or no obvious way to reproduce the issue, the team will ask you for those steps and mark the issue as <code>needs-repro</code>. Bugs with the <code>needs-repro</code> tag will not be addressed until they are reproduced.</li> <li>If the team is able to reproduce the issue, it will be marked <code>needs-fix</code>, as well as possibly other tags (such as <code>critical</code>), and the issue will be left to be implemented by someone.</li> </ul>"},{"location":"developer_guide/contributing/#suggesting-enhancements","title":"Suggesting Enhancements","text":"<p>This section guides you through submitting an enhancement suggestion for R-Type, including completely new features and minor improvements to existing functionality. Following these guidelines will help maintainers and the community to understand your suggestion and find related suggestions.</p>"},{"location":"developer_guide/contributing/#before-submitting-an-enhancement","title":"Before Submitting an Enhancement","text":"<ul> <li>Make sure that you are using the latest version.</li> <li>Read the documentation carefully and find out if the functionality is already covered, maybe by an individual configuration.</li> <li>Perform a search to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one.</li> <li>Find out whether your idea fits with the scope and aims of the project. It's up to you to make a strong case to convince the project's developers of the merits of this feature. Keep in mind that we want features that will be useful to the majority of our users and not just a small subset. If you're just targeting a minority of users, consider writing an add-on/plugin library.</li> </ul>"},{"location":"developer_guide/contributing/#how-do-i-submit-a-good-enhancement-suggestion","title":"How Do I Submit a Good Enhancement Suggestion?","text":"<p>Enhancement suggestions are tracked as GitHub issues.</p> <ul> <li>Use a clear and descriptive title for the issue to identify the suggestion.</li> <li>Provide a step-by-step description of the suggested enhancement in as many details as possible.</li> <li>Describe the current behavior and explain which behavior you expected to see instead and why. At this point you can also tell which alternatives do not work for you.</li> <li>You may want to include screenshots and animated GIFs which help you demonstrate the steps or point out the part which the suggestion is related to. You can use this tool to record GIFs on macOS and Windows, and this tool or this tool on Linux. </li> <li>Explain why this enhancement would be useful to most R-Type users. You may also want to point out the other projects that solved it better and which could serve as inspiration.</li> </ul>"},{"location":"developer_guide/contributing/#your-first-code-contribution","title":"Your First Code Contribution","text":""},{"location":"developer_guide/contributing/#improving-the-documentation","title":"Improving The Documentation","text":""},{"location":"developer_guide/contributing/#styleguides","title":"Styleguides","text":""},{"location":"developer_guide/contributing/#commit-messages","title":"Commit Messages","text":""},{"location":"developer_guide/contributing/#join-the-project-team","title":"Join The Project Team","text":""},{"location":"developer_guide/contributing/#attribution","title":"Attribution","text":"<p>This guide is based on the contributing-gen. Make your own!</p>"},{"location":"developer_guide/how_to_guides/","title":"How-To Guides","text":""},{"location":"installation/build_instructions/","title":"Build Instructions","text":"<p>Build the project using CMake and ensure you manage third-party dependencies with conan.</p> <p>Network Security</p> <p>Running the server on a public network may expose it to security risks; consider implementing proper security measures.</p>"},{"location":"installation/build_instructions/#on-linux","title":"On Linux","text":"<ul> <li>You may execute the script <code>install.sh</code>: <pre><code>chmod +x install.sh\n./install.sh\ncp bin/r-type_server bin/r-type_server ..\n</code></pre></li> </ul> <p>or the following commands: <pre><code>make build\n</code></pre></p>"},{"location":"installation/build_instructions/#on-windows","title":"On Windows","text":"<ul> <li>You may execute the script <code>build.bat</code>: <pre><code>mkdir build\ncd build\nconan install .. --build=missing\ncmake -DCMAKE_MODULE_PATH=\"$(pwd)\" -DCMAKE_SYSTEM_NAME=Windows -DCMAKE_CXX_COMPILER=i686-w64-mingw32-g++ ..\nmsbuild .\\r-type_client.vcxproj\nmsbuild .\\r-type_client.vcxproj\ncopy \".\\bin\\r-type_server.exe\" .\ncopy \".\\bin\\r-type_client.exe\" .\n</code></pre></li> </ul> <p>If you have make install on your system execute the command below: <pre><code>make build\n</code></pre></p>"},{"location":"installation/prerequisites/","title":"Pre-requisites","text":"<p>Ensure that you have the following tools installed:</p> <ul> <li>CMake</li> <li>Conan (for managing third-party dependencies)</li> <li>C++ compiler (GCC or MinGW)</li> </ul>"},{"location":"installation/running/","title":"Running Instructions","text":"<p>To run the project you can watch the following video Video</p>"},{"location":"user_documentation/controls/","title":"Controls","text":""},{"location":"user_documentation/controls/#game-instructions-how-to-play-the-multiplayer-game","title":"Game Instructions: How to Play the Multiplayer Game","text":"<p>Welcome to the multiplayer UDP-based game! This guide will help you understand how to play, control your character, and interact with other players in the game world.</p>"},{"location":"user_documentation/controls/#1-getting-started","title":"1. Getting Started","text":"<ul> <li>Client Connection: As a player, you will be connected to a server that manages all players and entities in the game world.</li> <li>UDP Protocol: The game uses fast UDP connections to communicate with the server. This means low latency for better real-time performance but with some packet loss tolerance.</li> </ul>"},{"location":"user_documentation/controls/#2-basic-controls","title":"2. Basic Controls","text":"<p>Once you're connected to the game, you can control your player using the following keys to move around:</p> <ul> <li>Up: Move your character upwards (0x02 command sent to the server).</li> <li>Down: Move your character downwards.</li> <li>Left: Move your character left.</li> <li>Right: Move your character right.</li> </ul> <p>Your inputs are instantly sent to the server, which processes the movement and sends back the updated positions of all players.</p>"},{"location":"user_documentation/controls/#3-player-actions","title":"3. Player Actions","text":"<ul> <li>Join the Game: Upon joining, your player is created on the server (0x01 message). The server sends back your player\u2019s details, and you will see yourself on the screen.</li> <li>Control Your Character: Use the arrow keys or assigned input keys to move your character around the map. The server processes your actions and updates your position for all players to see.</li> <li>Interact with Other Players: You will see other players in the game world. Their movements and actions are also processed and broadcasted by the server.</li> </ul>"},{"location":"user_documentation/controls/#4-gameplay-elements","title":"4. Gameplay Elements","text":"<ul> <li>Enemies: Enemies will spawn in the game. The server will broadcast their movements to all players. Your goal is to avoid or destroy them using your in-game abilities.</li> <li>Missiles and Attacks: You can attack enemies by shooting missiles (handled by the server). Each time you shoot, a message is sent to the server, which handles the collision and updates the enemy's status.</li> <li>Coins: Collect in-game coins that appear on the map. These are randomly spawned by the server and picking them up will boost your score.</li> <li>Health and Score: The server keeps track of your health and score. You will be notified when your health decreases due to enemy hits or when your score increases as you collect coins or defeat enemies.</li> </ul>"},{"location":"user_documentation/controls/#5-multiplayer-interactions","title":"5. Multiplayer Interactions","text":"<ul> <li>Disconnections: If a player disconnects, the server will notify all remaining players (with 0x04). The player will be removed from the game world.</li> <li>Player Death: If your player dies (health reaches 0), the server will broadcast your death to all other players. You will have to wait for a respawn to rejoin the game.</li> <li>Score Leaderboard: The server keeps track of all players' scores. You can see your rank compared to other players during the game.</li> </ul>"},{"location":"user_documentation/controls/#6-game-objectives","title":"6. Game Objectives","text":"<ul> <li>Survival: Stay alive by avoiding enemy attacks and hazards. Your health will decrease if you get hit.</li> <li>High Score: Collect coins and defeat enemies to increase your score. Compete with other players to reach the top of the leaderboard.</li> <li>Cooperation or Competition: Depending on the game mode, you can either team up with other players to fight enemies or compete against them for the highest score.</li> </ul>"},{"location":"user_documentation/controls/#7-game-status-updates","title":"7. Game Status Updates","text":"<p>The server sends regular updates to all clients, including:</p> <ul> <li>New Player Positions: Whenever a player moves, all clients receive updated position data.</li> <li>Enemy and Object Positions: The server broadcasts new enemy and object locations, which you need to avoid or interact with.</li> <li>Player Deaths and Disconnections: Receive real-time notifications if a player disconnects or dies during gameplay.</li> </ul> <p>Now that you know the basics, jump in and enjoy the game! Stay sharp, coordinate with your teammates, and aim for the top score!</p>"},{"location":"user_documentation/faq/","title":"FAQ","text":""},{"location":"user_documentation/gameplay_overview/","title":"Gameplay Overview","text":""},{"location":"user_documentation/gameplay_overview/#game-objective","title":"Game Objective","text":"<p>R-Type is a horizontal scrolling shoot-'em-up game where players pilot a spaceship to fight waves of enemies called the Bydos. The goal is to survive through levels filled with enemies, obstacles, and bosses, using strategic movement and shooting skills.</p>"},{"location":"user_documentation/gameplay_overview/#players-and-controls","title":"Players and Controls","text":"<p>Each player controls a spaceship using the following inputs:</p> <ul> <li>Arrow Keys: <ul> <li>Up, Down, Left, and Right to move.</li> </ul> </li> <li>Fire Button: Shoot missiles.</li> <li>Special Attack: Launch charged shots (if available).</li> </ul> <p>Gameplay Actions: 1. Player connection is initiated with the command:    <code>0x01</code> - Spawns the player in the game. 2. Movement commands:    <code>0x03</code> + Direction Codes    Example:    - <code>0x03 0x01</code> \u2192 Move Up    - <code>0x03 0x02</code> \u2192 Move Down    - <code>0x03 0x03</code> \u2192 Move Left    - <code>0x03 0x04</code> \u2192 Move Right  </p>"},{"location":"user_documentation/gameplay_overview/#game-world","title":"Game World","text":"<p>The game screen scrolls horizontally at a constant pace, with various elements dynamically appearing.</p> <pre><code>+-------------------------------------------------------------------+\n|                     Starfield Scrolling Background                |\n|                                                                   |\n|         Player 1 --&gt; [P1]                 Monster --&gt; [M]         |\n|                      +--------+            +-----+                |\n|         Player 2 --&gt; [P2]      Missile --&gt; [ ]---&gt;                |\n|                       *Power-up Spawner                           |\n|                                                                   |\n|         Obstacles --&gt; [X]   Boss --&gt; [B]                          |\n+-------------------------------------------------------------------+\n</code></pre>"},{"location":"user_documentation/gameplay_overview/#key-gameplay-elements","title":"Key Gameplay Elements:","text":"<ol> <li>Starfield Background: A scrolling starry space environment.</li> <li>Players (P1, P2, etc.): Up to 4 players with distinct sprites.</li> <li>Bydos Enemies (M): Various monsters with unique patterns and attacks.</li> <li>Obstacles (X): Static or moving barriers blocking players.</li> <li>Bosses (B): Powerful enemies with multiple attack phases.</li> <li>Power-ups: Items spawning randomly to upgrade players' abilities.</li> </ol>"},{"location":"user_documentation/gameplay_overview/#gameplay-flow","title":"Gameplay Flow","text":"<ol> <li> <p>Player Spawning    Upon connecting (<code>0x01</code>), the player spaceship appears on the left side of the screen.</p> </li> <li> <p>Movement and Input Handling    The player sends movement commands (e.g., <code>0x03</code> for movement + direction code) to the server. The server synchronizes the game state across all connected clients.</p> </li> <li> <p>Enemy Spawn and Interaction    Enemies randomly appear on the right side and move left. Players must shoot them down using missiles and special attacks.</p> </li> <li> <p>Power-ups and Obstacles    Destroying certain enemies spawns power-ups. Players collect these for enhancements. Obstacles add complexity to movement.</p> </li> <li> <p>Boss Battles    At the end of each level, players encounter a boss. Players must coordinate to defeat it while avoiding attacks.</p> </li> </ol>"},{"location":"user_documentation/gameplay_overview/#networking-and-synchronization","title":"Networking and Synchronization","text":"<p>The game follows a client-server architecture, where the server manages game logic and synchronizes it with the clients. All in-game communication, such as movement and enemy positions, uses UDP packets to ensure low-latency communication.</p>"},{"location":"user_documentation/gameplay_overview/#player-command-protocol","title":"Player Command Protocol:","text":"<ul> <li><code>0x01</code>: Player connection and spawning.</li> <li><code>0x03</code> + Movement: Moves the player in the specified direction.</li> <li><code>0x04</code> + Fire: Fires a missile.</li> <li><code>0x05</code> + Special Attack: Triggers a charged shot.</li> </ul> <p>The server ensures consistency by notifying all clients about: - Player movements. - Enemy spawns and deaths. - Power-up availability. - Boss encounters.</p>"},{"location":"user_documentation/gameplay_overview/#ascii-representation-of-a-game-round","title":"ASCII Representation of a Game Round","text":"<pre><code>+---------------------------------------------------------------+\n| [P1]          *       [M]       [M]         [B]               |\n|               |                 |                             |\n|        [P2]---&gt;                 +-------&gt; [ ]---&gt;             |\n|                           Power-up Spawner                    |\n|  [X]            [P3]   +--------------------+                 |\n|                                                               |\n|                       BOSS Fight!                             |\n+---------------------------------------------------------------+\n</code></pre> <p>In this scenario: - P1 and P2 are actively shooting enemies. - A boss (B) is advancing, with players coordinating to defeat it. - Power-ups are available for collection.</p>"},{"location":"user_documentation/multiplayer_setup/","title":"Multiplayer Setup","text":"<p>The multiplayer setup in R-Type allows players to connect to a central server to coordinate gameplay, share state updates, and interact in real time. This section explains the architecture, protocols, and processes involved in setting up and managing multiplayer sessions.</p>"},{"location":"user_documentation/multiplayer_setup/#architecture-overview","title":"Architecture Overview","text":"<p>R-Type uses a client-server architecture: - Server: Manages game logic, player states, and synchronization. - Clients: Send player inputs to the server and render game events received from the server.</p> <p>Communication Protocols: - UDP: For fast, non-blocking communication (player movements, game state updates).</p>"},{"location":"user_documentation/multiplayer_setup/#multiplayer-flow","title":"Multiplayer Flow","text":"<p>The following ASCII diagram summarizes how players interact with the server and each other in multiplayer mode.</p> <pre><code>+-------------------+           +-------------------+\n|      Client 1     |           |      Client 2     |\n| [Controls Player] |           | [Controls Player] |\n+-------------------+           +-------------------+\n           \\                          /\n            \\                        /\n             \\                      /\n           +---------------------------+\n           |         Server            |\n           |  - Syncs Game State       |\n           |  - Handles Player Inputs  |\n           |  - Manages Rooms          |\n           +---------------------------+\n                        |\n           +----------------------------+\n           |         Database           |\n           |  - Stores Room Info        |\n           |  - Tracks Player Scores    |\n           +----------------------------+\n</code></pre>"},{"location":"user_documentation/multiplayer_setup/#player-lifecycle-in-multiplayer","title":"Player Lifecycle in Multiplayer","text":""},{"location":"user_documentation/multiplayer_setup/#1-connecting-to-the-server","title":"1. Connecting to the Server","text":"<ol> <li>Players initiate a connection by sending a login request over UDP.</li> <li>The server responds with an acknowledgment, and the player is spawned in the game world.</li> </ol> <p>Protocol Command: <code>0x01</code> \u2192 Player Connected </p>"},{"location":"user_documentation/multiplayer_setup/#2-joining-or-creating-a-room","title":"2. Joining or Creating a Room","text":"<p>Players can either: - List Available Rooms   Command: <code>LIST_ROOMS</code> - Join a Room   Command: <code>JOIN_ROOM &lt;room_id&gt;</code> - Create a Room   Command: <code>CREATE_ROOM &lt;room_name&gt;</code> </p> <p>If the player is idle for too long, the server will mark them as disconnected.  </p>"},{"location":"user_documentation/multiplayer_setup/#3-in-game-communication-and-state-synchronization","title":"3. In-Game Communication and State Synchronization","text":"<ul> <li>Movement and Input Updates: Sent over UDP to avoid latency issues.  </li> <li>Game Events (such as enemy deaths or power-ups): Broadcasted by the server to all clients.</li> </ul> <p>Protocol: <code>0x03</code> + Direction (<code>0x01</code> = Up, <code>0x02</code> = Down, etc.) The server calculates the new position and sends it to all clients.</p>"},{"location":"user_documentation/multiplayer_setup/#4-player-disconnection-handling","title":"4. Player Disconnection Handling","text":"<p>If a player disconnects (either by closing the game or crashing), the server notifies all connected clients.</p> <pre><code>+-----------+                +--------------+\n|   Player  |  -------&gt;      |    Server    |\n+-----------+   Disconnect   +--------------+\n                Notifies other players:\n   \"Player 1 has disconnected.\"\n</code></pre>"},{"location":"user_documentation/multiplayer_setup/#room-system-and-matchmaking","title":"Room System and Matchmaking","text":"<p>The Room System allows players to form lobbies, create custom matches, or join existing rooms.</p>"},{"location":"user_documentation/multiplayer_setup/#room-management-commands","title":"Room Management Commands","text":"<ol> <li>LIST_ROOMS </li> <li>Lists all available rooms for players to join.</li> <li>JOIN_ROOM  <li>Joins the specified room.</li> <li>CREATE_ROOM  <li>Creates a new room with the given name.</li>"},{"location":"user_documentation/multiplayer_setup/#multiplayer-setup-flow","title":"Multiplayer Setup Flow","text":"<pre><code>[Client 1]   ---&gt;   Connect to Server   ---&gt;   [Server]\n                    Send: 0x01 Player Connected\n\n[Client 2]   ---&gt;   Connect to Server   ---&gt;   [Server]\n\n[Both Clients]   ---&gt;  Play the Game  ---&gt;  [Server]\n</code></pre>"},{"location":"user_documentation/multiplayer_setup/#player-input","title":"Player Input","text":"<p>Below is how player inputs are sent to the server for movement and shooting:</p> <pre><code>[Client]   ---&gt;   0x03 + 0x01 (Move Up)    ---&gt;    [Server]\n[Client]   ---&gt;   0x04 (Fire Missile)      ---&gt;    [Server]\n</code></pre> <p>The server sends back updated positions and game state to all clients over UDP.</p>"},{"location":"user_documentation/multiplayer_setup/#handling-disconnections","title":"Handling Disconnections","text":"<p>The server monitors all clients using heartbeat signals to ensure they are still active. If no signal is received for a certain period, the server: 1. Marks the client as disconnected. 2. Removes the client from the room. 3. Notifies other clients.</p> <pre><code>+-----------+                +--------------+\n|  Player 1 |   Timeout --&gt;  |    Server    |\n+-----------+                +--------------+\n \"Player 1 has disconnected.\" Broadcast to other players.\n</code></pre>"},{"location":"user_documentation/multiplayer_setup/#heartbeat-monitoring","title":"Heartbeat Monitoring","text":"<p>This example ensures the server keeps track of client connections.</p> <pre><code>void Server::start_heartbeat_monitor() {\n    std::thread([this]() {\n        while (true) {\n            auto now = std::chrono::steady_clock::now();\n            for (auto it = clients_me.begin(); it != clients_me.end();) {\n                auto time_since_last_ping = \n                    std::chrono::duration_cast&lt;std::chrono::seconds&gt;(\n                        now - it-&gt;second.last_ping);\n\n                if (time_since_last_ping.count() &gt; 10) {\n                    notify_clients_of_disconnection(io_context, it-&gt;first);\n                    it = clients_me.erase(it);\n                } else {\n                    ++it;\n                }\n            }\n            std::this_thread::sleep_for(std::chrono::seconds(1));\n        }\n    }).detach();\n}\n</code></pre>"}]}